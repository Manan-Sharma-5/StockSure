{"ast":null,"code":"/* eslint max-len: 0 */\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts â€” that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport { flowParseArrow, flowParseFunctionBodyAndFinish, flowParseMaybeAssign, flowParseSubscript, flowParseSubscripts, flowParseVariance, flowStartParseAsyncArrowFromCallExpression, flowStartParseNewArguments, flowStartParseObjPropValue } from \"../plugins/flow\";\nimport { jsxParseElement } from \"../plugins/jsx/index\";\nimport { typedParseConditional, typedParseParenItem } from \"../plugins/types\";\nimport { tsParseArrow, tsParseFunctionBodyAndFinish, tsParseMaybeAssign, tsParseSubscript, tsParseType, tsParseTypeAssertion, tsStartParseAsyncArrowFromCallExpression, tsStartParseObjPropValue } from \"../plugins/typescript\";\nimport { eat, IdentifierRole, lookaheadCharCode, lookaheadType, match, next, nextTemplateToken, popTypeContext, pushTypeContext, rescan_gt, retokenizeSlashAsRegex } from \"../tokenizer/index\";\nimport { ContextualKeyword } from \"../tokenizer/keywords\";\nimport { Scope } from \"../tokenizer/state\";\nimport { TokenType, TokenType as tt } from \"../tokenizer/types\";\nimport { charCodes } from \"../util/charcodes\";\nimport { IS_IDENTIFIER_START } from \"../util/identifier\";\nimport { getNextContextId, isFlowEnabled, isJSXEnabled, isTypeScriptEnabled, state } from \"./base\";\nimport { markPriorBindingIdentifier, parseBindingIdentifier, parseMaybeDefault, parseRest, parseSpread } from \"./lval\";\nimport { parseBlock, parseBlockBody, parseClass, parseDecorators, parseFunction, parseFunctionParams } from \"./statement\";\nimport { canInsertSemicolon, eatContextual, expect, expectContextual, hasFollowingLineBreak, hasPrecedingLineBreak, isContextual, unexpected } from \"./util\";\nexport class StopState {\n  constructor(stop) {\n    this.stop = stop;\n  }\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function (s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\nexport function parseExpression() {\n  let noIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  parseMaybeAssign(noIn);\n  if (match(tt.comma)) {\n    while (eat(tt.comma)) {\n      parseMaybeAssign(noIn);\n    }\n  }\n}\n\n/**\n * noIn is used when parsing a for loop so that we don't interpret a following \"in\" as the binary\n * operatior.\n * isWithinParens is used to indicate that we're parsing something that might be a comma expression\n * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).\n * In these cases, we should allow : and ?: after the initial \"left\" part.\n */\nexport function parseMaybeAssign() {\n  let noIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  let isWithinParens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (isTypeScriptEnabled) {\n    return tsParseMaybeAssign(noIn, isWithinParens);\n  } else if (isFlowEnabled) {\n    return flowParseMaybeAssign(noIn, isWithinParens);\n  } else {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n// Returns true if the expression was an arrow function.\nexport function baseParseMaybeAssign(noIn, isWithinParens) {\n  if (match(tt._yield)) {\n    parseYield();\n    return false;\n  }\n  if (match(tt.parenL) || match(tt.name) || match(tt._yield)) {\n    state.potentialArrowAt = state.start;\n  }\n  const wasArrow = parseMaybeConditional(noIn);\n  if (isWithinParens) {\n    parseParenItem();\n  }\n  if (state.type & TokenType.IS_ASSIGN) {\n    next();\n    parseMaybeAssign(noIn);\n    return false;\n  }\n  return wasArrow;\n}\n\n// Parse a ternary conditional (`?:`) operator.\n// Returns true if the expression was an arrow function.\nfunction parseMaybeConditional(noIn) {\n  const wasArrow = parseExprOps(noIn);\n  if (wasArrow) {\n    return true;\n  }\n  parseConditional(noIn);\n  return false;\n}\nfunction parseConditional(noIn) {\n  if (isTypeScriptEnabled || isFlowEnabled) {\n    typedParseConditional(noIn);\n  } else {\n    baseParseConditional(noIn);\n  }\n}\nexport function baseParseConditional(noIn) {\n  if (eat(tt.question)) {\n    parseMaybeAssign();\n    expect(tt.colon);\n    parseMaybeAssign(noIn);\n  }\n}\n\n// Start the precedence parser.\n// Returns true if this was an arrow function\nfunction parseExprOps(noIn) {\n  const startTokenIndex = state.tokens.length;\n  const wasArrow = parseMaybeUnary();\n  if (wasArrow) {\n    return true;\n  }\n  parseExprOp(startTokenIndex, -1, noIn);\n  return false;\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\nfunction parseExprOp(startTokenIndex, minPrec, noIn) {\n  if (isTypeScriptEnabled && (tt._in & TokenType.PRECEDENCE_MASK) > minPrec && !hasPrecedingLineBreak() && (eatContextual(ContextualKeyword._as) || eatContextual(ContextualKeyword._satisfies))) {\n    const oldIsType = pushTypeContext(1);\n    tsParseType();\n    popTypeContext(oldIsType);\n    rescan_gt();\n    parseExprOp(startTokenIndex, minPrec, noIn);\n    return;\n  }\n  const prec = state.type & TokenType.PRECEDENCE_MASK;\n  if (prec > 0 && (!noIn || !match(tt._in))) {\n    if (prec > minPrec) {\n      const op = state.type;\n      next();\n      if (op === tt.nullishCoalescing) {\n        state.tokens[state.tokens.length - 1].nullishStartIndex = startTokenIndex;\n      }\n      const rhsStartTokenIndex = state.tokens.length;\n      parseMaybeUnary();\n      // Extend the right operand of this operator if possible.\n      parseExprOp(rhsStartTokenIndex, op & TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);\n      if (op === tt.nullishCoalescing) {\n        state.tokens[startTokenIndex].numNullishCoalesceStarts++;\n        state.tokens[state.tokens.length - 1].numNullishCoalesceEnds++;\n      }\n      // Continue with any future operator holding this expression as the left operand.\n      parseExprOp(startTokenIndex, minPrec, noIn);\n    }\n  }\n}\n\n// Parse unary operators, both prefix and postfix.\n// Returns true if this was an arrow function.\nexport function parseMaybeUnary() {\n  if (isTypeScriptEnabled && !isJSXEnabled && eat(tt.lessThan)) {\n    tsParseTypeAssertion();\n    return false;\n  }\n  if (isContextual(ContextualKeyword._module) && lookaheadCharCode() === charCodes.leftCurlyBrace && !hasFollowingLineBreak()) {\n    parseModuleExpression();\n    return false;\n  }\n  if (state.type & TokenType.IS_PREFIX) {\n    next();\n    parseMaybeUnary();\n    return false;\n  }\n  const wasArrow = parseExprSubscripts();\n  if (wasArrow) {\n    return true;\n  }\n  while (state.type & TokenType.IS_POSTFIX && !canInsertSemicolon()) {\n    // The tokenizer calls everything a preincrement, so make it a postincrement when\n    // we see it in that context.\n    if (state.type === tt.preIncDec) {\n      state.type = tt.postIncDec;\n    }\n    next();\n  }\n  return false;\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n// Returns true if this was an arrow function.\nexport function parseExprSubscripts() {\n  const startTokenIndex = state.tokens.length;\n  const wasArrow = parseExprAtom();\n  if (wasArrow) {\n    return true;\n  }\n  parseSubscripts(startTokenIndex);\n  // If there was any optional chain operation, the start token would be marked\n  // as such, so also mark the end now.\n  if (state.tokens.length > startTokenIndex && state.tokens[startTokenIndex].isOptionalChainStart) {\n    state.tokens[state.tokens.length - 1].isOptionalChainEnd = true;\n  }\n  return false;\n}\nfunction parseSubscripts(startTokenIndex) {\n  let noCalls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (isFlowEnabled) {\n    flowParseSubscripts(startTokenIndex, noCalls);\n  } else {\n    baseParseSubscripts(startTokenIndex, noCalls);\n  }\n}\nexport function baseParseSubscripts(startTokenIndex) {\n  let noCalls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const stopState = new StopState(false);\n  do {\n    parseSubscript(startTokenIndex, noCalls, stopState);\n  } while (!stopState.stop && !state.error);\n}\nfunction parseSubscript(startTokenIndex, noCalls, stopState) {\n  if (isTypeScriptEnabled) {\n    tsParseSubscript(startTokenIndex, noCalls, stopState);\n  } else if (isFlowEnabled) {\n    flowParseSubscript(startTokenIndex, noCalls, stopState);\n  } else {\n    baseParseSubscript(startTokenIndex, noCalls, stopState);\n  }\n}\n\n/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */\nexport function baseParseSubscript(startTokenIndex, noCalls, stopState) {\n  if (!noCalls && eat(tt.doubleColon)) {\n    parseNoCallExpr();\n    stopState.stop = true;\n    // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want\n    // to revisit this in the future when fully supporting bind syntax.\n    parseSubscripts(startTokenIndex, noCalls);\n  } else if (match(tt.questionDot)) {\n    state.tokens[startTokenIndex].isOptionalChainStart = true;\n    if (noCalls && lookaheadType() === tt.parenL) {\n      stopState.stop = true;\n      return;\n    }\n    next();\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    if (eat(tt.bracketL)) {\n      parseExpression();\n      expect(tt.bracketR);\n    } else if (eat(tt.parenL)) {\n      parseCallExpressionArguments();\n    } else {\n      parseMaybePrivateName();\n    }\n  } else if (eat(tt.dot)) {\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseMaybePrivateName();\n  } else if (eat(tt.bracketL)) {\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseExpression();\n    expect(tt.bracketR);\n  } else if (!noCalls && match(tt.parenL)) {\n    if (atPossibleAsync()) {\n      // We see \"async\", but it's possible it's a usage of the name \"async\". Parse as if it's a\n      // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.\n      const snapshot = state.snapshot();\n      const asyncStartTokenIndex = state.tokens.length;\n      next();\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      const callContextId = getNextContextId();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      if (shouldParseAsyncArrow()) {\n        // We hit an arrow, so backtrack and start again parsing function parameters.\n        state.restoreFromSnapshot(snapshot);\n        stopState.stop = true;\n        state.scopeDepth++;\n        parseFunctionParams();\n        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);\n      }\n    } else {\n      next();\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      const callContextId = getNextContextId();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n    }\n  } else if (match(tt.backQuote)) {\n    // Tagged template expression.\n    parseTemplate();\n  } else {\n    stopState.stop = true;\n  }\n}\nexport function atPossibleAsync() {\n  // This was made less strict than the original version to avoid passing around nodes, but it\n  // should be safe to have rare false positives here.\n  return state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async && !canInsertSemicolon();\n}\nexport function parseCallExpressionArguments() {\n  let first = true;\n  while (!eat(tt.parenR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.parenR)) {\n        break;\n      }\n    }\n    parseExprListItem(false);\n  }\n}\nfunction shouldParseAsyncArrow() {\n  return match(tt.colon) || match(tt.arrow);\n}\nfunction parseAsyncArrowFromCallExpression(startTokenIndex) {\n  if (isTypeScriptEnabled) {\n    tsStartParseAsyncArrowFromCallExpression();\n  } else if (isFlowEnabled) {\n    flowStartParseAsyncArrowFromCallExpression();\n  }\n  expect(tt.arrow);\n  parseArrowExpression(startTokenIndex);\n}\n\n// Parse a no-call expression (like argument of `new` or `::` operators).\n\nfunction parseNoCallExpr() {\n  const startTokenIndex = state.tokens.length;\n  parseExprAtom();\n  parseSubscripts(startTokenIndex, true);\n}\n\n// Parse an atomic expression â€” either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n// Returns true if the parsed expression was an arrow function.\nexport function parseExprAtom() {\n  if (eat(tt.modulo)) {\n    // V8 intrinsic expression. Just parse the identifier, and the function invocation is parsed\n    // naturally.\n    parseIdentifier();\n    return false;\n  }\n  if (match(tt.jsxText) || match(tt.jsxEmptyText)) {\n    parseLiteral();\n    return false;\n  } else if (match(tt.lessThan) && isJSXEnabled) {\n    state.type = tt.jsxTagStart;\n    jsxParseElement();\n    next();\n    return false;\n  }\n  const canBeArrow = state.potentialArrowAt === state.start;\n  switch (state.type) {\n    case tt.slash:\n    case tt.assign:\n      retokenizeSlashAsRegex();\n    // Fall through.\n\n    case tt._super:\n    case tt._this:\n    case tt.regexp:\n    case tt.num:\n    case tt.bigint:\n    case tt.decimal:\n    case tt.string:\n    case tt._null:\n    case tt._true:\n    case tt._false:\n      next();\n      return false;\n    case tt._import:\n      next();\n      if (match(tt.dot)) {\n        // import.meta\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        next();\n        parseIdentifier();\n      }\n      return false;\n    case tt.name:\n      {\n        const startTokenIndex = state.tokens.length;\n        const functionStart = state.start;\n        const contextualKeyword = state.contextualKeyword;\n        parseIdentifier();\n        if (contextualKeyword === ContextualKeyword._await) {\n          parseAwait();\n          return false;\n        } else if (contextualKeyword === ContextualKeyword._async && match(tt._function) && !canInsertSemicolon()) {\n          next();\n          parseFunction(functionStart, false);\n          return false;\n        } else if (canBeArrow && contextualKeyword === ContextualKeyword._async && !canInsertSemicolon() && match(tt.name)) {\n          state.scopeDepth++;\n          parseBindingIdentifier(false);\n          expect(tt.arrow);\n          // let foo = async bar => {};\n          parseArrowExpression(startTokenIndex);\n          return true;\n        } else if (match(tt._do) && !canInsertSemicolon()) {\n          next();\n          parseBlock();\n          return false;\n        }\n        if (canBeArrow && !canInsertSemicolon() && match(tt.arrow)) {\n          state.scopeDepth++;\n          markPriorBindingIdentifier(false);\n          expect(tt.arrow);\n          parseArrowExpression(startTokenIndex);\n          return true;\n        }\n        state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.Access;\n        return false;\n      }\n    case tt._do:\n      {\n        next();\n        parseBlock();\n        return false;\n      }\n    case tt.parenL:\n      {\n        const wasArrow = parseParenAndDistinguishExpression(canBeArrow);\n        return wasArrow;\n      }\n    case tt.bracketL:\n      next();\n      parseExprList(tt.bracketR, true);\n      return false;\n    case tt.braceL:\n      parseObj(false, false);\n      return false;\n    case tt._function:\n      parseFunctionExpression();\n      return false;\n    case tt.at:\n      parseDecorators();\n    // Fall through.\n\n    case tt._class:\n      parseClass(false);\n      return false;\n    case tt._new:\n      parseNew();\n      return false;\n    case tt.backQuote:\n      parseTemplate();\n      return false;\n    case tt.doubleColon:\n      {\n        next();\n        parseNoCallExpr();\n        return false;\n      }\n    case tt.hash:\n      {\n        const code = lookaheadCharCode();\n        if (IS_IDENTIFIER_START[code] || code === charCodes.backslash) {\n          parseMaybePrivateName();\n        } else {\n          next();\n        }\n        // Smart pipeline topic reference.\n        return false;\n      }\n    default:\n      unexpected();\n      return false;\n  }\n}\nfunction parseMaybePrivateName() {\n  eat(tt.hash);\n  parseIdentifier();\n}\nfunction parseFunctionExpression() {\n  const functionStart = state.start;\n  parseIdentifier();\n  if (eat(tt.dot)) {\n    // function.sent\n    parseIdentifier();\n  }\n  parseFunction(functionStart, false);\n}\nexport function parseLiteral() {\n  next();\n}\nexport function parseParenExpression() {\n  expect(tt.parenL);\n  parseExpression();\n  expect(tt.parenR);\n}\n\n// Returns true if this was an arrow expression.\nfunction parseParenAndDistinguishExpression(canBeArrow) {\n  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and\n  // start over as a parameter list.\n  const snapshot = state.snapshot();\n  const startTokenIndex = state.tokens.length;\n  expect(tt.parenL);\n  let first = true;\n  while (!match(tt.parenR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (match(tt.parenR)) {\n        break;\n      }\n    }\n    if (match(tt.ellipsis)) {\n      parseRest(false /* isBlockScope */);\n      parseParenItem();\n      break;\n    } else {\n      parseMaybeAssign(false, true);\n    }\n  }\n  expect(tt.parenR);\n  if (canBeArrow && shouldParseArrow()) {\n    const wasArrow = parseArrow();\n    if (wasArrow) {\n      // It was an arrow function this whole time, so start over and parse it as params so that we\n      // get proper token annotations.\n      state.restoreFromSnapshot(snapshot);\n      state.scopeDepth++;\n      // Don't specify a context ID because arrow functions don't need a context ID.\n      parseFunctionParams();\n      parseArrow();\n      parseArrowExpression(startTokenIndex);\n      if (state.error) {\n        // Nevermind! This must have been something that looks very much like an\n        // arrow function but where its \"parameter list\" isn't actually a valid\n        // parameter list. Force non-arrow parsing.\n        // See https://github.com/alangpierce/sucrase/issues/666 for an example.\n        state.restoreFromSnapshot(snapshot);\n        parseParenAndDistinguishExpression(false);\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n}\nfunction shouldParseArrow() {\n  return match(tt.colon) || !canInsertSemicolon();\n}\n\n// Returns whether there was an arrow token.\nexport function parseArrow() {\n  if (isTypeScriptEnabled) {\n    return tsParseArrow();\n  } else if (isFlowEnabled) {\n    return flowParseArrow();\n  } else {\n    return eat(tt.arrow);\n  }\n}\nfunction parseParenItem() {\n  if (isTypeScriptEnabled || isFlowEnabled) {\n    typedParseParenItem();\n  }\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call â€” at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\nfunction parseNew() {\n  expect(tt._new);\n  if (eat(tt.dot)) {\n    // new.target\n    parseIdentifier();\n    return;\n  }\n  parseNewCallee();\n  if (isFlowEnabled) {\n    flowStartParseNewArguments();\n  }\n  if (eat(tt.parenL)) {\n    parseExprList(tt.parenR);\n  }\n}\nfunction parseNewCallee() {\n  parseNoCallExpr();\n  eat(tt.questionDot);\n}\nexport function parseTemplate() {\n  // Finish `, read quasi\n  nextTemplateToken();\n  // Finish quasi, read ${\n  nextTemplateToken();\n  while (!match(tt.backQuote) && !state.error) {\n    expect(tt.dollarBraceL);\n    parseExpression();\n    // Finish }, read quasi\n    nextTemplateToken();\n    // Finish quasi, read either ${ or `\n    nextTemplateToken();\n  }\n  next();\n}\n\n// Parse an object literal or binding pattern.\nexport function parseObj(isPattern, isBlockScope) {\n  // Attach a context ID to the object open and close brace and each object key.\n  const contextId = getNextContextId();\n  let first = true;\n  next();\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n    let isGenerator = false;\n    if (match(tt.ellipsis)) {\n      const previousIndex = state.tokens.length;\n      parseSpread();\n      if (isPattern) {\n        // Mark role when the only thing being spread over is an identifier.\n        if (state.tokens.length === previousIndex + 2) {\n          markPriorBindingIdentifier(isBlockScope);\n        }\n        if (eat(tt.braceR)) {\n          break;\n        }\n      }\n      continue;\n    }\n    if (!isPattern) {\n      isGenerator = eat(tt.star);\n    }\n    if (!isPattern && isContextual(ContextualKeyword._async)) {\n      if (isGenerator) unexpected();\n      parseIdentifier();\n      if (match(tt.colon) || match(tt.parenL) || match(tt.braceR) || match(tt.eq) || match(tt.comma)) {\n        // This is a key called \"async\" rather than an async function.\n      } else {\n        if (match(tt.star)) {\n          next();\n          isGenerator = true;\n        }\n        parsePropertyName(contextId);\n      }\n    } else {\n      parsePropertyName(contextId);\n    }\n    parseObjPropValue(isPattern, isBlockScope, contextId);\n  }\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n}\nfunction isGetterOrSetterMethod(isPattern) {\n  // We go off of the next and don't bother checking if the node key is actually \"get\" or \"set\".\n  // This lets us avoid generating a node, and should only make the validation worse.\n  return !isPattern && (match(tt.string) ||\n  // get \"string\"() {}\n  match(tt.num) ||\n  // get 1() {}\n  match(tt.bracketL) ||\n  // get [\"string\"]() {}\n  match(tt.name) ||\n  // get foo() {}\n  !!(state.type & TokenType.IS_KEYWORD)) // get debugger() {}\n  ;\n}\n\n// Returns true if this was a method.\nfunction parseObjectMethod(isPattern, objectContextId) {\n  // We don't need to worry about modifiers because object methods can't have optional bodies, so\n  // the start will never be used.\n  const functionStart = state.start;\n  if (match(tt.parenL)) {\n    if (isPattern) unexpected();\n    parseMethod(functionStart, /* isConstructor */false);\n    return true;\n  }\n  if (isGetterOrSetterMethod(isPattern)) {\n    parsePropertyName(objectContextId);\n    parseMethod(functionStart, /* isConstructor */false);\n    return true;\n  }\n  return false;\n}\nfunction parseObjectProperty(isPattern, isBlockScope) {\n  if (eat(tt.colon)) {\n    if (isPattern) {\n      parseMaybeDefault(isBlockScope);\n    } else {\n      parseMaybeAssign(false);\n    }\n    return;\n  }\n\n  // Since there's no colon, we assume this is an object shorthand.\n\n  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so\n  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to\n  // transform it on access, so mark it as a normal object shorthand.\n  let identifierRole;\n  if (isPattern) {\n    if (state.scopeDepth === 0) {\n      identifierRole = IdentifierRole.ObjectShorthandTopLevelDeclaration;\n    } else if (isBlockScope) {\n      identifierRole = IdentifierRole.ObjectShorthandBlockScopedDeclaration;\n    } else {\n      identifierRole = IdentifierRole.ObjectShorthandFunctionScopedDeclaration;\n    }\n  } else {\n    identifierRole = IdentifierRole.ObjectShorthand;\n  }\n  state.tokens[state.tokens.length - 1].identifierRole = identifierRole;\n\n  // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow\n  // parsing as if there's a default value.\n  parseMaybeDefault(isBlockScope, true);\n}\nfunction parseObjPropValue(isPattern, isBlockScope, objectContextId) {\n  if (isTypeScriptEnabled) {\n    tsStartParseObjPropValue();\n  } else if (isFlowEnabled) {\n    flowStartParseObjPropValue();\n  }\n  const wasMethod = parseObjectMethod(isPattern, objectContextId);\n  if (!wasMethod) {\n    parseObjectProperty(isPattern, isBlockScope);\n  }\n}\nexport function parsePropertyName(objectContextId) {\n  if (isFlowEnabled) {\n    flowParseVariance();\n  }\n  if (eat(tt.bracketL)) {\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n    parseMaybeAssign();\n    expect(tt.bracketR);\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n  } else {\n    if (match(tt.num) || match(tt.string) || match(tt.bigint) || match(tt.decimal)) {\n      parseExprAtom();\n    } else {\n      parseMaybePrivateName();\n    }\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ObjectKey;\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n  }\n}\n\n// Parse object or class method.\nexport function parseMethod(functionStart, isConstructor) {\n  const funcContextId = getNextContextId();\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  const allowModifiers = isConstructor; // For TypeScript parameter properties\n  parseFunctionParams(allowModifiers, funcContextId);\n  parseFunctionBodyAndFinish(functionStart, funcContextId);\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n}\n\n// Parse arrow function expression.\n// If the parameters are provided, they will be converted to an\n// assignable list.\nexport function parseArrowExpression(startTokenIndex) {\n  parseFunctionBody(true);\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n}\nexport function parseFunctionBodyAndFinish(functionStart) {\n  let funcContextId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (isTypeScriptEnabled) {\n    tsParseFunctionBodyAndFinish(functionStart, funcContextId);\n  } else if (isFlowEnabled) {\n    flowParseFunctionBodyAndFinish(funcContextId);\n  } else {\n    parseFunctionBody(false, funcContextId);\n  }\n}\nexport function parseFunctionBody(allowExpression) {\n  let funcContextId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const isExpression = allowExpression && !match(tt.braceL);\n  if (isExpression) {\n    parseMaybeAssign();\n  } else {\n    parseBlock(true /* isFunctionScope */, funcContextId);\n  }\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\nfunction parseExprList(close) {\n  let allowEmpty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let first = true;\n  while (!eat(close) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(close)) break;\n    }\n    parseExprListItem(allowEmpty);\n  }\n}\nfunction parseExprListItem(allowEmpty) {\n  if (allowEmpty && match(tt.comma)) {\n    // Empty item; nothing more to parse for this item.\n  } else if (match(tt.ellipsis)) {\n    parseSpread();\n    parseParenItem();\n  } else if (match(tt.question)) {\n    // Partial function application proposal.\n    next();\n  } else {\n    parseMaybeAssign(false, true);\n  }\n}\n\n// Parse the next token as an identifier.\nexport function parseIdentifier() {\n  next();\n  state.tokens[state.tokens.length - 1].type = tt.name;\n}\n\n// Parses await expression inside async function.\nfunction parseAwait() {\n  parseMaybeUnary();\n}\n\n// Parses yield expression inside generator.\nfunction parseYield() {\n  next();\n  if (!match(tt.semi) && !canInsertSemicolon()) {\n    eat(tt.star);\n    parseMaybeAssign();\n  }\n}\n\n// https://github.com/tc39/proposal-js-module-blocks\nfunction parseModuleExpression() {\n  expectContextual(ContextualKeyword._module);\n  expect(tt.braceL);\n  // For now, just call parseBlockBody to parse the block. In the future when we\n  // implement full support, we'll want to emit scopes and possibly other\n  // information.\n  parseBlockBody(tt.braceR);\n}","map":{"version":3,"names":["flowParseArrow","flowParseFunctionBodyAndFinish","flowParseMaybeAssign","flowParseSubscript","flowParseSubscripts","flowParseVariance","flowStartParseAsyncArrowFromCallExpression","flowStartParseNewArguments","flowStartParseObjPropValue","jsxParseElement","typedParseConditional","typedParseParenItem","tsParseArrow","tsParseFunctionBodyAndFinish","tsParseMaybeAssign","tsParseSubscript","tsParseType","tsParseTypeAssertion","tsStartParseAsyncArrowFromCallExpression","tsStartParseObjPropValue","eat","IdentifierRole","lookaheadCharCode","lookaheadType","match","next","nextTemplateToken","popTypeContext","pushTypeContext","rescan_gt","retokenizeSlashAsRegex","ContextualKeyword","Scope","TokenType","tt","charCodes","IS_IDENTIFIER_START","getNextContextId","isFlowEnabled","isJSXEnabled","isTypeScriptEnabled","state","markPriorBindingIdentifier","parseBindingIdentifier","parseMaybeDefault","parseRest","parseSpread","parseBlock","parseBlockBody","parseClass","parseDecorators","parseFunction","parseFunctionParams","canInsertSemicolon","eatContextual","expect","expectContextual","hasFollowingLineBreak","hasPrecedingLineBreak","isContextual","unexpected","StopState","constructor","stop","parseExpression","noIn","arguments","length","undefined","parseMaybeAssign","comma","isWithinParens","baseParseMaybeAssign","_yield","parseYield","parenL","name","potentialArrowAt","start","wasArrow","parseMaybeConditional","parseParenItem","type","IS_ASSIGN","parseExprOps","parseConditional","baseParseConditional","question","colon","startTokenIndex","tokens","parseMaybeUnary","parseExprOp","minPrec","_in","PRECEDENCE_MASK","_as","_satisfies","oldIsType","prec","op","nullishCoalescing","nullishStartIndex","rhsStartTokenIndex","IS_RIGHT_ASSOCIATIVE","numNullishCoalesceStarts","numNullishCoalesceEnds","lessThan","_module","leftCurlyBrace","parseModuleExpression","IS_PREFIX","parseExprSubscripts","IS_POSTFIX","preIncDec","postIncDec","parseExprAtom","parseSubscripts","isOptionalChainStart","isOptionalChainEnd","noCalls","baseParseSubscripts","stopState","parseSubscript","error","baseParseSubscript","doubleColon","parseNoCallExpr","questionDot","subscriptStartIndex","bracketL","bracketR","parseCallExpressionArguments","parseMaybePrivateName","dot","atPossibleAsync","snapshot","asyncStartTokenIndex","callContextId","contextId","shouldParseAsyncArrow","restoreFromSnapshot","scopeDepth","parseAsyncArrowFromCallExpression","backQuote","parseTemplate","contextualKeyword","_async","first","parenR","parseExprListItem","arrow","parseArrowExpression","modulo","parseIdentifier","jsxText","jsxEmptyText","parseLiteral","jsxTagStart","canBeArrow","slash","assign","_super","_this","regexp","num","bigint","decimal","string","_null","_true","_false","_import","functionStart","_await","parseAwait","_function","_do","identifierRole","Access","parseParenAndDistinguishExpression","parseExprList","braceL","parseObj","parseFunctionExpression","at","_class","_new","parseNew","hash","code","backslash","parseParenExpression","ellipsis","shouldParseArrow","parseArrow","parseNewCallee","dollarBraceL","isPattern","isBlockScope","braceR","isGenerator","previousIndex","star","eq","parsePropertyName","parseObjPropValue","isGetterOrSetterMethod","IS_KEYWORD","parseObjectMethod","objectContextId","parseMethod","parseObjectProperty","ObjectShorthandTopLevelDeclaration","ObjectShorthandBlockScopedDeclaration","ObjectShorthandFunctionScopedDeclaration","ObjectShorthand","wasMethod","ObjectKey","isConstructor","funcContextId","allowModifiers","parseFunctionBodyAndFinish","endTokenIndex","scopes","push","parseFunctionBody","allowExpression","isExpression","close","allowEmpty","semi"],"sources":["/Users/manan/Desktop/hach-unicorn/StockSure/frontend1/node_modules/sucrase/dist/esm/parser/traverser/expression.js"],"sourcesContent":["/* eslint max-len: 0 */\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts â€” that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {\n  flowParseArrow,\n  flowParseFunctionBodyAndFinish,\n  flowParseMaybeAssign,\n  flowParseSubscript,\n  flowParseSubscripts,\n  flowParseVariance,\n  flowStartParseAsyncArrowFromCallExpression,\n  flowStartParseNewArguments,\n  flowStartParseObjPropValue,\n} from \"../plugins/flow\";\nimport {jsxParseElement} from \"../plugins/jsx/index\";\nimport {typedParseConditional, typedParseParenItem} from \"../plugins/types\";\nimport {\n  tsParseArrow,\n  tsParseFunctionBodyAndFinish,\n  tsParseMaybeAssign,\n  tsParseSubscript,\n  tsParseType,\n  tsParseTypeAssertion,\n  tsStartParseAsyncArrowFromCallExpression,\n  tsStartParseObjPropValue,\n} from \"../plugins/typescript\";\nimport {\n  eat,\n  IdentifierRole,\n  lookaheadCharCode,\n  lookaheadType,\n  match,\n  next,\n  nextTemplateToken,\n  popTypeContext,\n  pushTypeContext,\n  rescan_gt,\n  retokenizeSlashAsRegex,\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {Scope} from \"../tokenizer/state\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {charCodes} from \"../util/charcodes\";\nimport {IS_IDENTIFIER_START} from \"../util/identifier\";\nimport {getNextContextId, isFlowEnabled, isJSXEnabled, isTypeScriptEnabled, state} from \"./base\";\nimport {\n  markPriorBindingIdentifier,\n  parseBindingIdentifier,\n  parseMaybeDefault,\n  parseRest,\n  parseSpread,\n} from \"./lval\";\nimport {\n  parseBlock,\n  parseBlockBody,\n  parseClass,\n  parseDecorators,\n  parseFunction,\n  parseFunctionParams,\n} from \"./statement\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  hasFollowingLineBreak,\n  hasPrecedingLineBreak,\n  isContextual,\n  unexpected,\n} from \"./util\";\n\nexport class StopState {\n  \n  constructor(stop) {\n    this.stop = stop;\n  }\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function (s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\nexport function parseExpression(noIn = false) {\n  parseMaybeAssign(noIn);\n  if (match(tt.comma)) {\n    while (eat(tt.comma)) {\n      parseMaybeAssign(noIn);\n    }\n  }\n}\n\n/**\n * noIn is used when parsing a for loop so that we don't interpret a following \"in\" as the binary\n * operatior.\n * isWithinParens is used to indicate that we're parsing something that might be a comma expression\n * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).\n * In these cases, we should allow : and ?: after the initial \"left\" part.\n */\nexport function parseMaybeAssign(noIn = false, isWithinParens = false) {\n  if (isTypeScriptEnabled) {\n    return tsParseMaybeAssign(noIn, isWithinParens);\n  } else if (isFlowEnabled) {\n    return flowParseMaybeAssign(noIn, isWithinParens);\n  } else {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n// Returns true if the expression was an arrow function.\nexport function baseParseMaybeAssign(noIn, isWithinParens) {\n  if (match(tt._yield)) {\n    parseYield();\n    return false;\n  }\n\n  if (match(tt.parenL) || match(tt.name) || match(tt._yield)) {\n    state.potentialArrowAt = state.start;\n  }\n\n  const wasArrow = parseMaybeConditional(noIn);\n  if (isWithinParens) {\n    parseParenItem();\n  }\n  if (state.type & TokenType.IS_ASSIGN) {\n    next();\n    parseMaybeAssign(noIn);\n    return false;\n  }\n  return wasArrow;\n}\n\n// Parse a ternary conditional (`?:`) operator.\n// Returns true if the expression was an arrow function.\nfunction parseMaybeConditional(noIn) {\n  const wasArrow = parseExprOps(noIn);\n  if (wasArrow) {\n    return true;\n  }\n  parseConditional(noIn);\n  return false;\n}\n\nfunction parseConditional(noIn) {\n  if (isTypeScriptEnabled || isFlowEnabled) {\n    typedParseConditional(noIn);\n  } else {\n    baseParseConditional(noIn);\n  }\n}\n\nexport function baseParseConditional(noIn) {\n  if (eat(tt.question)) {\n    parseMaybeAssign();\n    expect(tt.colon);\n    parseMaybeAssign(noIn);\n  }\n}\n\n// Start the precedence parser.\n// Returns true if this was an arrow function\nfunction parseExprOps(noIn) {\n  const startTokenIndex = state.tokens.length;\n  const wasArrow = parseMaybeUnary();\n  if (wasArrow) {\n    return true;\n  }\n  parseExprOp(startTokenIndex, -1, noIn);\n  return false;\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\nfunction parseExprOp(startTokenIndex, minPrec, noIn) {\n  if (\n    isTypeScriptEnabled &&\n    (tt._in & TokenType.PRECEDENCE_MASK) > minPrec &&\n    !hasPrecedingLineBreak() &&\n    (eatContextual(ContextualKeyword._as) || eatContextual(ContextualKeyword._satisfies))\n  ) {\n    const oldIsType = pushTypeContext(1);\n    tsParseType();\n    popTypeContext(oldIsType);\n    rescan_gt();\n    parseExprOp(startTokenIndex, minPrec, noIn);\n    return;\n  }\n\n  const prec = state.type & TokenType.PRECEDENCE_MASK;\n  if (prec > 0 && (!noIn || !match(tt._in))) {\n    if (prec > minPrec) {\n      const op = state.type;\n      next();\n      if (op === tt.nullishCoalescing) {\n        state.tokens[state.tokens.length - 1].nullishStartIndex = startTokenIndex;\n      }\n\n      const rhsStartTokenIndex = state.tokens.length;\n      parseMaybeUnary();\n      // Extend the right operand of this operator if possible.\n      parseExprOp(rhsStartTokenIndex, op & TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);\n      if (op === tt.nullishCoalescing) {\n        state.tokens[startTokenIndex].numNullishCoalesceStarts++;\n        state.tokens[state.tokens.length - 1].numNullishCoalesceEnds++;\n      }\n      // Continue with any future operator holding this expression as the left operand.\n      parseExprOp(startTokenIndex, minPrec, noIn);\n    }\n  }\n}\n\n// Parse unary operators, both prefix and postfix.\n// Returns true if this was an arrow function.\nexport function parseMaybeUnary() {\n  if (isTypeScriptEnabled && !isJSXEnabled && eat(tt.lessThan)) {\n    tsParseTypeAssertion();\n    return false;\n  }\n  if (\n    isContextual(ContextualKeyword._module) &&\n    lookaheadCharCode() === charCodes.leftCurlyBrace &&\n    !hasFollowingLineBreak()\n  ) {\n    parseModuleExpression();\n    return false;\n  }\n  if (state.type & TokenType.IS_PREFIX) {\n    next();\n    parseMaybeUnary();\n    return false;\n  }\n\n  const wasArrow = parseExprSubscripts();\n  if (wasArrow) {\n    return true;\n  }\n  while (state.type & TokenType.IS_POSTFIX && !canInsertSemicolon()) {\n    // The tokenizer calls everything a preincrement, so make it a postincrement when\n    // we see it in that context.\n    if (state.type === tt.preIncDec) {\n      state.type = tt.postIncDec;\n    }\n    next();\n  }\n  return false;\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n// Returns true if this was an arrow function.\nexport function parseExprSubscripts() {\n  const startTokenIndex = state.tokens.length;\n  const wasArrow = parseExprAtom();\n  if (wasArrow) {\n    return true;\n  }\n  parseSubscripts(startTokenIndex);\n  // If there was any optional chain operation, the start token would be marked\n  // as such, so also mark the end now.\n  if (state.tokens.length > startTokenIndex && state.tokens[startTokenIndex].isOptionalChainStart) {\n    state.tokens[state.tokens.length - 1].isOptionalChainEnd = true;\n  }\n  return false;\n}\n\nfunction parseSubscripts(startTokenIndex, noCalls = false) {\n  if (isFlowEnabled) {\n    flowParseSubscripts(startTokenIndex, noCalls);\n  } else {\n    baseParseSubscripts(startTokenIndex, noCalls);\n  }\n}\n\nexport function baseParseSubscripts(startTokenIndex, noCalls = false) {\n  const stopState = new StopState(false);\n  do {\n    parseSubscript(startTokenIndex, noCalls, stopState);\n  } while (!stopState.stop && !state.error);\n}\n\nfunction parseSubscript(startTokenIndex, noCalls, stopState) {\n  if (isTypeScriptEnabled) {\n    tsParseSubscript(startTokenIndex, noCalls, stopState);\n  } else if (isFlowEnabled) {\n    flowParseSubscript(startTokenIndex, noCalls, stopState);\n  } else {\n    baseParseSubscript(startTokenIndex, noCalls, stopState);\n  }\n}\n\n/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */\nexport function baseParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (!noCalls && eat(tt.doubleColon)) {\n    parseNoCallExpr();\n    stopState.stop = true;\n    // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want\n    // to revisit this in the future when fully supporting bind syntax.\n    parseSubscripts(startTokenIndex, noCalls);\n  } else if (match(tt.questionDot)) {\n    state.tokens[startTokenIndex].isOptionalChainStart = true;\n    if (noCalls && lookaheadType() === tt.parenL) {\n      stopState.stop = true;\n      return;\n    }\n    next();\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n    if (eat(tt.bracketL)) {\n      parseExpression();\n      expect(tt.bracketR);\n    } else if (eat(tt.parenL)) {\n      parseCallExpressionArguments();\n    } else {\n      parseMaybePrivateName();\n    }\n  } else if (eat(tt.dot)) {\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseMaybePrivateName();\n  } else if (eat(tt.bracketL)) {\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseExpression();\n    expect(tt.bracketR);\n  } else if (!noCalls && match(tt.parenL)) {\n    if (atPossibleAsync()) {\n      // We see \"async\", but it's possible it's a usage of the name \"async\". Parse as if it's a\n      // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.\n      const snapshot = state.snapshot();\n      const asyncStartTokenIndex = state.tokens.length;\n      next();\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n      const callContextId = getNextContextId();\n\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n\n      if (shouldParseAsyncArrow()) {\n        // We hit an arrow, so backtrack and start again parsing function parameters.\n        state.restoreFromSnapshot(snapshot);\n        stopState.stop = true;\n        state.scopeDepth++;\n\n        parseFunctionParams();\n        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);\n      }\n    } else {\n      next();\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      const callContextId = getNextContextId();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n    }\n  } else if (match(tt.backQuote)) {\n    // Tagged template expression.\n    parseTemplate();\n  } else {\n    stopState.stop = true;\n  }\n}\n\nexport function atPossibleAsync() {\n  // This was made less strict than the original version to avoid passing around nodes, but it\n  // should be safe to have rare false positives here.\n  return (\n    state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async &&\n    !canInsertSemicolon()\n  );\n}\n\nexport function parseCallExpressionArguments() {\n  let first = true;\n  while (!eat(tt.parenR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.parenR)) {\n        break;\n      }\n    }\n\n    parseExprListItem(false);\n  }\n}\n\nfunction shouldParseAsyncArrow() {\n  return match(tt.colon) || match(tt.arrow);\n}\n\nfunction parseAsyncArrowFromCallExpression(startTokenIndex) {\n  if (isTypeScriptEnabled) {\n    tsStartParseAsyncArrowFromCallExpression();\n  } else if (isFlowEnabled) {\n    flowStartParseAsyncArrowFromCallExpression();\n  }\n  expect(tt.arrow);\n  parseArrowExpression(startTokenIndex);\n}\n\n// Parse a no-call expression (like argument of `new` or `::` operators).\n\nfunction parseNoCallExpr() {\n  const startTokenIndex = state.tokens.length;\n  parseExprAtom();\n  parseSubscripts(startTokenIndex, true);\n}\n\n// Parse an atomic expression â€” either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n// Returns true if the parsed expression was an arrow function.\nexport function parseExprAtom() {\n  if (eat(tt.modulo)) {\n    // V8 intrinsic expression. Just parse the identifier, and the function invocation is parsed\n    // naturally.\n    parseIdentifier();\n    return false;\n  }\n\n  if (match(tt.jsxText) || match(tt.jsxEmptyText)) {\n    parseLiteral();\n    return false;\n  } else if (match(tt.lessThan) && isJSXEnabled) {\n    state.type = tt.jsxTagStart;\n    jsxParseElement();\n    next();\n    return false;\n  }\n\n  const canBeArrow = state.potentialArrowAt === state.start;\n  switch (state.type) {\n    case tt.slash:\n    case tt.assign:\n      retokenizeSlashAsRegex();\n    // Fall through.\n\n    case tt._super:\n    case tt._this:\n    case tt.regexp:\n    case tt.num:\n    case tt.bigint:\n    case tt.decimal:\n    case tt.string:\n    case tt._null:\n    case tt._true:\n    case tt._false:\n      next();\n      return false;\n\n    case tt._import:\n      next();\n      if (match(tt.dot)) {\n        // import.meta\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        next();\n        parseIdentifier();\n      }\n      return false;\n\n    case tt.name: {\n      const startTokenIndex = state.tokens.length;\n      const functionStart = state.start;\n      const contextualKeyword = state.contextualKeyword;\n      parseIdentifier();\n      if (contextualKeyword === ContextualKeyword._await) {\n        parseAwait();\n        return false;\n      } else if (\n        contextualKeyword === ContextualKeyword._async &&\n        match(tt._function) &&\n        !canInsertSemicolon()\n      ) {\n        next();\n        parseFunction(functionStart, false);\n        return false;\n      } else if (\n        canBeArrow &&\n        contextualKeyword === ContextualKeyword._async &&\n        !canInsertSemicolon() &&\n        match(tt.name)\n      ) {\n        state.scopeDepth++;\n        parseBindingIdentifier(false);\n        expect(tt.arrow);\n        // let foo = async bar => {};\n        parseArrowExpression(startTokenIndex);\n        return true;\n      } else if (match(tt._do) && !canInsertSemicolon()) {\n        next();\n        parseBlock();\n        return false;\n      }\n\n      if (canBeArrow && !canInsertSemicolon() && match(tt.arrow)) {\n        state.scopeDepth++;\n        markPriorBindingIdentifier(false);\n        expect(tt.arrow);\n        parseArrowExpression(startTokenIndex);\n        return true;\n      }\n\n      state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.Access;\n      return false;\n    }\n\n    case tt._do: {\n      next();\n      parseBlock();\n      return false;\n    }\n\n    case tt.parenL: {\n      const wasArrow = parseParenAndDistinguishExpression(canBeArrow);\n      return wasArrow;\n    }\n\n    case tt.bracketL:\n      next();\n      parseExprList(tt.bracketR, true);\n      return false;\n\n    case tt.braceL:\n      parseObj(false, false);\n      return false;\n\n    case tt._function:\n      parseFunctionExpression();\n      return false;\n\n    case tt.at:\n      parseDecorators();\n    // Fall through.\n\n    case tt._class:\n      parseClass(false);\n      return false;\n\n    case tt._new:\n      parseNew();\n      return false;\n\n    case tt.backQuote:\n      parseTemplate();\n      return false;\n\n    case tt.doubleColon: {\n      next();\n      parseNoCallExpr();\n      return false;\n    }\n\n    case tt.hash: {\n      const code = lookaheadCharCode();\n      if (IS_IDENTIFIER_START[code] || code === charCodes.backslash) {\n        parseMaybePrivateName();\n      } else {\n        next();\n      }\n      // Smart pipeline topic reference.\n      return false;\n    }\n\n    default:\n      unexpected();\n      return false;\n  }\n}\n\nfunction parseMaybePrivateName() {\n  eat(tt.hash);\n  parseIdentifier();\n}\n\nfunction parseFunctionExpression() {\n  const functionStart = state.start;\n  parseIdentifier();\n  if (eat(tt.dot)) {\n    // function.sent\n    parseIdentifier();\n  }\n  parseFunction(functionStart, false);\n}\n\nexport function parseLiteral() {\n  next();\n}\n\nexport function parseParenExpression() {\n  expect(tt.parenL);\n  parseExpression();\n  expect(tt.parenR);\n}\n\n// Returns true if this was an arrow expression.\nfunction parseParenAndDistinguishExpression(canBeArrow) {\n  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and\n  // start over as a parameter list.\n  const snapshot = state.snapshot();\n\n  const startTokenIndex = state.tokens.length;\n  expect(tt.parenL);\n\n  let first = true;\n\n  while (!match(tt.parenR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (match(tt.parenR)) {\n        break;\n      }\n    }\n\n    if (match(tt.ellipsis)) {\n      parseRest(false /* isBlockScope */);\n      parseParenItem();\n      break;\n    } else {\n      parseMaybeAssign(false, true);\n    }\n  }\n\n  expect(tt.parenR);\n\n  if (canBeArrow && shouldParseArrow()) {\n    const wasArrow = parseArrow();\n    if (wasArrow) {\n      // It was an arrow function this whole time, so start over and parse it as params so that we\n      // get proper token annotations.\n      state.restoreFromSnapshot(snapshot);\n      state.scopeDepth++;\n      // Don't specify a context ID because arrow functions don't need a context ID.\n      parseFunctionParams();\n      parseArrow();\n      parseArrowExpression(startTokenIndex);\n      if (state.error) {\n        // Nevermind! This must have been something that looks very much like an\n        // arrow function but where its \"parameter list\" isn't actually a valid\n        // parameter list. Force non-arrow parsing.\n        // See https://github.com/alangpierce/sucrase/issues/666 for an example.\n        state.restoreFromSnapshot(snapshot);\n        parseParenAndDistinguishExpression(false);\n        return false;\n      }\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldParseArrow() {\n  return match(tt.colon) || !canInsertSemicolon();\n}\n\n// Returns whether there was an arrow token.\nexport function parseArrow() {\n  if (isTypeScriptEnabled) {\n    return tsParseArrow();\n  } else if (isFlowEnabled) {\n    return flowParseArrow();\n  } else {\n    return eat(tt.arrow);\n  }\n}\n\nfunction parseParenItem() {\n  if (isTypeScriptEnabled || isFlowEnabled) {\n    typedParseParenItem();\n  }\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call â€” at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\nfunction parseNew() {\n  expect(tt._new);\n  if (eat(tt.dot)) {\n    // new.target\n    parseIdentifier();\n    return;\n  }\n  parseNewCallee();\n  if (isFlowEnabled) {\n    flowStartParseNewArguments();\n  }\n  if (eat(tt.parenL)) {\n    parseExprList(tt.parenR);\n  }\n}\n\nfunction parseNewCallee() {\n  parseNoCallExpr();\n  eat(tt.questionDot);\n}\n\nexport function parseTemplate() {\n  // Finish `, read quasi\n  nextTemplateToken();\n  // Finish quasi, read ${\n  nextTemplateToken();\n  while (!match(tt.backQuote) && !state.error) {\n    expect(tt.dollarBraceL);\n    parseExpression();\n    // Finish }, read quasi\n    nextTemplateToken();\n    // Finish quasi, read either ${ or `\n    nextTemplateToken();\n  }\n  next();\n}\n\n// Parse an object literal or binding pattern.\nexport function parseObj(isPattern, isBlockScope) {\n  // Attach a context ID to the object open and close brace and each object key.\n  const contextId = getNextContextId();\n  let first = true;\n\n  next();\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n\n    let isGenerator = false;\n    if (match(tt.ellipsis)) {\n      const previousIndex = state.tokens.length;\n      parseSpread();\n      if (isPattern) {\n        // Mark role when the only thing being spread over is an identifier.\n        if (state.tokens.length === previousIndex + 2) {\n          markPriorBindingIdentifier(isBlockScope);\n        }\n        if (eat(tt.braceR)) {\n          break;\n        }\n      }\n      continue;\n    }\n\n    if (!isPattern) {\n      isGenerator = eat(tt.star);\n    }\n\n    if (!isPattern && isContextual(ContextualKeyword._async)) {\n      if (isGenerator) unexpected();\n\n      parseIdentifier();\n      if (\n        match(tt.colon) ||\n        match(tt.parenL) ||\n        match(tt.braceR) ||\n        match(tt.eq) ||\n        match(tt.comma)\n      ) {\n        // This is a key called \"async\" rather than an async function.\n      } else {\n        if (match(tt.star)) {\n          next();\n          isGenerator = true;\n        }\n        parsePropertyName(contextId);\n      }\n    } else {\n      parsePropertyName(contextId);\n    }\n\n    parseObjPropValue(isPattern, isBlockScope, contextId);\n  }\n\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n}\n\nfunction isGetterOrSetterMethod(isPattern) {\n  // We go off of the next and don't bother checking if the node key is actually \"get\" or \"set\".\n  // This lets us avoid generating a node, and should only make the validation worse.\n  return (\n    !isPattern &&\n    (match(tt.string) || // get \"string\"() {}\n      match(tt.num) || // get 1() {}\n      match(tt.bracketL) || // get [\"string\"]() {}\n      match(tt.name) || // get foo() {}\n      !!(state.type & TokenType.IS_KEYWORD)) // get debugger() {}\n  );\n}\n\n// Returns true if this was a method.\nfunction parseObjectMethod(isPattern, objectContextId) {\n  // We don't need to worry about modifiers because object methods can't have optional bodies, so\n  // the start will never be used.\n  const functionStart = state.start;\n  if (match(tt.parenL)) {\n    if (isPattern) unexpected();\n    parseMethod(functionStart, /* isConstructor */ false);\n    return true;\n  }\n\n  if (isGetterOrSetterMethod(isPattern)) {\n    parsePropertyName(objectContextId);\n    parseMethod(functionStart, /* isConstructor */ false);\n    return true;\n  }\n  return false;\n}\n\nfunction parseObjectProperty(isPattern, isBlockScope) {\n  if (eat(tt.colon)) {\n    if (isPattern) {\n      parseMaybeDefault(isBlockScope);\n    } else {\n      parseMaybeAssign(false);\n    }\n    return;\n  }\n\n  // Since there's no colon, we assume this is an object shorthand.\n\n  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so\n  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to\n  // transform it on access, so mark it as a normal object shorthand.\n  let identifierRole;\n  if (isPattern) {\n    if (state.scopeDepth === 0) {\n      identifierRole = IdentifierRole.ObjectShorthandTopLevelDeclaration;\n    } else if (isBlockScope) {\n      identifierRole = IdentifierRole.ObjectShorthandBlockScopedDeclaration;\n    } else {\n      identifierRole = IdentifierRole.ObjectShorthandFunctionScopedDeclaration;\n    }\n  } else {\n    identifierRole = IdentifierRole.ObjectShorthand;\n  }\n  state.tokens[state.tokens.length - 1].identifierRole = identifierRole;\n\n  // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow\n  // parsing as if there's a default value.\n  parseMaybeDefault(isBlockScope, true);\n}\n\nfunction parseObjPropValue(\n  isPattern,\n  isBlockScope,\n  objectContextId,\n) {\n  if (isTypeScriptEnabled) {\n    tsStartParseObjPropValue();\n  } else if (isFlowEnabled) {\n    flowStartParseObjPropValue();\n  }\n  const wasMethod = parseObjectMethod(isPattern, objectContextId);\n  if (!wasMethod) {\n    parseObjectProperty(isPattern, isBlockScope);\n  }\n}\n\nexport function parsePropertyName(objectContextId) {\n  if (isFlowEnabled) {\n    flowParseVariance();\n  }\n  if (eat(tt.bracketL)) {\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n    parseMaybeAssign();\n    expect(tt.bracketR);\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n  } else {\n    if (match(tt.num) || match(tt.string) || match(tt.bigint) || match(tt.decimal)) {\n      parseExprAtom();\n    } else {\n      parseMaybePrivateName();\n    }\n\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ObjectKey;\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n  }\n}\n\n// Parse object or class method.\nexport function parseMethod(functionStart, isConstructor) {\n  const funcContextId = getNextContextId();\n\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  const allowModifiers = isConstructor; // For TypeScript parameter properties\n  parseFunctionParams(allowModifiers, funcContextId);\n  parseFunctionBodyAndFinish(functionStart, funcContextId);\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n}\n\n// Parse arrow function expression.\n// If the parameters are provided, they will be converted to an\n// assignable list.\nexport function parseArrowExpression(startTokenIndex) {\n  parseFunctionBody(true);\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n}\n\nexport function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {\n  if (isTypeScriptEnabled) {\n    tsParseFunctionBodyAndFinish(functionStart, funcContextId);\n  } else if (isFlowEnabled) {\n    flowParseFunctionBodyAndFinish(funcContextId);\n  } else {\n    parseFunctionBody(false, funcContextId);\n  }\n}\n\nexport function parseFunctionBody(allowExpression, funcContextId = 0) {\n  const isExpression = allowExpression && !match(tt.braceL);\n\n  if (isExpression) {\n    parseMaybeAssign();\n  } else {\n    parseBlock(true /* isFunctionScope */, funcContextId);\n  }\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\nfunction parseExprList(close, allowEmpty = false) {\n  let first = true;\n  while (!eat(close) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(close)) break;\n    }\n    parseExprListItem(allowEmpty);\n  }\n}\n\nfunction parseExprListItem(allowEmpty) {\n  if (allowEmpty && match(tt.comma)) {\n    // Empty item; nothing more to parse for this item.\n  } else if (match(tt.ellipsis)) {\n    parseSpread();\n    parseParenItem();\n  } else if (match(tt.question)) {\n    // Partial function application proposal.\n    next();\n  } else {\n    parseMaybeAssign(false, true);\n  }\n}\n\n// Parse the next token as an identifier.\nexport function parseIdentifier() {\n  next();\n  state.tokens[state.tokens.length - 1].type = tt.name;\n}\n\n// Parses await expression inside async function.\nfunction parseAwait() {\n  parseMaybeUnary();\n}\n\n// Parses yield expression inside generator.\nfunction parseYield() {\n  next();\n  if (!match(tt.semi) && !canInsertSemicolon()) {\n    eat(tt.star);\n    parseMaybeAssign();\n  }\n}\n\n// https://github.com/tc39/proposal-js-module-blocks\nfunction parseModuleExpression() {\n  expectContextual(ContextualKeyword._module);\n  expect(tt.braceL);\n  // For now, just call parseBlockBody to parse the block. In the future when we\n  // implement full support, we'll want to emit scopes and possibly other\n  // information.\n  parseBlockBody(tt.braceR);\n}\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SACEA,cAAc,EACdC,8BAA8B,EAC9BC,oBAAoB,EACpBC,kBAAkB,EAClBC,mBAAmB,EACnBC,iBAAiB,EACjBC,0CAA0C,EAC1CC,0BAA0B,EAC1BC,0BAA0B,QACrB,iBAAiB;AACxB,SAAQC,eAAe,QAAO,sBAAsB;AACpD,SAAQC,qBAAqB,EAAEC,mBAAmB,QAAO,kBAAkB;AAC3E,SACEC,YAAY,EACZC,4BAA4B,EAC5BC,kBAAkB,EAClBC,gBAAgB,EAChBC,WAAW,EACXC,oBAAoB,EACpBC,wCAAwC,EACxCC,wBAAwB,QACnB,uBAAuB;AAC9B,SACEC,GAAG,EACHC,cAAc,EACdC,iBAAiB,EACjBC,aAAa,EACbC,KAAK,EACLC,IAAI,EACJC,iBAAiB,EACjBC,cAAc,EACdC,eAAe,EACfC,SAAS,EACTC,sBAAsB,QACjB,oBAAoB;AAC3B,SAAQC,iBAAiB,QAAO,uBAAuB;AACvD,SAAQC,KAAK,QAAO,oBAAoB;AACxC,SAAQC,SAAS,EAAEA,SAAS,IAAIC,EAAE,QAAO,oBAAoB;AAC7D,SAAQC,SAAS,QAAO,mBAAmB;AAC3C,SAAQC,mBAAmB,QAAO,oBAAoB;AACtD,SAAQC,gBAAgB,EAAEC,aAAa,EAAEC,YAAY,EAAEC,mBAAmB,EAAEC,KAAK,QAAO,QAAQ;AAChG,SACEC,0BAA0B,EAC1BC,sBAAsB,EACtBC,iBAAiB,EACjBC,SAAS,EACTC,WAAW,QACN,QAAQ;AACf,SACEC,UAAU,EACVC,cAAc,EACdC,UAAU,EACVC,eAAe,EACfC,aAAa,EACbC,mBAAmB,QACd,aAAa;AACpB,SACEC,kBAAkB,EAClBC,aAAa,EACbC,MAAM,EACNC,gBAAgB,EAChBC,qBAAqB,EACrBC,qBAAqB,EACrBC,YAAY,EACZC,UAAU,QACL,QAAQ;AAEf,OAAO,MAAMC,SAAS,CAAC;EAErBC,WAAWA,CAACC,IAAI,EAAE;IAChB,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;AACF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAAA,EAAe;EAAA,IAAdC,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EAC1CG,gBAAgB,CAACJ,IAAI,CAAC;EACtB,IAAIzC,KAAK,CAACU,EAAE,CAACoC,KAAK,CAAC,EAAE;IACnB,OAAOlD,GAAG,CAACc,EAAE,CAACoC,KAAK,CAAC,EAAE;MACpBD,gBAAgB,CAACJ,IAAI,CAAC;IACxB;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,gBAAgBA,CAAA,EAAuC;EAAA,IAAtCJ,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EAAA,IAAEK,cAAc,GAAAL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACnE,IAAI1B,mBAAmB,EAAE;IACvB,OAAO1B,kBAAkB,CAACmD,IAAI,EAAEM,cAAc,CAAC;EACjD,CAAC,MAAM,IAAIjC,aAAa,EAAE;IACxB,OAAOpC,oBAAoB,CAAC+D,IAAI,EAAEM,cAAc,CAAC;EACnD,CAAC,MAAM;IACL,OAAOC,oBAAoB,CAACP,IAAI,EAAEM,cAAc,CAAC;EACnD;AACF;;AAEA;AACA;AACA;AACA,OAAO,SAASC,oBAAoBA,CAACP,IAAI,EAAEM,cAAc,EAAE;EACzD,IAAI/C,KAAK,CAACU,EAAE,CAACuC,MAAM,CAAC,EAAE;IACpBC,UAAU,CAAC,CAAC;IACZ,OAAO,KAAK;EACd;EAEA,IAAIlD,KAAK,CAACU,EAAE,CAACyC,MAAM,CAAC,IAAInD,KAAK,CAACU,EAAE,CAAC0C,IAAI,CAAC,IAAIpD,KAAK,CAACU,EAAE,CAACuC,MAAM,CAAC,EAAE;IAC1DhC,KAAK,CAACoC,gBAAgB,GAAGpC,KAAK,CAACqC,KAAK;EACtC;EAEA,MAAMC,QAAQ,GAAGC,qBAAqB,CAACf,IAAI,CAAC;EAC5C,IAAIM,cAAc,EAAE;IAClBU,cAAc,CAAC,CAAC;EAClB;EACA,IAAIxC,KAAK,CAACyC,IAAI,GAAGjD,SAAS,CAACkD,SAAS,EAAE;IACpC1D,IAAI,CAAC,CAAC;IACN4C,gBAAgB,CAACJ,IAAI,CAAC;IACtB,OAAO,KAAK;EACd;EACA,OAAOc,QAAQ;AACjB;;AAEA;AACA;AACA,SAASC,qBAAqBA,CAACf,IAAI,EAAE;EACnC,MAAMc,QAAQ,GAAGK,YAAY,CAACnB,IAAI,CAAC;EACnC,IAAIc,QAAQ,EAAE;IACZ,OAAO,IAAI;EACb;EACAM,gBAAgB,CAACpB,IAAI,CAAC;EACtB,OAAO,KAAK;AACd;AAEA,SAASoB,gBAAgBA,CAACpB,IAAI,EAAE;EAC9B,IAAIzB,mBAAmB,IAAIF,aAAa,EAAE;IACxC5B,qBAAqB,CAACuD,IAAI,CAAC;EAC7B,CAAC,MAAM;IACLqB,oBAAoB,CAACrB,IAAI,CAAC;EAC5B;AACF;AAEA,OAAO,SAASqB,oBAAoBA,CAACrB,IAAI,EAAE;EACzC,IAAI7C,GAAG,CAACc,EAAE,CAACqD,QAAQ,CAAC,EAAE;IACpBlB,gBAAgB,CAAC,CAAC;IAClBd,MAAM,CAACrB,EAAE,CAACsD,KAAK,CAAC;IAChBnB,gBAAgB,CAACJ,IAAI,CAAC;EACxB;AACF;;AAEA;AACA;AACA,SAASmB,YAAYA,CAACnB,IAAI,EAAE;EAC1B,MAAMwB,eAAe,GAAGhD,KAAK,CAACiD,MAAM,CAACvB,MAAM;EAC3C,MAAMY,QAAQ,GAAGY,eAAe,CAAC,CAAC;EAClC,IAAIZ,QAAQ,EAAE;IACZ,OAAO,IAAI;EACb;EACAa,WAAW,CAACH,eAAe,EAAE,CAAC,CAAC,EAAExB,IAAI,CAAC;EACtC,OAAO,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS2B,WAAWA,CAACH,eAAe,EAAEI,OAAO,EAAE5B,IAAI,EAAE;EACnD,IACEzB,mBAAmB,IACnB,CAACN,EAAE,CAAC4D,GAAG,GAAG7D,SAAS,CAAC8D,eAAe,IAAIF,OAAO,IAC9C,CAACnC,qBAAqB,CAAC,CAAC,KACvBJ,aAAa,CAACvB,iBAAiB,CAACiE,GAAG,CAAC,IAAI1C,aAAa,CAACvB,iBAAiB,CAACkE,UAAU,CAAC,CAAC,EACrF;IACA,MAAMC,SAAS,GAAGtE,eAAe,CAAC,CAAC,CAAC;IACpCZ,WAAW,CAAC,CAAC;IACbW,cAAc,CAACuE,SAAS,CAAC;IACzBrE,SAAS,CAAC,CAAC;IACX+D,WAAW,CAACH,eAAe,EAAEI,OAAO,EAAE5B,IAAI,CAAC;IAC3C;EACF;EAEA,MAAMkC,IAAI,GAAG1D,KAAK,CAACyC,IAAI,GAAGjD,SAAS,CAAC8D,eAAe;EACnD,IAAII,IAAI,GAAG,CAAC,KAAK,CAAClC,IAAI,IAAI,CAACzC,KAAK,CAACU,EAAE,CAAC4D,GAAG,CAAC,CAAC,EAAE;IACzC,IAAIK,IAAI,GAAGN,OAAO,EAAE;MAClB,MAAMO,EAAE,GAAG3D,KAAK,CAACyC,IAAI;MACrBzD,IAAI,CAAC,CAAC;MACN,IAAI2E,EAAE,KAAKlE,EAAE,CAACmE,iBAAiB,EAAE;QAC/B5D,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACmC,iBAAiB,GAAGb,eAAe;MAC3E;MAEA,MAAMc,kBAAkB,GAAG9D,KAAK,CAACiD,MAAM,CAACvB,MAAM;MAC9CwB,eAAe,CAAC,CAAC;MACjB;MACAC,WAAW,CAACW,kBAAkB,EAAEH,EAAE,GAAGnE,SAAS,CAACuE,oBAAoB,GAAGL,IAAI,GAAG,CAAC,GAAGA,IAAI,EAAElC,IAAI,CAAC;MAC5F,IAAImC,EAAE,KAAKlE,EAAE,CAACmE,iBAAiB,EAAE;QAC/B5D,KAAK,CAACiD,MAAM,CAACD,eAAe,CAAC,CAACgB,wBAAwB,EAAE;QACxDhE,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACuC,sBAAsB,EAAE;MAChE;MACA;MACAd,WAAW,CAACH,eAAe,EAAEI,OAAO,EAAE5B,IAAI,CAAC;IAC7C;EACF;AACF;;AAEA;AACA;AACA,OAAO,SAAS0B,eAAeA,CAAA,EAAG;EAChC,IAAInD,mBAAmB,IAAI,CAACD,YAAY,IAAInB,GAAG,CAACc,EAAE,CAACyE,QAAQ,CAAC,EAAE;IAC5D1F,oBAAoB,CAAC,CAAC;IACtB,OAAO,KAAK;EACd;EACA,IACE0C,YAAY,CAAC5B,iBAAiB,CAAC6E,OAAO,CAAC,IACvCtF,iBAAiB,CAAC,CAAC,KAAKa,SAAS,CAAC0E,cAAc,IAChD,CAACpD,qBAAqB,CAAC,CAAC,EACxB;IACAqD,qBAAqB,CAAC,CAAC;IACvB,OAAO,KAAK;EACd;EACA,IAAIrE,KAAK,CAACyC,IAAI,GAAGjD,SAAS,CAAC8E,SAAS,EAAE;IACpCtF,IAAI,CAAC,CAAC;IACNkE,eAAe,CAAC,CAAC;IACjB,OAAO,KAAK;EACd;EAEA,MAAMZ,QAAQ,GAAGiC,mBAAmB,CAAC,CAAC;EACtC,IAAIjC,QAAQ,EAAE;IACZ,OAAO,IAAI;EACb;EACA,OAAOtC,KAAK,CAACyC,IAAI,GAAGjD,SAAS,CAACgF,UAAU,IAAI,CAAC5D,kBAAkB,CAAC,CAAC,EAAE;IACjE;IACA;IACA,IAAIZ,KAAK,CAACyC,IAAI,KAAKhD,EAAE,CAACgF,SAAS,EAAE;MAC/BzE,KAAK,CAACyC,IAAI,GAAGhD,EAAE,CAACiF,UAAU;IAC5B;IACA1F,IAAI,CAAC,CAAC;EACR;EACA,OAAO,KAAK;AACd;;AAEA;AACA;AACA,OAAO,SAASuF,mBAAmBA,CAAA,EAAG;EACpC,MAAMvB,eAAe,GAAGhD,KAAK,CAACiD,MAAM,CAACvB,MAAM;EAC3C,MAAMY,QAAQ,GAAGqC,aAAa,CAAC,CAAC;EAChC,IAAIrC,QAAQ,EAAE;IACZ,OAAO,IAAI;EACb;EACAsC,eAAe,CAAC5B,eAAe,CAAC;EAChC;EACA;EACA,IAAIhD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAGsB,eAAe,IAAIhD,KAAK,CAACiD,MAAM,CAACD,eAAe,CAAC,CAAC6B,oBAAoB,EAAE;IAC/F7E,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACoD,kBAAkB,GAAG,IAAI;EACjE;EACA,OAAO,KAAK;AACd;AAEA,SAASF,eAAeA,CAAC5B,eAAe,EAAmB;EAAA,IAAjB+B,OAAO,GAAAtD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACvD,IAAI5B,aAAa,EAAE;IACjBlC,mBAAmB,CAACqF,eAAe,EAAE+B,OAAO,CAAC;EAC/C,CAAC,MAAM;IACLC,mBAAmB,CAAChC,eAAe,EAAE+B,OAAO,CAAC;EAC/C;AACF;AAEA,OAAO,SAASC,mBAAmBA,CAAChC,eAAe,EAAmB;EAAA,IAAjB+B,OAAO,GAAAtD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EAClE,MAAMwD,SAAS,GAAG,IAAI7D,SAAS,CAAC,KAAK,CAAC;EACtC,GAAG;IACD8D,cAAc,CAAClC,eAAe,EAAE+B,OAAO,EAAEE,SAAS,CAAC;EACrD,CAAC,QAAQ,CAACA,SAAS,CAAC3D,IAAI,IAAI,CAACtB,KAAK,CAACmF,KAAK;AAC1C;AAEA,SAASD,cAAcA,CAAClC,eAAe,EAAE+B,OAAO,EAAEE,SAAS,EAAE;EAC3D,IAAIlF,mBAAmB,EAAE;IACvBzB,gBAAgB,CAAC0E,eAAe,EAAE+B,OAAO,EAAEE,SAAS,CAAC;EACvD,CAAC,MAAM,IAAIpF,aAAa,EAAE;IACxBnC,kBAAkB,CAACsF,eAAe,EAAE+B,OAAO,EAAEE,SAAS,CAAC;EACzD,CAAC,MAAM;IACLG,kBAAkB,CAACpC,eAAe,EAAE+B,OAAO,EAAEE,SAAS,CAAC;EACzD;AACF;;AAEA;AACA,OAAO,SAASG,kBAAkBA,CAChCpC,eAAe,EACf+B,OAAO,EACPE,SAAS,EACT;EACA,IAAI,CAACF,OAAO,IAAIpG,GAAG,CAACc,EAAE,CAAC4F,WAAW,CAAC,EAAE;IACnCC,eAAe,CAAC,CAAC;IACjBL,SAAS,CAAC3D,IAAI,GAAG,IAAI;IACrB;IACA;IACAsD,eAAe,CAAC5B,eAAe,EAAE+B,OAAO,CAAC;EAC3C,CAAC,MAAM,IAAIhG,KAAK,CAACU,EAAE,CAAC8F,WAAW,CAAC,EAAE;IAChCvF,KAAK,CAACiD,MAAM,CAACD,eAAe,CAAC,CAAC6B,oBAAoB,GAAG,IAAI;IACzD,IAAIE,OAAO,IAAIjG,aAAa,CAAC,CAAC,KAAKW,EAAE,CAACyC,MAAM,EAAE;MAC5C+C,SAAS,CAAC3D,IAAI,GAAG,IAAI;MACrB;IACF;IACAtC,IAAI,CAAC,CAAC;IACNgB,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAAC8D,mBAAmB,GAAGxC,eAAe;IAE3E,IAAIrE,GAAG,CAACc,EAAE,CAACgG,QAAQ,CAAC,EAAE;MACpBlE,eAAe,CAAC,CAAC;MACjBT,MAAM,CAACrB,EAAE,CAACiG,QAAQ,CAAC;IACrB,CAAC,MAAM,IAAI/G,GAAG,CAACc,EAAE,CAACyC,MAAM,CAAC,EAAE;MACzByD,4BAA4B,CAAC,CAAC;IAChC,CAAC,MAAM;MACLC,qBAAqB,CAAC,CAAC;IACzB;EACF,CAAC,MAAM,IAAIjH,GAAG,CAACc,EAAE,CAACoG,GAAG,CAAC,EAAE;IACtB7F,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAAC8D,mBAAmB,GAAGxC,eAAe;IAC3E4C,qBAAqB,CAAC,CAAC;EACzB,CAAC,MAAM,IAAIjH,GAAG,CAACc,EAAE,CAACgG,QAAQ,CAAC,EAAE;IAC3BzF,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAAC8D,mBAAmB,GAAGxC,eAAe;IAC3EzB,eAAe,CAAC,CAAC;IACjBT,MAAM,CAACrB,EAAE,CAACiG,QAAQ,CAAC;EACrB,CAAC,MAAM,IAAI,CAACX,OAAO,IAAIhG,KAAK,CAACU,EAAE,CAACyC,MAAM,CAAC,EAAE;IACvC,IAAI4D,eAAe,CAAC,CAAC,EAAE;MACrB;MACA;MACA,MAAMC,QAAQ,GAAG/F,KAAK,CAAC+F,QAAQ,CAAC,CAAC;MACjC,MAAMC,oBAAoB,GAAGhG,KAAK,CAACiD,MAAM,CAACvB,MAAM;MAChD1C,IAAI,CAAC,CAAC;MACNgB,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAAC8D,mBAAmB,GAAGxC,eAAe;MAE3E,MAAMiD,aAAa,GAAGrG,gBAAgB,CAAC,CAAC;MAExCI,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACwE,SAAS,GAAGD,aAAa;MAC/DN,4BAA4B,CAAC,CAAC;MAC9B3F,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACwE,SAAS,GAAGD,aAAa;MAE/D,IAAIE,qBAAqB,CAAC,CAAC,EAAE;QAC3B;QACAnG,KAAK,CAACoG,mBAAmB,CAACL,QAAQ,CAAC;QACnCd,SAAS,CAAC3D,IAAI,GAAG,IAAI;QACrBtB,KAAK,CAACqG,UAAU,EAAE;QAElB1F,mBAAmB,CAAC,CAAC;QACrB2F,iCAAiC,CAACN,oBAAoB,CAAC;MACzD;IACF,CAAC,MAAM;MACLhH,IAAI,CAAC,CAAC;MACNgB,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAAC8D,mBAAmB,GAAGxC,eAAe;MAC3E,MAAMiD,aAAa,GAAGrG,gBAAgB,CAAC,CAAC;MACxCI,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACwE,SAAS,GAAGD,aAAa;MAC/DN,4BAA4B,CAAC,CAAC;MAC9B3F,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACwE,SAAS,GAAGD,aAAa;IACjE;EACF,CAAC,MAAM,IAAIlH,KAAK,CAACU,EAAE,CAAC8G,SAAS,CAAC,EAAE;IAC9B;IACAC,aAAa,CAAC,CAAC;EACjB,CAAC,MAAM;IACLvB,SAAS,CAAC3D,IAAI,GAAG,IAAI;EACvB;AACF;AAEA,OAAO,SAASwE,eAAeA,CAAA,EAAG;EAChC;EACA;EACA,OACE9F,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAAC+E,iBAAiB,KAAKnH,iBAAiB,CAACoH,MAAM,IACpF,CAAC9F,kBAAkB,CAAC,CAAC;AAEzB;AAEA,OAAO,SAAS+E,4BAA4BA,CAAA,EAAG;EAC7C,IAAIgB,KAAK,GAAG,IAAI;EAChB,OAAO,CAAChI,GAAG,CAACc,EAAE,CAACmH,MAAM,CAAC,IAAI,CAAC5G,KAAK,CAACmF,KAAK,EAAE;IACtC,IAAIwB,KAAK,EAAE;MACTA,KAAK,GAAG,KAAK;IACf,CAAC,MAAM;MACL7F,MAAM,CAACrB,EAAE,CAACoC,KAAK,CAAC;MAChB,IAAIlD,GAAG,CAACc,EAAE,CAACmH,MAAM,CAAC,EAAE;QAClB;MACF;IACF;IAEAC,iBAAiB,CAAC,KAAK,CAAC;EAC1B;AACF;AAEA,SAASV,qBAAqBA,CAAA,EAAG;EAC/B,OAAOpH,KAAK,CAACU,EAAE,CAACsD,KAAK,CAAC,IAAIhE,KAAK,CAACU,EAAE,CAACqH,KAAK,CAAC;AAC3C;AAEA,SAASR,iCAAiCA,CAACtD,eAAe,EAAE;EAC1D,IAAIjD,mBAAmB,EAAE;IACvBtB,wCAAwC,CAAC,CAAC;EAC5C,CAAC,MAAM,IAAIoB,aAAa,EAAE;IACxBhC,0CAA0C,CAAC,CAAC;EAC9C;EACAiD,MAAM,CAACrB,EAAE,CAACqH,KAAK,CAAC;EAChBC,oBAAoB,CAAC/D,eAAe,CAAC;AACvC;;AAEA;;AAEA,SAASsC,eAAeA,CAAA,EAAG;EACzB,MAAMtC,eAAe,GAAGhD,KAAK,CAACiD,MAAM,CAACvB,MAAM;EAC3CiD,aAAa,CAAC,CAAC;EACfC,eAAe,CAAC5B,eAAe,EAAE,IAAI,CAAC;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS2B,aAAaA,CAAA,EAAG;EAC9B,IAAIhG,GAAG,CAACc,EAAE,CAACuH,MAAM,CAAC,EAAE;IAClB;IACA;IACAC,eAAe,CAAC,CAAC;IACjB,OAAO,KAAK;EACd;EAEA,IAAIlI,KAAK,CAACU,EAAE,CAACyH,OAAO,CAAC,IAAInI,KAAK,CAACU,EAAE,CAAC0H,YAAY,CAAC,EAAE;IAC/CC,YAAY,CAAC,CAAC;IACd,OAAO,KAAK;EACd,CAAC,MAAM,IAAIrI,KAAK,CAACU,EAAE,CAACyE,QAAQ,CAAC,IAAIpE,YAAY,EAAE;IAC7CE,KAAK,CAACyC,IAAI,GAAGhD,EAAE,CAAC4H,WAAW;IAC3BrJ,eAAe,CAAC,CAAC;IACjBgB,IAAI,CAAC,CAAC;IACN,OAAO,KAAK;EACd;EAEA,MAAMsI,UAAU,GAAGtH,KAAK,CAACoC,gBAAgB,KAAKpC,KAAK,CAACqC,KAAK;EACzD,QAAQrC,KAAK,CAACyC,IAAI;IAChB,KAAKhD,EAAE,CAAC8H,KAAK;IACb,KAAK9H,EAAE,CAAC+H,MAAM;MACZnI,sBAAsB,CAAC,CAAC;IAC1B;;IAEA,KAAKI,EAAE,CAACgI,MAAM;IACd,KAAKhI,EAAE,CAACiI,KAAK;IACb,KAAKjI,EAAE,CAACkI,MAAM;IACd,KAAKlI,EAAE,CAACmI,GAAG;IACX,KAAKnI,EAAE,CAACoI,MAAM;IACd,KAAKpI,EAAE,CAACqI,OAAO;IACf,KAAKrI,EAAE,CAACsI,MAAM;IACd,KAAKtI,EAAE,CAACuI,KAAK;IACb,KAAKvI,EAAE,CAACwI,KAAK;IACb,KAAKxI,EAAE,CAACyI,MAAM;MACZlJ,IAAI,CAAC,CAAC;MACN,OAAO,KAAK;IAEd,KAAKS,EAAE,CAAC0I,OAAO;MACbnJ,IAAI,CAAC,CAAC;MACN,IAAID,KAAK,CAACU,EAAE,CAACoG,GAAG,CAAC,EAAE;QACjB;QACA7F,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACe,IAAI,GAAGhD,EAAE,CAAC0C,IAAI;QACpDnD,IAAI,CAAC,CAAC;QACNiI,eAAe,CAAC,CAAC;MACnB;MACA,OAAO,KAAK;IAEd,KAAKxH,EAAE,CAAC0C,IAAI;MAAE;QACZ,MAAMa,eAAe,GAAGhD,KAAK,CAACiD,MAAM,CAACvB,MAAM;QAC3C,MAAM0G,aAAa,GAAGpI,KAAK,CAACqC,KAAK;QACjC,MAAMoE,iBAAiB,GAAGzG,KAAK,CAACyG,iBAAiB;QACjDQ,eAAe,CAAC,CAAC;QACjB,IAAIR,iBAAiB,KAAKnH,iBAAiB,CAAC+I,MAAM,EAAE;UAClDC,UAAU,CAAC,CAAC;UACZ,OAAO,KAAK;QACd,CAAC,MAAM,IACL7B,iBAAiB,KAAKnH,iBAAiB,CAACoH,MAAM,IAC9C3H,KAAK,CAACU,EAAE,CAAC8I,SAAS,CAAC,IACnB,CAAC3H,kBAAkB,CAAC,CAAC,EACrB;UACA5B,IAAI,CAAC,CAAC;UACN0B,aAAa,CAAC0H,aAAa,EAAE,KAAK,CAAC;UACnC,OAAO,KAAK;QACd,CAAC,MAAM,IACLd,UAAU,IACVb,iBAAiB,KAAKnH,iBAAiB,CAACoH,MAAM,IAC9C,CAAC9F,kBAAkB,CAAC,CAAC,IACrB7B,KAAK,CAACU,EAAE,CAAC0C,IAAI,CAAC,EACd;UACAnC,KAAK,CAACqG,UAAU,EAAE;UAClBnG,sBAAsB,CAAC,KAAK,CAAC;UAC7BY,MAAM,CAACrB,EAAE,CAACqH,KAAK,CAAC;UAChB;UACAC,oBAAoB,CAAC/D,eAAe,CAAC;UACrC,OAAO,IAAI;QACb,CAAC,MAAM,IAAIjE,KAAK,CAACU,EAAE,CAAC+I,GAAG,CAAC,IAAI,CAAC5H,kBAAkB,CAAC,CAAC,EAAE;UACjD5B,IAAI,CAAC,CAAC;UACNsB,UAAU,CAAC,CAAC;UACZ,OAAO,KAAK;QACd;QAEA,IAAIgH,UAAU,IAAI,CAAC1G,kBAAkB,CAAC,CAAC,IAAI7B,KAAK,CAACU,EAAE,CAACqH,KAAK,CAAC,EAAE;UAC1D9G,KAAK,CAACqG,UAAU,EAAE;UAClBpG,0BAA0B,CAAC,KAAK,CAAC;UACjCa,MAAM,CAACrB,EAAE,CAACqH,KAAK,CAAC;UAChBC,oBAAoB,CAAC/D,eAAe,CAAC;UACrC,OAAO,IAAI;QACb;QAEAhD,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAAC+G,cAAc,GAAG7J,cAAc,CAAC8J,MAAM;QAC5E,OAAO,KAAK;MACd;IAEA,KAAKjJ,EAAE,CAAC+I,GAAG;MAAE;QACXxJ,IAAI,CAAC,CAAC;QACNsB,UAAU,CAAC,CAAC;QACZ,OAAO,KAAK;MACd;IAEA,KAAKb,EAAE,CAACyC,MAAM;MAAE;QACd,MAAMI,QAAQ,GAAGqG,kCAAkC,CAACrB,UAAU,CAAC;QAC/D,OAAOhF,QAAQ;MACjB;IAEA,KAAK7C,EAAE,CAACgG,QAAQ;MACdzG,IAAI,CAAC,CAAC;MACN4J,aAAa,CAACnJ,EAAE,CAACiG,QAAQ,EAAE,IAAI,CAAC;MAChC,OAAO,KAAK;IAEd,KAAKjG,EAAE,CAACoJ,MAAM;MACZC,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC;MACtB,OAAO,KAAK;IAEd,KAAKrJ,EAAE,CAAC8I,SAAS;MACfQ,uBAAuB,CAAC,CAAC;MACzB,OAAO,KAAK;IAEd,KAAKtJ,EAAE,CAACuJ,EAAE;MACRvI,eAAe,CAAC,CAAC;IACnB;;IAEA,KAAKhB,EAAE,CAACwJ,MAAM;MACZzI,UAAU,CAAC,KAAK,CAAC;MACjB,OAAO,KAAK;IAEd,KAAKf,EAAE,CAACyJ,IAAI;MACVC,QAAQ,CAAC,CAAC;MACV,OAAO,KAAK;IAEd,KAAK1J,EAAE,CAAC8G,SAAS;MACfC,aAAa,CAAC,CAAC;MACf,OAAO,KAAK;IAEd,KAAK/G,EAAE,CAAC4F,WAAW;MAAE;QACnBrG,IAAI,CAAC,CAAC;QACNsG,eAAe,CAAC,CAAC;QACjB,OAAO,KAAK;MACd;IAEA,KAAK7F,EAAE,CAAC2J,IAAI;MAAE;QACZ,MAAMC,IAAI,GAAGxK,iBAAiB,CAAC,CAAC;QAChC,IAAIc,mBAAmB,CAAC0J,IAAI,CAAC,IAAIA,IAAI,KAAK3J,SAAS,CAAC4J,SAAS,EAAE;UAC7D1D,qBAAqB,CAAC,CAAC;QACzB,CAAC,MAAM;UACL5G,IAAI,CAAC,CAAC;QACR;QACA;QACA,OAAO,KAAK;MACd;IAEA;MACEmC,UAAU,CAAC,CAAC;MACZ,OAAO,KAAK;EAChB;AACF;AAEA,SAASyE,qBAAqBA,CAAA,EAAG;EAC/BjH,GAAG,CAACc,EAAE,CAAC2J,IAAI,CAAC;EACZnC,eAAe,CAAC,CAAC;AACnB;AAEA,SAAS8B,uBAAuBA,CAAA,EAAG;EACjC,MAAMX,aAAa,GAAGpI,KAAK,CAACqC,KAAK;EACjC4E,eAAe,CAAC,CAAC;EACjB,IAAItI,GAAG,CAACc,EAAE,CAACoG,GAAG,CAAC,EAAE;IACf;IACAoB,eAAe,CAAC,CAAC;EACnB;EACAvG,aAAa,CAAC0H,aAAa,EAAE,KAAK,CAAC;AACrC;AAEA,OAAO,SAAShB,YAAYA,CAAA,EAAG;EAC7BpI,IAAI,CAAC,CAAC;AACR;AAEA,OAAO,SAASuK,oBAAoBA,CAAA,EAAG;EACrCzI,MAAM,CAACrB,EAAE,CAACyC,MAAM,CAAC;EACjBX,eAAe,CAAC,CAAC;EACjBT,MAAM,CAACrB,EAAE,CAACmH,MAAM,CAAC;AACnB;;AAEA;AACA,SAAS+B,kCAAkCA,CAACrB,UAAU,EAAE;EACtD;EACA;EACA,MAAMvB,QAAQ,GAAG/F,KAAK,CAAC+F,QAAQ,CAAC,CAAC;EAEjC,MAAM/C,eAAe,GAAGhD,KAAK,CAACiD,MAAM,CAACvB,MAAM;EAC3CZ,MAAM,CAACrB,EAAE,CAACyC,MAAM,CAAC;EAEjB,IAAIyE,KAAK,GAAG,IAAI;EAEhB,OAAO,CAAC5H,KAAK,CAACU,EAAE,CAACmH,MAAM,CAAC,IAAI,CAAC5G,KAAK,CAACmF,KAAK,EAAE;IACxC,IAAIwB,KAAK,EAAE;MACTA,KAAK,GAAG,KAAK;IACf,CAAC,MAAM;MACL7F,MAAM,CAACrB,EAAE,CAACoC,KAAK,CAAC;MAChB,IAAI9C,KAAK,CAACU,EAAE,CAACmH,MAAM,CAAC,EAAE;QACpB;MACF;IACF;IAEA,IAAI7H,KAAK,CAACU,EAAE,CAAC+J,QAAQ,CAAC,EAAE;MACtBpJ,SAAS,CAAC,KAAK,CAAC,kBAAkB,CAAC;MACnCoC,cAAc,CAAC,CAAC;MAChB;IACF,CAAC,MAAM;MACLZ,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC;IAC/B;EACF;EAEAd,MAAM,CAACrB,EAAE,CAACmH,MAAM,CAAC;EAEjB,IAAIU,UAAU,IAAImC,gBAAgB,CAAC,CAAC,EAAE;IACpC,MAAMnH,QAAQ,GAAGoH,UAAU,CAAC,CAAC;IAC7B,IAAIpH,QAAQ,EAAE;MACZ;MACA;MACAtC,KAAK,CAACoG,mBAAmB,CAACL,QAAQ,CAAC;MACnC/F,KAAK,CAACqG,UAAU,EAAE;MAClB;MACA1F,mBAAmB,CAAC,CAAC;MACrB+I,UAAU,CAAC,CAAC;MACZ3C,oBAAoB,CAAC/D,eAAe,CAAC;MACrC,IAAIhD,KAAK,CAACmF,KAAK,EAAE;QACf;QACA;QACA;QACA;QACAnF,KAAK,CAACoG,mBAAmB,CAACL,QAAQ,CAAC;QACnC4C,kCAAkC,CAAC,KAAK,CAAC;QACzC,OAAO,KAAK;MACd;MACA,OAAO,IAAI;IACb;EACF;EAEA,OAAO,KAAK;AACd;AAEA,SAASc,gBAAgBA,CAAA,EAAG;EAC1B,OAAO1K,KAAK,CAACU,EAAE,CAACsD,KAAK,CAAC,IAAI,CAACnC,kBAAkB,CAAC,CAAC;AACjD;;AAEA;AACA,OAAO,SAAS8I,UAAUA,CAAA,EAAG;EAC3B,IAAI3J,mBAAmB,EAAE;IACvB,OAAO5B,YAAY,CAAC,CAAC;EACvB,CAAC,MAAM,IAAI0B,aAAa,EAAE;IACxB,OAAOtC,cAAc,CAAC,CAAC;EACzB,CAAC,MAAM;IACL,OAAOoB,GAAG,CAACc,EAAE,CAACqH,KAAK,CAAC;EACtB;AACF;AAEA,SAAStE,cAAcA,CAAA,EAAG;EACxB,IAAIzC,mBAAmB,IAAIF,aAAa,EAAE;IACxC3B,mBAAmB,CAAC,CAAC;EACvB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASiL,QAAQA,CAAA,EAAG;EAClBrI,MAAM,CAACrB,EAAE,CAACyJ,IAAI,CAAC;EACf,IAAIvK,GAAG,CAACc,EAAE,CAACoG,GAAG,CAAC,EAAE;IACf;IACAoB,eAAe,CAAC,CAAC;IACjB;EACF;EACA0C,cAAc,CAAC,CAAC;EAChB,IAAI9J,aAAa,EAAE;IACjB/B,0BAA0B,CAAC,CAAC;EAC9B;EACA,IAAIa,GAAG,CAACc,EAAE,CAACyC,MAAM,CAAC,EAAE;IAClB0G,aAAa,CAACnJ,EAAE,CAACmH,MAAM,CAAC;EAC1B;AACF;AAEA,SAAS+C,cAAcA,CAAA,EAAG;EACxBrE,eAAe,CAAC,CAAC;EACjB3G,GAAG,CAACc,EAAE,CAAC8F,WAAW,CAAC;AACrB;AAEA,OAAO,SAASiB,aAAaA,CAAA,EAAG;EAC9B;EACAvH,iBAAiB,CAAC,CAAC;EACnB;EACAA,iBAAiB,CAAC,CAAC;EACnB,OAAO,CAACF,KAAK,CAACU,EAAE,CAAC8G,SAAS,CAAC,IAAI,CAACvG,KAAK,CAACmF,KAAK,EAAE;IAC3CrE,MAAM,CAACrB,EAAE,CAACmK,YAAY,CAAC;IACvBrI,eAAe,CAAC,CAAC;IACjB;IACAtC,iBAAiB,CAAC,CAAC;IACnB;IACAA,iBAAiB,CAAC,CAAC;EACrB;EACAD,IAAI,CAAC,CAAC;AACR;;AAEA;AACA,OAAO,SAAS8J,QAAQA,CAACe,SAAS,EAAEC,YAAY,EAAE;EAChD;EACA,MAAM5D,SAAS,GAAGtG,gBAAgB,CAAC,CAAC;EACpC,IAAI+G,KAAK,GAAG,IAAI;EAEhB3H,IAAI,CAAC,CAAC;EACNgB,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACwE,SAAS,GAAGA,SAAS;EAE3D,OAAO,CAACvH,GAAG,CAACc,EAAE,CAACsK,MAAM,CAAC,IAAI,CAAC/J,KAAK,CAACmF,KAAK,EAAE;IACtC,IAAIwB,KAAK,EAAE;MACTA,KAAK,GAAG,KAAK;IACf,CAAC,MAAM;MACL7F,MAAM,CAACrB,EAAE,CAACoC,KAAK,CAAC;MAChB,IAAIlD,GAAG,CAACc,EAAE,CAACsK,MAAM,CAAC,EAAE;QAClB;MACF;IACF;IAEA,IAAIC,WAAW,GAAG,KAAK;IACvB,IAAIjL,KAAK,CAACU,EAAE,CAAC+J,QAAQ,CAAC,EAAE;MACtB,MAAMS,aAAa,GAAGjK,KAAK,CAACiD,MAAM,CAACvB,MAAM;MACzCrB,WAAW,CAAC,CAAC;MACb,IAAIwJ,SAAS,EAAE;QACb;QACA,IAAI7J,KAAK,CAACiD,MAAM,CAACvB,MAAM,KAAKuI,aAAa,GAAG,CAAC,EAAE;UAC7ChK,0BAA0B,CAAC6J,YAAY,CAAC;QAC1C;QACA,IAAInL,GAAG,CAACc,EAAE,CAACsK,MAAM,CAAC,EAAE;UAClB;QACF;MACF;MACA;IACF;IAEA,IAAI,CAACF,SAAS,EAAE;MACdG,WAAW,GAAGrL,GAAG,CAACc,EAAE,CAACyK,IAAI,CAAC;IAC5B;IAEA,IAAI,CAACL,SAAS,IAAI3I,YAAY,CAAC5B,iBAAiB,CAACoH,MAAM,CAAC,EAAE;MACxD,IAAIsD,WAAW,EAAE7I,UAAU,CAAC,CAAC;MAE7B8F,eAAe,CAAC,CAAC;MACjB,IACElI,KAAK,CAACU,EAAE,CAACsD,KAAK,CAAC,IACfhE,KAAK,CAACU,EAAE,CAACyC,MAAM,CAAC,IAChBnD,KAAK,CAACU,EAAE,CAACsK,MAAM,CAAC,IAChBhL,KAAK,CAACU,EAAE,CAAC0K,EAAE,CAAC,IACZpL,KAAK,CAACU,EAAE,CAACoC,KAAK,CAAC,EACf;QACA;MAAA,CACD,MAAM;QACL,IAAI9C,KAAK,CAACU,EAAE,CAACyK,IAAI,CAAC,EAAE;UAClBlL,IAAI,CAAC,CAAC;UACNgL,WAAW,GAAG,IAAI;QACpB;QACAI,iBAAiB,CAAClE,SAAS,CAAC;MAC9B;IACF,CAAC,MAAM;MACLkE,iBAAiB,CAAClE,SAAS,CAAC;IAC9B;IAEAmE,iBAAiB,CAACR,SAAS,EAAEC,YAAY,EAAE5D,SAAS,CAAC;EACvD;EAEAlG,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACwE,SAAS,GAAGA,SAAS;AAC7D;AAEA,SAASoE,sBAAsBA,CAACT,SAAS,EAAE;EACzC;EACA;EACA,OACE,CAACA,SAAS,KACT9K,KAAK,CAACU,EAAE,CAACsI,MAAM,CAAC;EAAI;EACnBhJ,KAAK,CAACU,EAAE,CAACmI,GAAG,CAAC;EAAI;EACjB7I,KAAK,CAACU,EAAE,CAACgG,QAAQ,CAAC;EAAI;EACtB1G,KAAK,CAACU,EAAE,CAAC0C,IAAI,CAAC;EAAI;EAClB,CAAC,EAAEnC,KAAK,CAACyC,IAAI,GAAGjD,SAAS,CAAC+K,UAAU,CAAC,CAAC,CAAC;EAAA;AAE7C;;AAEA;AACA,SAASC,iBAAiBA,CAACX,SAAS,EAAEY,eAAe,EAAE;EACrD;EACA;EACA,MAAMrC,aAAa,GAAGpI,KAAK,CAACqC,KAAK;EACjC,IAAItD,KAAK,CAACU,EAAE,CAACyC,MAAM,CAAC,EAAE;IACpB,IAAI2H,SAAS,EAAE1I,UAAU,CAAC,CAAC;IAC3BuJ,WAAW,CAACtC,aAAa,EAAE,mBAAoB,KAAK,CAAC;IACrD,OAAO,IAAI;EACb;EAEA,IAAIkC,sBAAsB,CAACT,SAAS,CAAC,EAAE;IACrCO,iBAAiB,CAACK,eAAe,CAAC;IAClCC,WAAW,CAACtC,aAAa,EAAE,mBAAoB,KAAK,CAAC;IACrD,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd;AAEA,SAASuC,mBAAmBA,CAACd,SAAS,EAAEC,YAAY,EAAE;EACpD,IAAInL,GAAG,CAACc,EAAE,CAACsD,KAAK,CAAC,EAAE;IACjB,IAAI8G,SAAS,EAAE;MACb1J,iBAAiB,CAAC2J,YAAY,CAAC;IACjC,CAAC,MAAM;MACLlI,gBAAgB,CAAC,KAAK,CAAC;IACzB;IACA;EACF;;EAEA;;EAEA;EACA;EACA;EACA,IAAI6G,cAAc;EAClB,IAAIoB,SAAS,EAAE;IACb,IAAI7J,KAAK,CAACqG,UAAU,KAAK,CAAC,EAAE;MAC1BoC,cAAc,GAAG7J,cAAc,CAACgM,kCAAkC;IACpE,CAAC,MAAM,IAAId,YAAY,EAAE;MACvBrB,cAAc,GAAG7J,cAAc,CAACiM,qCAAqC;IACvE,CAAC,MAAM;MACLpC,cAAc,GAAG7J,cAAc,CAACkM,wCAAwC;IAC1E;EACF,CAAC,MAAM;IACLrC,cAAc,GAAG7J,cAAc,CAACmM,eAAe;EACjD;EACA/K,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAAC+G,cAAc,GAAGA,cAAc;;EAErE;EACA;EACAtI,iBAAiB,CAAC2J,YAAY,EAAE,IAAI,CAAC;AACvC;AAEA,SAASO,iBAAiBA,CACxBR,SAAS,EACTC,YAAY,EACZW,eAAe,EACf;EACA,IAAI1K,mBAAmB,EAAE;IACvBrB,wBAAwB,CAAC,CAAC;EAC5B,CAAC,MAAM,IAAImB,aAAa,EAAE;IACxB9B,0BAA0B,CAAC,CAAC;EAC9B;EACA,MAAMiN,SAAS,GAAGR,iBAAiB,CAACX,SAAS,EAAEY,eAAe,CAAC;EAC/D,IAAI,CAACO,SAAS,EAAE;IACdL,mBAAmB,CAACd,SAAS,EAAEC,YAAY,CAAC;EAC9C;AACF;AAEA,OAAO,SAASM,iBAAiBA,CAACK,eAAe,EAAE;EACjD,IAAI5K,aAAa,EAAE;IACjBjC,iBAAiB,CAAC,CAAC;EACrB;EACA,IAAIe,GAAG,CAACc,EAAE,CAACgG,QAAQ,CAAC,EAAE;IACpBzF,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACwE,SAAS,GAAGuE,eAAe;IACjE7I,gBAAgB,CAAC,CAAC;IAClBd,MAAM,CAACrB,EAAE,CAACiG,QAAQ,CAAC;IACnB1F,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACwE,SAAS,GAAGuE,eAAe;EACnE,CAAC,MAAM;IACL,IAAI1L,KAAK,CAACU,EAAE,CAACmI,GAAG,CAAC,IAAI7I,KAAK,CAACU,EAAE,CAACsI,MAAM,CAAC,IAAIhJ,KAAK,CAACU,EAAE,CAACoI,MAAM,CAAC,IAAI9I,KAAK,CAACU,EAAE,CAACqI,OAAO,CAAC,EAAE;MAC9EnD,aAAa,CAAC,CAAC;IACjB,CAAC,MAAM;MACLiB,qBAAqB,CAAC,CAAC;IACzB;IAEA5F,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAAC+G,cAAc,GAAG7J,cAAc,CAACqM,SAAS;IAC/EjL,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACwE,SAAS,GAAGuE,eAAe;EACnE;AACF;;AAEA;AACA,OAAO,SAASC,WAAWA,CAACtC,aAAa,EAAE8C,aAAa,EAAE;EACxD,MAAMC,aAAa,GAAGvL,gBAAgB,CAAC,CAAC;EAExCI,KAAK,CAACqG,UAAU,EAAE;EAClB,MAAMrD,eAAe,GAAGhD,KAAK,CAACiD,MAAM,CAACvB,MAAM;EAC3C,MAAM0J,cAAc,GAAGF,aAAa,CAAC,CAAC;EACtCvK,mBAAmB,CAACyK,cAAc,EAAED,aAAa,CAAC;EAClDE,0BAA0B,CAACjD,aAAa,EAAE+C,aAAa,CAAC;EACxD,MAAMG,aAAa,GAAGtL,KAAK,CAACiD,MAAM,CAACvB,MAAM;EACzC1B,KAAK,CAACuL,MAAM,CAACC,IAAI,CAAC,IAAIjM,KAAK,CAACyD,eAAe,EAAEsI,aAAa,EAAE,IAAI,CAAC,CAAC;EAClEtL,KAAK,CAACqG,UAAU,EAAE;AACpB;;AAEA;AACA;AACA;AACA,OAAO,SAASU,oBAAoBA,CAAC/D,eAAe,EAAE;EACpDyI,iBAAiB,CAAC,IAAI,CAAC;EACvB,MAAMH,aAAa,GAAGtL,KAAK,CAACiD,MAAM,CAACvB,MAAM;EACzC1B,KAAK,CAACuL,MAAM,CAACC,IAAI,CAAC,IAAIjM,KAAK,CAACyD,eAAe,EAAEsI,aAAa,EAAE,IAAI,CAAC,CAAC;EAClEtL,KAAK,CAACqG,UAAU,EAAE;AACpB;AAEA,OAAO,SAASgF,0BAA0BA,CAACjD,aAAa,EAAqB;EAAA,IAAnB+C,aAAa,GAAA1J,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EACzE,IAAI1B,mBAAmB,EAAE;IACvB3B,4BAA4B,CAACgK,aAAa,EAAE+C,aAAa,CAAC;EAC5D,CAAC,MAAM,IAAItL,aAAa,EAAE;IACxBrC,8BAA8B,CAAC2N,aAAa,CAAC;EAC/C,CAAC,MAAM;IACLM,iBAAiB,CAAC,KAAK,EAAEN,aAAa,CAAC;EACzC;AACF;AAEA,OAAO,SAASM,iBAAiBA,CAACC,eAAe,EAAqB;EAAA,IAAnBP,aAAa,GAAA1J,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAClE,MAAMkK,YAAY,GAAGD,eAAe,IAAI,CAAC3M,KAAK,CAACU,EAAE,CAACoJ,MAAM,CAAC;EAEzD,IAAI8C,YAAY,EAAE;IAChB/J,gBAAgB,CAAC,CAAC;EACpB,CAAC,MAAM;IACLtB,UAAU,CAAC,IAAI,CAAC,uBAAuB6K,aAAa,CAAC;EACvD;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAASvC,aAAaA,CAACgD,KAAK,EAAsB;EAAA,IAApBC,UAAU,GAAApK,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EAC9C,IAAIkF,KAAK,GAAG,IAAI;EAChB,OAAO,CAAChI,GAAG,CAACiN,KAAK,CAAC,IAAI,CAAC5L,KAAK,CAACmF,KAAK,EAAE;IAClC,IAAIwB,KAAK,EAAE;MACTA,KAAK,GAAG,KAAK;IACf,CAAC,MAAM;MACL7F,MAAM,CAACrB,EAAE,CAACoC,KAAK,CAAC;MAChB,IAAIlD,GAAG,CAACiN,KAAK,CAAC,EAAE;IAClB;IACA/E,iBAAiB,CAACgF,UAAU,CAAC;EAC/B;AACF;AAEA,SAAShF,iBAAiBA,CAACgF,UAAU,EAAE;EACrC,IAAIA,UAAU,IAAI9M,KAAK,CAACU,EAAE,CAACoC,KAAK,CAAC,EAAE;IACjC;EAAA,CACD,MAAM,IAAI9C,KAAK,CAACU,EAAE,CAAC+J,QAAQ,CAAC,EAAE;IAC7BnJ,WAAW,CAAC,CAAC;IACbmC,cAAc,CAAC,CAAC;EAClB,CAAC,MAAM,IAAIzD,KAAK,CAACU,EAAE,CAACqD,QAAQ,CAAC,EAAE;IAC7B;IACA9D,IAAI,CAAC,CAAC;EACR,CAAC,MAAM;IACL4C,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC;EAC/B;AACF;;AAEA;AACA,OAAO,SAASqF,eAAeA,CAAA,EAAG;EAChCjI,IAAI,CAAC,CAAC;EACNgB,KAAK,CAACiD,MAAM,CAACjD,KAAK,CAACiD,MAAM,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACe,IAAI,GAAGhD,EAAE,CAAC0C,IAAI;AACtD;;AAEA;AACA,SAASmG,UAAUA,CAAA,EAAG;EACpBpF,eAAe,CAAC,CAAC;AACnB;;AAEA;AACA,SAASjB,UAAUA,CAAA,EAAG;EACpBjD,IAAI,CAAC,CAAC;EACN,IAAI,CAACD,KAAK,CAACU,EAAE,CAACqM,IAAI,CAAC,IAAI,CAAClL,kBAAkB,CAAC,CAAC,EAAE;IAC5CjC,GAAG,CAACc,EAAE,CAACyK,IAAI,CAAC;IACZtI,gBAAgB,CAAC,CAAC;EACpB;AACF;;AAEA;AACA,SAASyC,qBAAqBA,CAAA,EAAG;EAC/BtD,gBAAgB,CAACzB,iBAAiB,CAAC6E,OAAO,CAAC;EAC3CrD,MAAM,CAACrB,EAAE,CAACoJ,MAAM,CAAC;EACjB;EACA;EACA;EACAtI,cAAc,CAACd,EAAE,CAACsK,MAAM,CAAC;AAC3B"},"metadata":{},"sourceType":"module","externalDependencies":[]}