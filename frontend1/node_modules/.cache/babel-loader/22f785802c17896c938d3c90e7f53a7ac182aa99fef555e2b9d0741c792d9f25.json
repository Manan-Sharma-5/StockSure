{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  isValidVariantFormatString: function () {\n    return isValidVariantFormatString;\n  },\n  parseVariant: function () {\n    return parseVariant;\n  },\n  getFileModifiedMap: function () {\n    return getFileModifiedMap;\n  },\n  createContext: function () {\n    return createContext;\n  },\n  getContext: function () {\n    return getContext;\n  }\n});\nconst _fs = /*#__PURE__*/_interop_require_default(require(\"fs\"));\nconst _url = /*#__PURE__*/_interop_require_default(require(\"url\"));\nconst _postcss = /*#__PURE__*/_interop_require_default(require(\"postcss\"));\nconst _dlv = /*#__PURE__*/_interop_require_default(require(\"dlv\"));\nconst _postcssselectorparser = /*#__PURE__*/_interop_require_default(require(\"postcss-selector-parser\"));\nconst _transformThemeValue = /*#__PURE__*/_interop_require_default(require(\"../util/transformThemeValue\"));\nconst _parseObjectStyles = /*#__PURE__*/_interop_require_default(require(\"../util/parseObjectStyles\"));\nconst _prefixSelector = /*#__PURE__*/_interop_require_default(require(\"../util/prefixSelector\"));\nconst _isPlainObject = /*#__PURE__*/_interop_require_default(require(\"../util/isPlainObject\"));\nconst _escapeClassName = /*#__PURE__*/_interop_require_default(require(\"../util/escapeClassName\"));\nconst _nameClass = /*#__PURE__*/_interop_require_wildcard(require(\"../util/nameClass\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _corePlugins = require(\"../corePlugins\");\nconst _sharedState = /*#__PURE__*/_interop_require_wildcard(require(\"./sharedState\"));\nconst _toPath = require(\"../util/toPath\");\nconst _log = /*#__PURE__*/_interop_require_default(require(\"../util/log\"));\nconst _negateValue = /*#__PURE__*/_interop_require_default(require(\"../util/negateValue\"));\nconst _isSyntacticallyValidPropertyValue = /*#__PURE__*/_interop_require_default(require(\"../util/isSyntacticallyValidPropertyValue\"));\nconst _generateRules = require(\"./generateRules\");\nconst _cacheInvalidation = require(\"./cacheInvalidation.js\");\nconst _offsets = require(\"./offsets.js\");\nconst _featureFlags = require(\"../featureFlags.js\");\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nconst VARIANT_TYPES = {\n  AddVariant: Symbol.for(\"ADD_VARIANT\"),\n  MatchVariant: Symbol.for(\"MATCH_VARIANT\")\n};\nconst VARIANT_INFO = {\n  Base: 1 << 0,\n  Dynamic: 1 << 1\n};\nfunction prefix(context, selector) {\n  let prefix = context.tailwindConfig.prefix;\n  return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction normalizeOptionTypes(_ref) {\n  let {\n    type = \"any\",\n    ...options\n  } = _ref;\n  let types = [].concat(type);\n  return {\n    ...options,\n    types: types.map(type => {\n      if (Array.isArray(type)) {\n        return {\n          type: type[0],\n          ...type[1]\n        };\n      }\n      return {\n        type,\n        preferOnConflict: false\n      };\n    })\n  };\n}\nfunction parseVariantFormatString(input) {\n  /** @type {string[]} */let parts = [];\n  // When parsing whitespace around special characters are insignificant\n  // However, _inside_ of a variant they could be\n  // Because the selector could look like this\n  // @media { &[data-name=\"foo bar\"] }\n  // This is why we do not skip whitespace\n  let current = \"\";\n  let depth = 0;\n  for (let idx = 0; idx < input.length; idx++) {\n    let char = input[idx];\n    if (char === \"\\\\\") {\n      // Escaped characters are not special\n      current += \"\\\\\" + input[++idx];\n    } else if (char === \"{\") {\n      // Nested rule: start\n      ++depth;\n      parts.push(current.trim());\n      current = \"\";\n    } else if (char === \"}\") {\n      // Nested rule: end\n      if (--depth < 0) {\n        throw new Error(`Your { and } are unbalanced.`);\n      }\n      parts.push(current.trim());\n      current = \"\";\n    } else {\n      // Normal character\n      current += char;\n    }\n  }\n  if (current.length > 0) {\n    parts.push(current.trim());\n  }\n  parts = parts.filter(part => part !== \"\");\n  return parts;\n}\nfunction insertInto(list, value) {\n  let {\n    before = []\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  before = [].concat(before);\n  if (before.length <= 0) {\n    list.push(value);\n    return;\n  }\n  let idx = list.length - 1;\n  for (let other of before) {\n    let iidx = list.indexOf(other);\n    if (iidx === -1) continue;\n    idx = Math.min(idx, iidx);\n  }\n  list.splice(idx, 0, value);\n}\nfunction parseStyles(styles) {\n  if (!Array.isArray(styles)) {\n    return parseStyles([styles]);\n  }\n  return styles.flatMap(style => {\n    let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);\n    return isNode ? style : (0, _parseObjectStyles.default)(style);\n  });\n}\nfunction getClasses(selector, mutate) {\n  let parser = (0, _postcssselectorparser.default)(selectors => {\n    let allClasses = [];\n    if (mutate) {\n      mutate(selectors);\n    }\n    selectors.walkClasses(classNode => {\n      allClasses.push(classNode.value);\n    });\n    return allClasses;\n  });\n  return parser.transformSync(selector);\n}\nfunction extractCandidates(node) {\n  let state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    containsNonOnDemandable: false\n  };\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let classes = [];\n  // Handle normal rules\n  if (node.type === \"rule\") {\n    // Ignore everything inside a :not(...). This allows you to write code like\n    // `div:not(.foo)`. If `.foo` is never found in your code, then we used to\n    // not generated it. But now we will ignore everything inside a `:not`, so\n    // that it still gets generated.\n    function ignoreNot(selectors) {\n      selectors.walkPseudos(pseudo => {\n        if (pseudo.value === \":not\") {\n          pseudo.remove();\n        }\n      });\n    }\n    for (let selector of node.selectors) {\n      let classCandidates = getClasses(selector, ignoreNot);\n      // At least one of the selectors contains non-\"on-demandable\" candidates.\n      if (classCandidates.length === 0) {\n        state.containsNonOnDemandable = true;\n      }\n      for (let classCandidate of classCandidates) {\n        classes.push(classCandidate);\n      }\n    }\n  } else if (node.type === \"atrule\") {\n    node.walkRules(rule => {\n      for (let classCandidate of rule.selectors.flatMap(selector => getClasses(selector))) {\n        classes.push(classCandidate);\n      }\n    });\n  }\n  if (depth === 0) {\n    return [state.containsNonOnDemandable || classes.length === 0, classes];\n  }\n  return classes;\n}\nfunction withIdentifiers(styles) {\n  return parseStyles(styles).flatMap(node => {\n    let nodeMap = new Map();\n    let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);\n    // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n    if (containsNonOnDemandableSelectors) {\n      candidates.unshift(_sharedState.NOT_ON_DEMAND);\n    }\n    // However, it could be that it also contains \"on-demandable\" candidates.\n    // E.g.: `span, .foo {}`, in that case it should still be possible to use\n    // `@apply foo` for example.\n    return candidates.map(c => {\n      if (!nodeMap.has(node)) {\n        nodeMap.set(node, node);\n      }\n      return [c, nodeMap.get(node)];\n    });\n  });\n}\nfunction isValidVariantFormatString(format) {\n  return format.startsWith(\"@\") || format.includes(\"&\");\n}\nfunction parseVariant(variant) {\n  variant = variant.replace(/\\n+/g, \"\").replace(/\\s{1,}/g, \" \").trim();\n  let fns = parseVariantFormatString(variant).map(str => {\n    if (!str.startsWith(\"@\")) {\n      return _ref2 => {\n        let {\n          format\n        } = _ref2;\n        return format(str);\n      };\n    }\n    let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str);\n    return _ref3 => {\n      let {\n        wrap\n      } = _ref3;\n      return wrap(_postcss.default.atRule({\n        name,\n        params: params.trim()\n      }));\n    };\n  }).reverse();\n  return api => {\n    for (let fn of fns) {\n      fn(api);\n    }\n  };\n}\n/**\n *\n * @param {any} tailwindConfig\n * @param {any} context\n * @param {object} param2\n * @param {Offsets} param2.offsets\n */\nfunction buildPluginApi(tailwindConfig, context, _ref4) {\n  let {\n    variantList,\n    variantMap,\n    offsets,\n    classList\n  } = _ref4;\n  function getConfigValue(path, defaultValue) {\n    return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;\n  }\n  function applyConfiguredPrefix(selector) {\n    return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);\n  }\n  function prefixIdentifier(identifier, options) {\n    if (identifier === _sharedState.NOT_ON_DEMAND) {\n      return _sharedState.NOT_ON_DEMAND;\n    }\n    if (!options.respectPrefix) {\n      return identifier;\n    }\n    return context.tailwindConfig.prefix + identifier;\n  }\n  function resolveThemeValue(path, defaultValue) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let parts = (0, _toPath.toPath)(path);\n    let value = getConfigValue([\"theme\", ...parts], defaultValue);\n    return (0, _transformThemeValue.default)(parts[0])(value, opts);\n  }\n  let variantIdentifier = 0;\n  let api = {\n    postcss: _postcss.default,\n    prefix: applyConfiguredPrefix,\n    e: _escapeClassName.default,\n    config: getConfigValue,\n    theme: resolveThemeValue,\n    corePlugins: path => {\n      if (Array.isArray(tailwindConfig.corePlugins)) {\n        return tailwindConfig.corePlugins.includes(path);\n      }\n      return getConfigValue([\"corePlugins\", path], true);\n    },\n    variants: () => {\n      // Preserved for backwards compatibility but not used in v3.0+\n      return [];\n    },\n    addBase(base) {\n      for (let [identifier, rule] of withIdentifiers(base)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n        let offset = offsets.create(\"base\");\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: \"base\"\n        }, rule]);\n      }\n    },\n    /**\n    * @param {string} group\n    * @param {Record<string, string | string[]>} declarations\n    */\n    addDefaults(group, declarations) {\n      const groups = {\n        [`@defaults ${group}`]: declarations\n      };\n      for (let [identifier, rule] of withIdentifiers(groups)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.create(\"defaults\"),\n          layer: \"defaults\"\n        }, rule]);\n      }\n    },\n    addComponents(components, options) {\n      let defaultOptions = {\n        preserveSource: false,\n        respectPrefix: true,\n        respectImportant: false\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n      for (let [identifier, rule] of withIdentifiers(components)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        classList.add(prefixedIdentifier);\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.create(\"components\"),\n          layer: \"components\",\n          options\n        }, rule]);\n      }\n    },\n    addUtilities(utilities, options) {\n      let defaultOptions = {\n        preserveSource: false,\n        respectPrefix: true,\n        respectImportant: true\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n      for (let [identifier, rule] of withIdentifiers(utilities)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        classList.add(prefixedIdentifier);\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.create(\"utilities\"),\n          layer: \"utilities\",\n          options\n        }, rule]);\n      }\n    },\n    matchUtilities: function (utilities, options) {\n      let defaultOptions = {\n        respectPrefix: true,\n        respectImportant: true,\n        modifiers: false\n      };\n      options = normalizeOptionTypes({\n        ...defaultOptions,\n        ...options\n      });\n      let offset = offsets.create(\"utilities\");\n      for (let identifier in utilities) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let rule = utilities[identifier];\n        classList.add([prefixedIdentifier, options]);\n        function wrapped(modifier, _ref5) {\n          let {\n            isOnlyPlugin\n          } = _ref5;\n          let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n          if (value === undefined) {\n            return [];\n          }\n          if (!options.types.some(_ref6 => {\n            let {\n              type\n            } = _ref6;\n            return type === coercedType;\n          })) {\n            if (isOnlyPlugin) {\n              _log.default.warn([`Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`, `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`]);\n            } else {\n              return [];\n            }\n          }\n          if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n            return [];\n          }\n          let extras = {\n            get modifier() {\n              if (!options.modifiers) {\n                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\"Your plugin must set `modifiers: true` in its options to support modifiers.\"]);\n              }\n              return utilityModifier;\n            }\n          };\n          let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n          let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map(declaration => ({\n            [(0, _nameClass.default)(identifier, modifier)]: declaration\n          }));\n          return ruleSets;\n        }\n        let withOffsets = [{\n          sort: offset,\n          layer: \"utilities\",\n          options\n        }, wrapped];\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      }\n    },\n    matchComponents: function (components, options) {\n      let defaultOptions = {\n        respectPrefix: true,\n        respectImportant: false,\n        modifiers: false\n      };\n      options = normalizeOptionTypes({\n        ...defaultOptions,\n        ...options\n      });\n      let offset = offsets.create(\"components\");\n      for (let identifier in components) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let rule = components[identifier];\n        classList.add([prefixedIdentifier, options]);\n        function wrapped(modifier, _ref7) {\n          let {\n            isOnlyPlugin\n          } = _ref7;\n          let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n          if (value === undefined) {\n            return [];\n          }\n          if (!options.types.some(_ref8 => {\n            let {\n              type\n            } = _ref8;\n            return type === coercedType;\n          })) {\n            if (isOnlyPlugin) {\n              _log.default.warn([`Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`, `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`]);\n            } else {\n              return [];\n            }\n          }\n          if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n            return [];\n          }\n          let extras = {\n            get modifier() {\n              if (!options.modifiers) {\n                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\"Your plugin must set `modifiers: true` in its options to support modifiers.\"]);\n              }\n              return utilityModifier;\n            }\n          };\n          let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n          let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map(declaration => ({\n            [(0, _nameClass.default)(identifier, modifier)]: declaration\n          }));\n          return ruleSets;\n        }\n        let withOffsets = [{\n          sort: offset,\n          layer: \"components\",\n          options\n        }, wrapped];\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      }\n    },\n    addVariant(variantName, variantFunctions) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      variantFunctions = [].concat(variantFunctions).map(variantFunction => {\n        if (typeof variantFunction !== \"string\") {\n          // Safelist public API functions\n          return function () {\n            let api = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            let {\n              args,\n              modifySelectors,\n              container,\n              separator,\n              wrap,\n              format\n            } = api;\n            let result = variantFunction(Object.assign({\n              modifySelectors,\n              container,\n              separator\n            }, options.type === VARIANT_TYPES.MatchVariant && {\n              args,\n              wrap,\n              format\n            }));\n            if (typeof result === \"string\" && !isValidVariantFormatString(result)) {\n              throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n            }\n            if (Array.isArray(result)) {\n              return result.filter(variant => typeof variant === \"string\").map(variant => parseVariant(variant));\n            }\n            // result may be undefined with legacy variants that use APIs like `modifySelectors`\n            // result may also be a postcss node if someone was returning the result from `modifySelectors`\n            return result && typeof result === \"string\" && parseVariant(result)(api);\n          };\n        }\n        if (!isValidVariantFormatString(variantFunction)) {\n          throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n        }\n        return parseVariant(variantFunction);\n      });\n      insertInto(variantList, variantName, options);\n      variantMap.set(variantName, variantFunctions);\n      context.variantOptions.set(variantName, options);\n    },\n    matchVariant(variant, variantFn, options) {\n      var _options_id;\n      // A unique identifier that \"groups\" these variants together.\n      // This is for internal use only which is why it is not present in the types\n      let id = (_options_id = options === null || options === void 0 ? void 0 : options.id) !== null && _options_id !== void 0 ? _options_id : ++variantIdentifier;\n      let isSpecial = variant === \"@\";\n      let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n      var _options_values;\n      for (let [key, value] of Object.entries((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {})) {\n        if (key === \"DEFAULT\") continue;\n        api.addVariant(isSpecial ? `${variant}${key}` : `${variant}-${key}`, _ref9 => {\n          let {\n            args,\n            container\n          } = _ref9;\n          return variantFn(value, modifiersEnabled ? {\n            modifier: args === null || args === void 0 ? void 0 : args.modifier,\n            container\n          } : {\n            container\n          });\n        }, {\n          ...options,\n          value,\n          id,\n          type: VARIANT_TYPES.MatchVariant,\n          variantInfo: VARIANT_INFO.Base\n        });\n      }\n      var _options_values1;\n      let hasDefault = (\"DEFAULT\" in ((_options_values1 = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {}));\n      api.addVariant(variant, _ref10 => {\n        let {\n          args,\n          container\n        } = _ref10;\n        if ((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE && !hasDefault) {\n          return null;\n        }\n        var\n        // (JetBrains) plugins.\n        _args_value;\n        return variantFn((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE ? options.values.DEFAULT : (_args_value = args === null || args === void 0 ? void 0 : args.value) !== null && _args_value !== void 0 ? _args_value : typeof args === \"string\" ? args : \"\", modifiersEnabled ? {\n          modifier: args === null || args === void 0 ? void 0 : args.modifier,\n          container\n        } : {\n          container\n        });\n      }, {\n        ...options,\n        id,\n        type: VARIANT_TYPES.MatchVariant,\n        variantInfo: VARIANT_INFO.Dynamic\n      });\n    }\n  };\n  return api;\n}\nlet fileModifiedMapCache = new WeakMap();\nfunction getFileModifiedMap(context) {\n  if (!fileModifiedMapCache.has(context)) {\n    fileModifiedMapCache.set(context, new Map());\n  }\n  return fileModifiedMapCache.get(context);\n}\nfunction trackModified(files, fileModifiedMap) {\n  let changed = false;\n  let mtimesToCommit = new Map();\n  for (let file of files) {\n    var _fs_statSync;\n    if (!file) continue;\n    let parsed = _url.default.parse(file);\n    let pathname = parsed.hash ? parsed.href.replace(parsed.hash, \"\") : parsed.href;\n    pathname = parsed.search ? pathname.replace(parsed.search, \"\") : pathname;\n    let newModified = (_fs_statSync = _fs.default.statSync(decodeURIComponent(pathname), {\n      throwIfNoEntry: false\n    })) === null || _fs_statSync === void 0 ? void 0 : _fs_statSync.mtimeMs;\n    if (!newModified) {\n      continue;\n    }\n    if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n      changed = true;\n    }\n    mtimesToCommit.set(file, newModified);\n  }\n  return [changed, mtimesToCommit];\n}\nfunction extractVariantAtRules(node) {\n  node.walkAtRules(atRule => {\n    if ([\"responsive\", \"variants\"].includes(atRule.name)) {\n      extractVariantAtRules(atRule);\n      atRule.before(atRule.nodes);\n      atRule.remove();\n    }\n  });\n}\nfunction collectLayerPlugins(root) {\n  let layerPlugins = [];\n  root.each(node => {\n    if (node.type === \"atrule\" && [\"responsive\", \"variants\"].includes(node.name)) {\n      node.name = \"layer\";\n      node.params = \"utilities\";\n    }\n  });\n  // Walk @layer rules and treat them like plugins\n  root.walkAtRules(\"layer\", layerRule => {\n    extractVariantAtRules(layerRule);\n    if (layerRule.params === \"base\") {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function (_ref11) {\n          let {\n            addBase\n          } = _ref11;\n          addBase(node, {\n            respectPrefix: false\n          });\n        });\n      }\n      layerRule.remove();\n    } else if (layerRule.params === \"components\") {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function (_ref12) {\n          let {\n            addComponents\n          } = _ref12;\n          addComponents(node, {\n            respectPrefix: false,\n            preserveSource: true\n          });\n        });\n      }\n      layerRule.remove();\n    } else if (layerRule.params === \"utilities\") {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function (_ref13) {\n          let {\n            addUtilities\n          } = _ref13;\n          addUtilities(node, {\n            respectPrefix: false,\n            preserveSource: true\n          });\n        });\n      }\n      layerRule.remove();\n    }\n  });\n  return layerPlugins;\n}\nfunction resolvePlugins(context, root) {\n  let corePluginList = Object.entries({\n    ..._corePlugins.variantPlugins,\n    ..._corePlugins.corePlugins\n  }).map(_ref14 => {\n    let [name, plugin] = _ref14;\n    if (!context.tailwindConfig.corePlugins.includes(name)) {\n      return null;\n    }\n    return plugin;\n  }).filter(Boolean);\n  let userPlugins = context.tailwindConfig.plugins.map(plugin => {\n    if (plugin.__isOptionsFunction) {\n      plugin = plugin();\n    }\n    return typeof plugin === \"function\" ? plugin : plugin.handler;\n  });\n  let layerPlugins = collectLayerPlugins(root);\n  // TODO: This is a workaround for backwards compatibility, since custom variants\n  // were historically sorted before screen/stackable variants.\n  let beforeVariants = [_corePlugins.variantPlugins[\"pseudoElementVariants\"], _corePlugins.variantPlugins[\"pseudoClassVariants\"], _corePlugins.variantPlugins[\"ariaVariants\"], _corePlugins.variantPlugins[\"dataVariants\"]];\n  let afterVariants = [_corePlugins.variantPlugins[\"supportsVariants\"], _corePlugins.variantPlugins[\"directionVariants\"], _corePlugins.variantPlugins[\"reducedMotionVariants\"], _corePlugins.variantPlugins[\"prefersContrastVariants\"], _corePlugins.variantPlugins[\"darkVariants\"], _corePlugins.variantPlugins[\"printVariant\"], _corePlugins.variantPlugins[\"screenVariants\"], _corePlugins.variantPlugins[\"orientationVariants\"]];\n  return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins];\n}\nfunction registerPlugins(plugins, context) {\n  let variantList = [];\n  let variantMap = new Map();\n  context.variantMap = variantMap;\n  let offsets = new _offsets.Offsets();\n  context.offsets = offsets;\n  let classList = new Set();\n  let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n    variantList,\n    variantMap,\n    offsets,\n    classList\n  });\n  for (let plugin of plugins) {\n    if (Array.isArray(plugin)) {\n      for (let pluginItem of plugin) {\n        pluginItem(pluginApi);\n      }\n    } else {\n      plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);\n    }\n  }\n  // Make sure to record bit masks for every variant\n  offsets.recordVariants(variantList, variant => variantMap.get(variant).length);\n  // Build variantMap\n  for (let [variantName, variantFunctions] of variantMap.entries()) {\n    context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx) => [offsets.forVariant(variantName, idx), variantFunction]));\n  }\n  var _context_tailwindConfig_safelist;\n  let safelist = ((_context_tailwindConfig_safelist = context.tailwindConfig.safelist) !== null && _context_tailwindConfig_safelist !== void 0 ? _context_tailwindConfig_safelist : []).filter(Boolean);\n  if (safelist.length > 0) {\n    let checks = [];\n    for (let value of safelist) {\n      if (typeof value === \"string\") {\n        context.changedContent.push({\n          content: value,\n          extension: \"html\"\n        });\n        continue;\n      }\n      if (value instanceof RegExp) {\n        _log.default.warn(\"root-regex\", [\"Regular expressions in `safelist` work differently in Tailwind CSS v3.0.\", \"Update your `safelist` configuration to eliminate this warning.\", \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"]);\n        continue;\n      }\n      checks.push(value);\n    }\n    if (checks.length > 0) {\n      let patternMatchingCount = new Map();\n      let prefixLength = context.tailwindConfig.prefix.length;\n      let checkImportantUtils = checks.some(check => check.pattern.source.includes(\"!\"));\n      for (let util of classList) {\n        let utils = Array.isArray(util) ? (() => {\n          let [utilName, options] = util;\n          var _options_values;\n          let values = Object.keys((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {});\n          let classes = values.map(value => (0, _nameClass.formatClass)(utilName, value));\n          if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {\n            // This is the normal negated version\n            // e.g. `-inset-1` or `-tw-inset-1`\n            classes = [...classes, ...classes.map(cls => \"-\" + cls)];\n            // This is the negated version *after* the prefix\n            // e.g. `tw--inset-1`\n            // The prefix is already attached to util name\n            // So we add the negative after the prefix\n            classes = [...classes, ...classes.map(cls => cls.slice(0, prefixLength) + \"-\" + cls.slice(prefixLength))];\n          }\n          if (options.types.some(_ref15 => {\n            let {\n              type\n            } = _ref15;\n            return type === \"color\";\n          })) {\n            classes = [...classes, ...classes.flatMap(cls => Object.keys(context.tailwindConfig.theme.opacity).map(opacity => `${cls}/${opacity}`))];\n          }\n          if (checkImportantUtils && (options === null || options === void 0 ? void 0 : options.respectImportant)) {\n            classes = [...classes, ...classes.map(cls => \"!\" + cls)];\n          }\n          return classes;\n        })() : [util];\n        for (let util of utils) {\n          for (let {\n            pattern,\n            variants = []\n          } of checks) {\n            // RegExp with the /g flag are stateful, so let's reset the last\n            // index pointer to reset the state.\n            pattern.lastIndex = 0;\n            if (!patternMatchingCount.has(pattern)) {\n              patternMatchingCount.set(pattern, 0);\n            }\n            if (!pattern.test(util)) continue;\n            patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);\n            context.changedContent.push({\n              content: util,\n              extension: \"html\"\n            });\n            for (let variant of variants) {\n              context.changedContent.push({\n                content: variant + context.tailwindConfig.separator + util,\n                extension: \"html\"\n              });\n            }\n          }\n        }\n      }\n      for (let [regex, count] of patternMatchingCount.entries()) {\n        if (count !== 0) continue;\n        _log.default.warn([`The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`, \"Fix this pattern or remove it from your `safelist` configuration.\", \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"]);\n      }\n    }\n  }\n  var _context_tailwindConfig_darkMode, _concat_;\n  let darkClassName = (_concat_ = [].concat((_context_tailwindConfig_darkMode = context.tailwindConfig.darkMode) !== null && _context_tailwindConfig_darkMode !== void 0 ? _context_tailwindConfig_darkMode : \"media\")[1]) !== null && _concat_ !== void 0 ? _concat_ : \"dark\";\n  // A list of utilities that are used by certain Tailwind CSS utilities but\n  // that don't exist on their own. This will result in them \"not existing\" and\n  // sorting could be weird since you still require them in order to make the\n  // host utilities work properly. (Thanks Biology)\n  let parasiteUtilities = [prefix(context, darkClassName), prefix(context, \"group\"), prefix(context, \"peer\")];\n  context.getClassOrder = function getClassOrder(classes) {\n    // Sort classes so they're ordered in a deterministic manner\n    let sorted = [...classes].sort((a, z) => {\n      if (a === z) return 0;\n      if (a < z) return -1;\n      return 1;\n    });\n    // Non-util classes won't be generated, so we default them to null\n    let sortedClassNames = new Map(sorted.map(className => [className, null]));\n    // Sort all classes in order\n    // Non-tailwind classes won't be generated and will be left as `null`\n    let rules = (0, _generateRules.generateRules)(new Set(sorted), context);\n    rules = context.offsets.sort(rules);\n    let idx = BigInt(parasiteUtilities.length);\n    for (const [, rule] of rules) {\n      sortedClassNames.set(rule.raws.tailwind.candidate, idx++);\n    }\n    return classes.map(className => {\n      var _sortedClassNames_get;\n      let order = (_sortedClassNames_get = sortedClassNames.get(className)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : null;\n      let parasiteIndex = parasiteUtilities.indexOf(className);\n      if (order === null && parasiteIndex !== -1) {\n        // This will make sure that it is at the very beginning of the\n        // `components` layer which technically means 'before any\n        // components'.\n        order = BigInt(parasiteIndex);\n      }\n      return [className, order];\n    });\n  };\n  // Generate a list of strings for autocompletion purposes, e.g.\n  // ['uppercase', 'lowercase', ...]\n  context.getClassList = function getClassList() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let output = [];\n    for (let util of classList) {\n      if (Array.isArray(util)) {\n        var _utilOptions_types;\n        let [utilName, utilOptions] = util;\n        let negativeClasses = [];\n        var _utilOptions_modifiers;\n        let modifiers = Object.keys((_utilOptions_modifiers = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.modifiers) !== null && _utilOptions_modifiers !== void 0 ? _utilOptions_modifiers : {});\n        if (utilOptions === null || utilOptions === void 0 ? void 0 : (_utilOptions_types = utilOptions.types) === null || _utilOptions_types === void 0 ? void 0 : _utilOptions_types.some(_ref16 => {\n          let {\n            type\n          } = _ref16;\n          return type === \"color\";\n        })) {\n          var _context_tailwindConfig_theme_opacity;\n          modifiers.push(...Object.keys((_context_tailwindConfig_theme_opacity = context.tailwindConfig.theme.opacity) !== null && _context_tailwindConfig_theme_opacity !== void 0 ? _context_tailwindConfig_theme_opacity : {}));\n        }\n        let metadata = {\n          modifiers\n        };\n        let includeMetadata = options.includeMetadata && modifiers.length > 0;\n        var _utilOptions_values;\n        for (let [key, value] of Object.entries((_utilOptions_values = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.values) !== null && _utilOptions_values !== void 0 ? _utilOptions_values : {})) {\n          // Ignore undefined and null values\n          if (value == null) {\n            continue;\n          }\n          let cls = (0, _nameClass.formatClass)(utilName, key);\n          output.push(includeMetadata ? [cls, metadata] : cls);\n          if ((utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.supportsNegativeValues) && (0, _negateValue.default)(value)) {\n            let cls = (0, _nameClass.formatClass)(utilName, `-${key}`);\n            negativeClasses.push(includeMetadata ? [cls, metadata] : cls);\n          }\n        }\n        output.push(...negativeClasses);\n      } else {\n        output.push(util);\n      }\n    }\n    return output;\n  };\n  // Generate a list of available variants with meta information of the type of variant.\n  context.getVariants = function getVariants() {\n    let result = [];\n    for (let [name, options] of context.variantOptions.entries()) {\n      if (options.variantInfo === VARIANT_INFO.Base) continue;\n      var _options_values;\n      result.push({\n        name,\n        isArbitrary: options.type === Symbol.for(\"MATCH_VARIANT\"),\n        values: Object.keys((_options_values = options.values) !== null && _options_values !== void 0 ? _options_values : {}),\n        hasDash: name !== \"@\",\n        selectors() {\n          let {\n            modifier,\n            value\n          } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          let candidate = \"__TAILWIND_PLACEHOLDER__\";\n          let rule = _postcss.default.rule({\n            selector: `.${candidate}`\n          });\n          let container = _postcss.default.root({\n            nodes: [rule.clone()]\n          });\n          let before = container.toString();\n          var _context_variantMap_get;\n          let fns = ((_context_variantMap_get = context.variantMap.get(name)) !== null && _context_variantMap_get !== void 0 ? _context_variantMap_get : []).flatMap(_ref17 => {\n            let [_, fn] = _ref17;\n            return fn;\n          });\n          let formatStrings = [];\n          for (let fn of fns) {\n            var _options_values;\n            let localFormatStrings = [];\n            var _options_values_value;\n            let api = {\n              args: {\n                modifier,\n                value: (_options_values_value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[value]) !== null && _options_values_value !== void 0 ? _options_values_value : value\n              },\n              separator: context.tailwindConfig.separator,\n              modifySelectors(modifierFunction) {\n                // Run the modifierFunction over each rule\n                container.each(rule => {\n                  if (rule.type !== \"rule\") {\n                    return;\n                  }\n                  rule.selectors = rule.selectors.map(selector => {\n                    return modifierFunction({\n                      get className() {\n                        return (0, _generateRules.getClassNameFromSelector)(selector);\n                      },\n                      selector\n                    });\n                  });\n                });\n                return container;\n              },\n              format(str) {\n                localFormatStrings.push(str);\n              },\n              wrap(wrapper) {\n                localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);\n              },\n              container\n            };\n            let ruleWithVariant = fn(api);\n            if (localFormatStrings.length > 0) {\n              formatStrings.push(localFormatStrings);\n            }\n            if (Array.isArray(ruleWithVariant)) {\n              for (let variantFunction of ruleWithVariant) {\n                localFormatStrings = [];\n                variantFunction(api);\n                formatStrings.push(localFormatStrings);\n              }\n            }\n          }\n          // Reverse engineer the result of the `container`\n          let manualFormatStrings = [];\n          let after = container.toString();\n          if (before !== after) {\n            // Figure out all selectors\n            container.walkRules(rule => {\n              let modified = rule.selector;\n              // Rebuild the base selector, this is what plugin authors would do\n              // as well. E.g.: `${variant}${separator}${className}`.\n              // However, plugin authors probably also prepend or append certain\n              // classes, pseudos, ids, ...\n              let rebuiltBase = (0, _postcssselectorparser.default)(selectors => {\n                selectors.walkClasses(classNode => {\n                  classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;\n                });\n              }).processSync(modified);\n              // Now that we know the original selector, the new selector, and\n              // the rebuild part in between, we can replace the part that plugin\n              // authors need to rebuild with `&`, and eventually store it in the\n              // collectedFormats. Similar to what `format('...')` would do.\n              //\n              // E.g.:\n              //                   variant: foo\n              //                  selector: .markdown > p\n              //      modified (by plugin): .foo .foo\\\\:markdown > p\n              //    rebuiltBase (internal): .foo\\\\:markdown > p\n              //                    format: .foo &\n              manualFormatStrings.push(modified.replace(rebuiltBase, \"&\").replace(candidate, \"&\"));\n            });\n            // Figure out all atrules\n            container.walkAtRules(atrule => {\n              manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);\n            });\n          }\n          var _options_values1;\n          let isArbitraryVariant = !(value in ((_options_values1 = options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {}));\n          formatStrings = formatStrings.map(format => format.map(str => ({\n            format: str,\n            isArbitraryVariant\n          })));\n          manualFormatStrings = manualFormatStrings.map(format => ({\n            format,\n            isArbitraryVariant\n          }));\n          let opts = {\n            candidate,\n            context\n          };\n          let result = formatStrings.map(formats => (0, _formatVariantSelector.finalizeSelector)(`.${candidate}`, (0, _formatVariantSelector.formatVariantSelector)(formats, opts), opts).replace(`.${candidate}`, \"&\").replace(\"{ & }\", \"\").trim());\n          if (manualFormatStrings.length > 0) {\n            result.push((0, _formatVariantSelector.formatVariantSelector)(manualFormatStrings, opts).toString().replace(`.${candidate}`, \"&\"));\n          }\n          return result;\n        }\n      });\n    }\n    return result;\n  };\n}\n/**\n * Mark as class as retroactively invalid\n *\n *\n * @param {string} candidate\n */\nfunction markInvalidUtilityCandidate(context, candidate) {\n  if (!context.classCache.has(candidate)) {\n    return;\n  }\n  // Mark this as not being a real utility\n  context.notClassCache.add(candidate);\n  // Remove it from any candidate-specific caches\n  context.classCache.delete(candidate);\n  context.applyClassCache.delete(candidate);\n  context.candidateRuleMap.delete(candidate);\n  context.candidateRuleCache.delete(candidate);\n  // Ensure the stylesheet gets rebuilt\n  context.stylesheetCache = null;\n}\n/**\n * Mark as class as retroactively invalid\n *\n * @param {import('postcss').Node} node\n */\nfunction markInvalidUtilityNode(context, node) {\n  let candidate = node.raws.tailwind.candidate;\n  if (!candidate) {\n    return;\n  }\n  for (const entry of context.ruleCache) {\n    if (entry[1].raws.tailwind.candidate === candidate) {\n      context.ruleCache.delete(entry);\n      // context.postCssNodeCache.delete(node)\n    }\n  }\n\n  markInvalidUtilityCandidate(context, candidate);\n}\nfunction createContext(tailwindConfig) {\n  let changedContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _postcss.default.root();\n  var _tailwindConfig_blocklist;\n  let context = {\n    disposables: [],\n    ruleCache: new Set(),\n    candidateRuleCache: new Map(),\n    classCache: new Map(),\n    applyClassCache: new Map(),\n    // Seed the not class cache with the blocklist (which is only strings)\n    notClassCache: new Set((_tailwindConfig_blocklist = tailwindConfig.blocklist) !== null && _tailwindConfig_blocklist !== void 0 ? _tailwindConfig_blocklist : []),\n    postCssNodeCache: new Map(),\n    candidateRuleMap: new Map(),\n    tailwindConfig,\n    changedContent: changedContent,\n    variantMap: new Map(),\n    stylesheetCache: null,\n    variantOptions: new Map(),\n    markInvalidUtilityCandidate: candidate => markInvalidUtilityCandidate(context, candidate),\n    markInvalidUtilityNode: node => markInvalidUtilityNode(context, node)\n  };\n  let resolvedPlugins = resolvePlugins(context, root);\n  registerPlugins(resolvedPlugins, context);\n  return context;\n}\nlet contextMap = _sharedState.contextMap;\nlet configContextMap = _sharedState.configContextMap;\nlet contextSourcesMap = _sharedState.contextSourcesMap;\nfunction getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n  let sourcePath = result.opts.from;\n  let isConfigFile = userConfigPath !== null;\n  _sharedState.env.DEBUG && console.log(\"Source path:\", sourcePath);\n  let existingContext;\n  if (isConfigFile && contextMap.has(sourcePath)) {\n    existingContext = contextMap.get(sourcePath);\n  } else if (configContextMap.has(tailwindConfigHash)) {\n    let context = configContextMap.get(tailwindConfigHash);\n    contextSourcesMap.get(context).add(sourcePath);\n    contextMap.set(sourcePath, context);\n    existingContext = context;\n  }\n  let cssDidChange = (0, _cacheInvalidation.hasContentChanged)(sourcePath, root);\n  // If there's already a context in the cache and we don't need to\n  // reset the context, return the cached context.\n  if (existingContext) {\n    let [contextDependenciesChanged, mtimesToCommit] = trackModified([...contextDependencies], getFileModifiedMap(existingContext));\n    if (!contextDependenciesChanged && !cssDidChange) {\n      return [existingContext, false, mtimesToCommit];\n    }\n  }\n  // If this source is in the context map, get the old context.\n  // Remove this source from the context sources for the old context,\n  // and clean up that context if no one else is using it. This can be\n  // called by many processes in rapid succession, so we check for presence\n  // first because the first process to run this code will wipe it out first.\n  if (contextMap.has(sourcePath)) {\n    let oldContext = contextMap.get(sourcePath);\n    if (contextSourcesMap.has(oldContext)) {\n      contextSourcesMap.get(oldContext).delete(sourcePath);\n      if (contextSourcesMap.get(oldContext).size === 0) {\n        contextSourcesMap.delete(oldContext);\n        for (let [tailwindConfigHash, context] of configContextMap) {\n          if (context === oldContext) {\n            configContextMap.delete(tailwindConfigHash);\n          }\n        }\n        for (let disposable of oldContext.disposables.splice(0)) {\n          disposable(oldContext);\n        }\n      }\n    }\n  }\n  _sharedState.env.DEBUG && console.log(\"Setting up new context...\");\n  let context = createContext(tailwindConfig, [], root);\n  Object.assign(context, {\n    userConfigPath\n  });\n  let [, mtimesToCommit] = trackModified([...contextDependencies], getFileModifiedMap(context));\n  // ---\n  // Update all context tracking state\n  configContextMap.set(tailwindConfigHash, context);\n  contextMap.set(sourcePath, context);\n  if (!contextSourcesMap.has(context)) {\n    contextSourcesMap.set(context, new Set());\n  }\n  contextSourcesMap.get(context).add(sourcePath);\n  return [context, true, mtimesToCommit];\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","isValidVariantFormatString","parseVariant","getFileModifiedMap","createContext","getContext","_fs","_interop_require_default","require","_url","_postcss","_dlv","_postcssselectorparser","_transformThemeValue","_parseObjectStyles","_prefixSelector","_isPlainObject","_escapeClassName","_nameClass","_interop_require_wildcard","_pluginUtils","_corePlugins","_sharedState","_toPath","_log","_negateValue","_isSyntacticallyValidPropertyValue","_generateRules","_cacheInvalidation","_offsets","_featureFlags","_formatVariantSelector","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","VARIANT_TYPES","AddVariant","Symbol","for","MatchVariant","VARIANT_INFO","Base","Dynamic","prefix","context","selector","tailwindConfig","normalizeOptionTypes","_ref","type","options","types","concat","map","Array","isArray","preferOnConflict","parseVariantFormatString","input","parts","current","depth","idx","length","char","push","trim","Error","filter","part","insertInto","list","before","arguments","undefined","other","iidx","indexOf","Math","min","splice","parseStyles","styles","flatMap","style","isNode","getClasses","mutate","parser","selectors","allClasses","walkClasses","classNode","transformSync","extractCandidates","node","state","containsNonOnDemandable","classes","ignoreNot","walkPseudos","pseudo","remove","classCandidates","classCandidate","walkRules","rule","withIdentifiers","nodeMap","Map","containsNonOnDemandableSelectors","candidates","unshift","NOT_ON_DEMAND","c","format","startsWith","includes","variant","replace","fns","str","_ref2","params","exec","_ref3","wrap","atRule","reverse","api","fn","buildPluginApi","_ref4","variantList","variantMap","offsets","classList","getConfigValue","path","defaultValue","applyConfiguredPrefix","prefixIdentifier","identifier","respectPrefix","resolveThemeValue","opts","toPath","variantIdentifier","postcss","e","config","theme","corePlugins","variants","addBase","base","prefixedIdentifier","offset","create","candidateRuleMap","sort","layer","addDefaults","group","declarations","groups","addComponents","components","defaultOptions","preserveSource","respectImportant","assign","add","addUtilities","utilities","matchUtilities","modifiers","wrapped","modifier","_ref5","isOnlyPlugin","coercedType","utilityModifier","coerceValue","some","_ref6","warn","extras","modifiersEnabled","flagEnabled","ruleSets","Boolean","declaration","withOffsets","matchComponents","_ref7","_ref8","addVariant","variantName","variantFunctions","variantFunction","args","modifySelectors","container","separator","result","variantOptions","matchVariant","variantFn","_options_id","id","isSpecial","_options_values","entries","values","_ref9","variantInfo","_options_values1","hasDefault","_ref10","NONE","_args_value","DEFAULT","fileModifiedMapCache","trackModified","files","fileModifiedMap","changed","mtimesToCommit","file","_fs_statSync","parsed","parse","pathname","hash","href","search","newModified","statSync","decodeURIComponent","throwIfNoEntry","mtimeMs","extractVariantAtRules","walkAtRules","nodes","collectLayerPlugins","root","layerPlugins","each","layerRule","_ref11","_ref12","_ref13","resolvePlugins","corePluginList","variantPlugins","_ref14","plugin","userPlugins","plugins","__isOptionsFunction","handler","beforeVariants","afterVariants","registerPlugins","Offsets","Set","pluginApi","pluginItem","recordVariants","forVariant","_context_tailwindConfig_safelist","safelist","checks","changedContent","content","extension","RegExp","patternMatchingCount","prefixLength","checkImportantUtils","check","pattern","source","util","utils","utilName","keys","formatClass","supportsNegativeValues","cls","slice","_ref15","opacity","lastIndex","test","regex","count","_context_tailwindConfig_darkMode","_concat_","darkClassName","darkMode","parasiteUtilities","getClassOrder","sorted","a","z","sortedClassNames","className","rules","generateRules","BigInt","raws","tailwind","candidate","_sortedClassNames_get","order","parasiteIndex","getClassList","output","_utilOptions_types","utilOptions","negativeClasses","_utilOptions_modifiers","_ref16","_context_tailwindConfig_theme_opacity","metadata","includeMetadata","_utilOptions_values","getVariants","isArbitrary","hasDash","clone","toString","_context_variantMap_get","_ref17","_","formatStrings","localFormatStrings","_options_values_value","modifierFunction","getClassNameFromSelector","wrapper","ruleWithVariant","manualFormatStrings","after","modified","rebuiltBase","processSync","atrule","isArbitraryVariant","formats","finalizeSelector","formatVariantSelector","markInvalidUtilityCandidate","classCache","notClassCache","delete","applyClassCache","candidateRuleCache","stylesheetCache","markInvalidUtilityNode","entry","ruleCache","_tailwindConfig_blocklist","disposables","blocklist","postCssNodeCache","resolvedPlugins","contextMap","configContextMap","contextSourcesMap","userConfigPath","tailwindConfigHash","contextDependencies","sourcePath","from","isConfigFile","env","DEBUG","console","log","existingContext","cssDidChange","hasContentChanged","contextDependenciesChanged","oldContext","size","disposable"],"sources":["/Users/manan/Desktop/hach-unicorn/StockSure/frontend1/node_modules/tailwindcss/lib/lib/setupContextUtils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isValidVariantFormatString: function() {\n        return isValidVariantFormatString;\n    },\n    parseVariant: function() {\n        return parseVariant;\n    },\n    getFileModifiedMap: function() {\n        return getFileModifiedMap;\n    },\n    createContext: function() {\n        return createContext;\n    },\n    getContext: function() {\n        return getContext;\n    }\n});\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _url = /*#__PURE__*/ _interop_require_default(require(\"url\"));\nconst _postcss = /*#__PURE__*/ _interop_require_default(require(\"postcss\"));\nconst _dlv = /*#__PURE__*/ _interop_require_default(require(\"dlv\"));\nconst _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser\"));\nconst _transformThemeValue = /*#__PURE__*/ _interop_require_default(require(\"../util/transformThemeValue\"));\nconst _parseObjectStyles = /*#__PURE__*/ _interop_require_default(require(\"../util/parseObjectStyles\"));\nconst _prefixSelector = /*#__PURE__*/ _interop_require_default(require(\"../util/prefixSelector\"));\nconst _isPlainObject = /*#__PURE__*/ _interop_require_default(require(\"../util/isPlainObject\"));\nconst _escapeClassName = /*#__PURE__*/ _interop_require_default(require(\"../util/escapeClassName\"));\nconst _nameClass = /*#__PURE__*/ _interop_require_wildcard(require(\"../util/nameClass\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _corePlugins = require(\"../corePlugins\");\nconst _sharedState = /*#__PURE__*/ _interop_require_wildcard(require(\"./sharedState\"));\nconst _toPath = require(\"../util/toPath\");\nconst _log = /*#__PURE__*/ _interop_require_default(require(\"../util/log\"));\nconst _negateValue = /*#__PURE__*/ _interop_require_default(require(\"../util/negateValue\"));\nconst _isSyntacticallyValidPropertyValue = /*#__PURE__*/ _interop_require_default(require(\"../util/isSyntacticallyValidPropertyValue\"));\nconst _generateRules = require(\"./generateRules\");\nconst _cacheInvalidation = require(\"./cacheInvalidation.js\");\nconst _offsets = require(\"./offsets.js\");\nconst _featureFlags = require(\"../featureFlags.js\");\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst VARIANT_TYPES = {\n    AddVariant: Symbol.for(\"ADD_VARIANT\"),\n    MatchVariant: Symbol.for(\"MATCH_VARIANT\")\n};\nconst VARIANT_INFO = {\n    Base: 1 << 0,\n    Dynamic: 1 << 1\n};\nfunction prefix(context, selector) {\n    let prefix = context.tailwindConfig.prefix;\n    return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction normalizeOptionTypes({ type =\"any\" , ...options }) {\n    let types = [].concat(type);\n    return {\n        ...options,\n        types: types.map((type)=>{\n            if (Array.isArray(type)) {\n                return {\n                    type: type[0],\n                    ...type[1]\n                };\n            }\n            return {\n                type,\n                preferOnConflict: false\n            };\n        })\n    };\n}\nfunction parseVariantFormatString(input) {\n    /** @type {string[]} */ let parts = [];\n    // When parsing whitespace around special characters are insignificant\n    // However, _inside_ of a variant they could be\n    // Because the selector could look like this\n    // @media { &[data-name=\"foo bar\"] }\n    // This is why we do not skip whitespace\n    let current = \"\";\n    let depth = 0;\n    for(let idx = 0; idx < input.length; idx++){\n        let char = input[idx];\n        if (char === \"\\\\\") {\n            // Escaped characters are not special\n            current += \"\\\\\" + input[++idx];\n        } else if (char === \"{\") {\n            // Nested rule: start\n            ++depth;\n            parts.push(current.trim());\n            current = \"\";\n        } else if (char === \"}\") {\n            // Nested rule: end\n            if (--depth < 0) {\n                throw new Error(`Your { and } are unbalanced.`);\n            }\n            parts.push(current.trim());\n            current = \"\";\n        } else {\n            // Normal character\n            current += char;\n        }\n    }\n    if (current.length > 0) {\n        parts.push(current.trim());\n    }\n    parts = parts.filter((part)=>part !== \"\");\n    return parts;\n}\nfunction insertInto(list, value, { before =[]  } = {}) {\n    before = [].concat(before);\n    if (before.length <= 0) {\n        list.push(value);\n        return;\n    }\n    let idx = list.length - 1;\n    for (let other of before){\n        let iidx = list.indexOf(other);\n        if (iidx === -1) continue;\n        idx = Math.min(idx, iidx);\n    }\n    list.splice(idx, 0, value);\n}\nfunction parseStyles(styles) {\n    if (!Array.isArray(styles)) {\n        return parseStyles([\n            styles\n        ]);\n    }\n    return styles.flatMap((style)=>{\n        let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);\n        return isNode ? style : (0, _parseObjectStyles.default)(style);\n    });\n}\nfunction getClasses(selector, mutate) {\n    let parser = (0, _postcssselectorparser.default)((selectors)=>{\n        let allClasses = [];\n        if (mutate) {\n            mutate(selectors);\n        }\n        selectors.walkClasses((classNode)=>{\n            allClasses.push(classNode.value);\n        });\n        return allClasses;\n    });\n    return parser.transformSync(selector);\n}\nfunction extractCandidates(node, state = {\n    containsNonOnDemandable: false\n}, depth = 0) {\n    let classes = [];\n    // Handle normal rules\n    if (node.type === \"rule\") {\n        // Ignore everything inside a :not(...). This allows you to write code like\n        // `div:not(.foo)`. If `.foo` is never found in your code, then we used to\n        // not generated it. But now we will ignore everything inside a `:not`, so\n        // that it still gets generated.\n        function ignoreNot(selectors) {\n            selectors.walkPseudos((pseudo)=>{\n                if (pseudo.value === \":not\") {\n                    pseudo.remove();\n                }\n            });\n        }\n        for (let selector of node.selectors){\n            let classCandidates = getClasses(selector, ignoreNot);\n            // At least one of the selectors contains non-\"on-demandable\" candidates.\n            if (classCandidates.length === 0) {\n                state.containsNonOnDemandable = true;\n            }\n            for (let classCandidate of classCandidates){\n                classes.push(classCandidate);\n            }\n        }\n    } else if (node.type === \"atrule\") {\n        node.walkRules((rule)=>{\n            for (let classCandidate of rule.selectors.flatMap((selector)=>getClasses(selector))){\n                classes.push(classCandidate);\n            }\n        });\n    }\n    if (depth === 0) {\n        return [\n            state.containsNonOnDemandable || classes.length === 0,\n            classes\n        ];\n    }\n    return classes;\n}\nfunction withIdentifiers(styles) {\n    return parseStyles(styles).flatMap((node)=>{\n        let nodeMap = new Map();\n        let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);\n        // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n        if (containsNonOnDemandableSelectors) {\n            candidates.unshift(_sharedState.NOT_ON_DEMAND);\n        }\n        // However, it could be that it also contains \"on-demandable\" candidates.\n        // E.g.: `span, .foo {}`, in that case it should still be possible to use\n        // `@apply foo` for example.\n        return candidates.map((c)=>{\n            if (!nodeMap.has(node)) {\n                nodeMap.set(node, node);\n            }\n            return [\n                c,\n                nodeMap.get(node)\n            ];\n        });\n    });\n}\nfunction isValidVariantFormatString(format) {\n    return format.startsWith(\"@\") || format.includes(\"&\");\n}\nfunction parseVariant(variant) {\n    variant = variant.replace(/\\n+/g, \"\").replace(/\\s{1,}/g, \" \").trim();\n    let fns = parseVariantFormatString(variant).map((str)=>{\n        if (!str.startsWith(\"@\")) {\n            return ({ format  })=>format(str);\n        }\n        let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str);\n        return ({ wrap  })=>wrap(_postcss.default.atRule({\n                name,\n                params: params.trim()\n            }));\n    }).reverse();\n    return (api)=>{\n        for (let fn of fns){\n            fn(api);\n        }\n    };\n}\n/**\n *\n * @param {any} tailwindConfig\n * @param {any} context\n * @param {object} param2\n * @param {Offsets} param2.offsets\n */ function buildPluginApi(tailwindConfig, context, { variantList , variantMap , offsets , classList  }) {\n    function getConfigValue(path, defaultValue) {\n        return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;\n    }\n    function applyConfiguredPrefix(selector) {\n        return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);\n    }\n    function prefixIdentifier(identifier, options) {\n        if (identifier === _sharedState.NOT_ON_DEMAND) {\n            return _sharedState.NOT_ON_DEMAND;\n        }\n        if (!options.respectPrefix) {\n            return identifier;\n        }\n        return context.tailwindConfig.prefix + identifier;\n    }\n    function resolveThemeValue(path, defaultValue, opts = {}) {\n        let parts = (0, _toPath.toPath)(path);\n        let value = getConfigValue([\n            \"theme\",\n            ...parts\n        ], defaultValue);\n        return (0, _transformThemeValue.default)(parts[0])(value, opts);\n    }\n    let variantIdentifier = 0;\n    let api = {\n        postcss: _postcss.default,\n        prefix: applyConfiguredPrefix,\n        e: _escapeClassName.default,\n        config: getConfigValue,\n        theme: resolveThemeValue,\n        corePlugins: (path)=>{\n            if (Array.isArray(tailwindConfig.corePlugins)) {\n                return tailwindConfig.corePlugins.includes(path);\n            }\n            return getConfigValue([\n                \"corePlugins\",\n                path\n            ], true);\n        },\n        variants: ()=>{\n            // Preserved for backwards compatibility but not used in v3.0+\n            return [];\n        },\n        addBase (base) {\n            for (let [identifier, rule] of withIdentifiers(base)){\n                let prefixedIdentifier = prefixIdentifier(identifier, {});\n                let offset = offsets.create(\"base\");\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offset,\n                        layer: \"base\"\n                    },\n                    rule\n                ]);\n            }\n        },\n        /**\n     * @param {string} group\n     * @param {Record<string, string | string[]>} declarations\n     */ addDefaults (group, declarations) {\n            const groups = {\n                [`@defaults ${group}`]: declarations\n            };\n            for (let [identifier, rule] of withIdentifiers(groups)){\n                let prefixedIdentifier = prefixIdentifier(identifier, {});\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"defaults\"),\n                        layer: \"defaults\"\n                    },\n                    rule\n                ]);\n            }\n        },\n        addComponents (components, options) {\n            let defaultOptions = {\n                preserveSource: false,\n                respectPrefix: true,\n                respectImportant: false\n            };\n            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n            for (let [identifier, rule] of withIdentifiers(components)){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                classList.add(prefixedIdentifier);\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"components\"),\n                        layer: \"components\",\n                        options\n                    },\n                    rule\n                ]);\n            }\n        },\n        addUtilities (utilities, options) {\n            let defaultOptions = {\n                preserveSource: false,\n                respectPrefix: true,\n                respectImportant: true\n            };\n            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n            for (let [identifier, rule] of withIdentifiers(utilities)){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                classList.add(prefixedIdentifier);\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"utilities\"),\n                        layer: \"utilities\",\n                        options\n                    },\n                    rule\n                ]);\n            }\n        },\n        matchUtilities: function(utilities, options) {\n            let defaultOptions = {\n                respectPrefix: true,\n                respectImportant: true,\n                modifiers: false\n            };\n            options = normalizeOptionTypes({\n                ...defaultOptions,\n                ...options\n            });\n            let offset = offsets.create(\"utilities\");\n            for(let identifier in utilities){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                let rule = utilities[identifier];\n                classList.add([\n                    prefixedIdentifier,\n                    options\n                ]);\n                function wrapped(modifier, { isOnlyPlugin  }) {\n                    let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n                    if (value === undefined) {\n                        return [];\n                    }\n                    if (!options.types.some(({ type  })=>type === coercedType)) {\n                        if (isOnlyPlugin) {\n                            _log.default.warn([\n                                `Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,\n                                `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`\n                            ]);\n                        } else {\n                            return [];\n                        }\n                    }\n                    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n                        return [];\n                    }\n                    let extras = {\n                        get modifier () {\n                            if (!options.modifiers) {\n                                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\n                                    \"Your plugin must set `modifiers: true` in its options to support modifiers.\"\n                                ]);\n                            }\n                            return utilityModifier;\n                        }\n                    };\n                    let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n                    let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration)=>({\n                            [(0, _nameClass.default)(identifier, modifier)]: declaration\n                        }));\n                    return ruleSets;\n                }\n                let withOffsets = [\n                    {\n                        sort: offset,\n                        layer: \"utilities\",\n                        options\n                    },\n                    wrapped\n                ];\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n            }\n        },\n        matchComponents: function(components, options) {\n            let defaultOptions = {\n                respectPrefix: true,\n                respectImportant: false,\n                modifiers: false\n            };\n            options = normalizeOptionTypes({\n                ...defaultOptions,\n                ...options\n            });\n            let offset = offsets.create(\"components\");\n            for(let identifier in components){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                let rule = components[identifier];\n                classList.add([\n                    prefixedIdentifier,\n                    options\n                ]);\n                function wrapped(modifier, { isOnlyPlugin  }) {\n                    let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n                    if (value === undefined) {\n                        return [];\n                    }\n                    if (!options.types.some(({ type  })=>type === coercedType)) {\n                        if (isOnlyPlugin) {\n                            _log.default.warn([\n                                `Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,\n                                `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`\n                            ]);\n                        } else {\n                            return [];\n                        }\n                    }\n                    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n                        return [];\n                    }\n                    let extras = {\n                        get modifier () {\n                            if (!options.modifiers) {\n                                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\n                                    \"Your plugin must set `modifiers: true` in its options to support modifiers.\"\n                                ]);\n                            }\n                            return utilityModifier;\n                        }\n                    };\n                    let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n                    let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration)=>({\n                            [(0, _nameClass.default)(identifier, modifier)]: declaration\n                        }));\n                    return ruleSets;\n                }\n                let withOffsets = [\n                    {\n                        sort: offset,\n                        layer: \"components\",\n                        options\n                    },\n                    wrapped\n                ];\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n            }\n        },\n        addVariant (variantName, variantFunctions, options = {}) {\n            variantFunctions = [].concat(variantFunctions).map((variantFunction)=>{\n                if (typeof variantFunction !== \"string\") {\n                    // Safelist public API functions\n                    return (api = {})=>{\n                        let { args , modifySelectors , container , separator , wrap , format  } = api;\n                        let result = variantFunction(Object.assign({\n                            modifySelectors,\n                            container,\n                            separator\n                        }, options.type === VARIANT_TYPES.MatchVariant && {\n                            args,\n                            wrap,\n                            format\n                        }));\n                        if (typeof result === \"string\" && !isValidVariantFormatString(result)) {\n                            throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n                        }\n                        if (Array.isArray(result)) {\n                            return result.filter((variant)=>typeof variant === \"string\").map((variant)=>parseVariant(variant));\n                        }\n                        // result may be undefined with legacy variants that use APIs like `modifySelectors`\n                        // result may also be a postcss node if someone was returning the result from `modifySelectors`\n                        return result && typeof result === \"string\" && parseVariant(result)(api);\n                    };\n                }\n                if (!isValidVariantFormatString(variantFunction)) {\n                    throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n                }\n                return parseVariant(variantFunction);\n            });\n            insertInto(variantList, variantName, options);\n            variantMap.set(variantName, variantFunctions);\n            context.variantOptions.set(variantName, options);\n        },\n        matchVariant (variant, variantFn, options) {\n            var _options_id;\n            // A unique identifier that \"groups\" these variants together.\n            // This is for internal use only which is why it is not present in the types\n            let id = (_options_id = options === null || options === void 0 ? void 0 : options.id) !== null && _options_id !== void 0 ? _options_id : ++variantIdentifier;\n            let isSpecial = variant === \"@\";\n            let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n            var _options_values;\n            for (let [key, value] of Object.entries((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {})){\n                if (key === \"DEFAULT\") continue;\n                api.addVariant(isSpecial ? `${variant}${key}` : `${variant}-${key}`, ({ args , container  })=>{\n                    return variantFn(value, modifiersEnabled ? {\n                        modifier: args === null || args === void 0 ? void 0 : args.modifier,\n                        container\n                    } : {\n                        container\n                    });\n                }, {\n                    ...options,\n                    value,\n                    id,\n                    type: VARIANT_TYPES.MatchVariant,\n                    variantInfo: VARIANT_INFO.Base\n                });\n            }\n            var _options_values1;\n            let hasDefault = \"DEFAULT\" in ((_options_values1 = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {});\n            api.addVariant(variant, ({ args , container  })=>{\n                if ((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE && !hasDefault) {\n                    return null;\n                }\n                var // (JetBrains) plugins.\n                _args_value;\n                return variantFn((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE ? options.values.DEFAULT : (_args_value = args === null || args === void 0 ? void 0 : args.value) !== null && _args_value !== void 0 ? _args_value : typeof args === \"string\" ? args : \"\", modifiersEnabled ? {\n                    modifier: args === null || args === void 0 ? void 0 : args.modifier,\n                    container\n                } : {\n                    container\n                });\n            }, {\n                ...options,\n                id,\n                type: VARIANT_TYPES.MatchVariant,\n                variantInfo: VARIANT_INFO.Dynamic\n            });\n        }\n    };\n    return api;\n}\nlet fileModifiedMapCache = new WeakMap();\nfunction getFileModifiedMap(context) {\n    if (!fileModifiedMapCache.has(context)) {\n        fileModifiedMapCache.set(context, new Map());\n    }\n    return fileModifiedMapCache.get(context);\n}\nfunction trackModified(files, fileModifiedMap) {\n    let changed = false;\n    let mtimesToCommit = new Map();\n    for (let file of files){\n        var _fs_statSync;\n        if (!file) continue;\n        let parsed = _url.default.parse(file);\n        let pathname = parsed.hash ? parsed.href.replace(parsed.hash, \"\") : parsed.href;\n        pathname = parsed.search ? pathname.replace(parsed.search, \"\") : pathname;\n        let newModified = (_fs_statSync = _fs.default.statSync(decodeURIComponent(pathname), {\n            throwIfNoEntry: false\n        })) === null || _fs_statSync === void 0 ? void 0 : _fs_statSync.mtimeMs;\n        if (!newModified) {\n            continue;\n        }\n        if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n            changed = true;\n        }\n        mtimesToCommit.set(file, newModified);\n    }\n    return [\n        changed,\n        mtimesToCommit\n    ];\n}\nfunction extractVariantAtRules(node) {\n    node.walkAtRules((atRule)=>{\n        if ([\n            \"responsive\",\n            \"variants\"\n        ].includes(atRule.name)) {\n            extractVariantAtRules(atRule);\n            atRule.before(atRule.nodes);\n            atRule.remove();\n        }\n    });\n}\nfunction collectLayerPlugins(root) {\n    let layerPlugins = [];\n    root.each((node)=>{\n        if (node.type === \"atrule\" && [\n            \"responsive\",\n            \"variants\"\n        ].includes(node.name)) {\n            node.name = \"layer\";\n            node.params = \"utilities\";\n        }\n    });\n    // Walk @layer rules and treat them like plugins\n    root.walkAtRules(\"layer\", (layerRule)=>{\n        extractVariantAtRules(layerRule);\n        if (layerRule.params === \"base\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addBase  }) {\n                    addBase(node, {\n                        respectPrefix: false\n                    });\n                });\n            }\n            layerRule.remove();\n        } else if (layerRule.params === \"components\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addComponents  }) {\n                    addComponents(node, {\n                        respectPrefix: false,\n                        preserveSource: true\n                    });\n                });\n            }\n            layerRule.remove();\n        } else if (layerRule.params === \"utilities\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addUtilities  }) {\n                    addUtilities(node, {\n                        respectPrefix: false,\n                        preserveSource: true\n                    });\n                });\n            }\n            layerRule.remove();\n        }\n    });\n    return layerPlugins;\n}\nfunction resolvePlugins(context, root) {\n    let corePluginList = Object.entries({\n        ..._corePlugins.variantPlugins,\n        ..._corePlugins.corePlugins\n    }).map(([name, plugin])=>{\n        if (!context.tailwindConfig.corePlugins.includes(name)) {\n            return null;\n        }\n        return plugin;\n    }).filter(Boolean);\n    let userPlugins = context.tailwindConfig.plugins.map((plugin)=>{\n        if (plugin.__isOptionsFunction) {\n            plugin = plugin();\n        }\n        return typeof plugin === \"function\" ? plugin : plugin.handler;\n    });\n    let layerPlugins = collectLayerPlugins(root);\n    // TODO: This is a workaround for backwards compatibility, since custom variants\n    // were historically sorted before screen/stackable variants.\n    let beforeVariants = [\n        _corePlugins.variantPlugins[\"pseudoElementVariants\"],\n        _corePlugins.variantPlugins[\"pseudoClassVariants\"],\n        _corePlugins.variantPlugins[\"ariaVariants\"],\n        _corePlugins.variantPlugins[\"dataVariants\"]\n    ];\n    let afterVariants = [\n        _corePlugins.variantPlugins[\"supportsVariants\"],\n        _corePlugins.variantPlugins[\"directionVariants\"],\n        _corePlugins.variantPlugins[\"reducedMotionVariants\"],\n        _corePlugins.variantPlugins[\"prefersContrastVariants\"],\n        _corePlugins.variantPlugins[\"darkVariants\"],\n        _corePlugins.variantPlugins[\"printVariant\"],\n        _corePlugins.variantPlugins[\"screenVariants\"],\n        _corePlugins.variantPlugins[\"orientationVariants\"]\n    ];\n    return [\n        ...corePluginList,\n        ...beforeVariants,\n        ...userPlugins,\n        ...afterVariants,\n        ...layerPlugins\n    ];\n}\nfunction registerPlugins(plugins, context) {\n    let variantList = [];\n    let variantMap = new Map();\n    context.variantMap = variantMap;\n    let offsets = new _offsets.Offsets();\n    context.offsets = offsets;\n    let classList = new Set();\n    let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n        variantList,\n        variantMap,\n        offsets,\n        classList\n    });\n    for (let plugin of plugins){\n        if (Array.isArray(plugin)) {\n            for (let pluginItem of plugin){\n                pluginItem(pluginApi);\n            }\n        } else {\n            plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);\n        }\n    }\n    // Make sure to record bit masks for every variant\n    offsets.recordVariants(variantList, (variant)=>variantMap.get(variant).length);\n    // Build variantMap\n    for (let [variantName, variantFunctions] of variantMap.entries()){\n        context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx)=>[\n                offsets.forVariant(variantName, idx),\n                variantFunction\n            ]));\n    }\n    var _context_tailwindConfig_safelist;\n    let safelist = ((_context_tailwindConfig_safelist = context.tailwindConfig.safelist) !== null && _context_tailwindConfig_safelist !== void 0 ? _context_tailwindConfig_safelist : []).filter(Boolean);\n    if (safelist.length > 0) {\n        let checks = [];\n        for (let value of safelist){\n            if (typeof value === \"string\") {\n                context.changedContent.push({\n                    content: value,\n                    extension: \"html\"\n                });\n                continue;\n            }\n            if (value instanceof RegExp) {\n                _log.default.warn(\"root-regex\", [\n                    \"Regular expressions in `safelist` work differently in Tailwind CSS v3.0.\",\n                    \"Update your `safelist` configuration to eliminate this warning.\",\n                    \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"\n                ]);\n                continue;\n            }\n            checks.push(value);\n        }\n        if (checks.length > 0) {\n            let patternMatchingCount = new Map();\n            let prefixLength = context.tailwindConfig.prefix.length;\n            let checkImportantUtils = checks.some((check)=>check.pattern.source.includes(\"!\"));\n            for (let util of classList){\n                let utils = Array.isArray(util) ? (()=>{\n                    let [utilName, options] = util;\n                    var _options_values;\n                    let values = Object.keys((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {});\n                    let classes = values.map((value)=>(0, _nameClass.formatClass)(utilName, value));\n                    if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {\n                        // This is the normal negated version\n                        // e.g. `-inset-1` or `-tw-inset-1`\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>\"-\" + cls)\n                        ];\n                        // This is the negated version *after* the prefix\n                        // e.g. `tw--inset-1`\n                        // The prefix is already attached to util name\n                        // So we add the negative after the prefix\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>cls.slice(0, prefixLength) + \"-\" + cls.slice(prefixLength))\n                        ];\n                    }\n                    if (options.types.some(({ type  })=>type === \"color\")) {\n                        classes = [\n                            ...classes,\n                            ...classes.flatMap((cls)=>Object.keys(context.tailwindConfig.theme.opacity).map((opacity)=>`${cls}/${opacity}`))\n                        ];\n                    }\n                    if (checkImportantUtils && (options === null || options === void 0 ? void 0 : options.respectImportant)) {\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>\"!\" + cls)\n                        ];\n                    }\n                    return classes;\n                })() : [\n                    util\n                ];\n                for (let util of utils){\n                    for (let { pattern , variants =[]  } of checks){\n                        // RegExp with the /g flag are stateful, so let's reset the last\n                        // index pointer to reset the state.\n                        pattern.lastIndex = 0;\n                        if (!patternMatchingCount.has(pattern)) {\n                            patternMatchingCount.set(pattern, 0);\n                        }\n                        if (!pattern.test(util)) continue;\n                        patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);\n                        context.changedContent.push({\n                            content: util,\n                            extension: \"html\"\n                        });\n                        for (let variant of variants){\n                            context.changedContent.push({\n                                content: variant + context.tailwindConfig.separator + util,\n                                extension: \"html\"\n                            });\n                        }\n                    }\n                }\n            }\n            for (let [regex, count] of patternMatchingCount.entries()){\n                if (count !== 0) continue;\n                _log.default.warn([\n                    `The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`,\n                    \"Fix this pattern or remove it from your `safelist` configuration.\",\n                    \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"\n                ]);\n            }\n        }\n    }\n    var _context_tailwindConfig_darkMode, _concat_;\n    let darkClassName = (_concat_ = [].concat((_context_tailwindConfig_darkMode = context.tailwindConfig.darkMode) !== null && _context_tailwindConfig_darkMode !== void 0 ? _context_tailwindConfig_darkMode : \"media\")[1]) !== null && _concat_ !== void 0 ? _concat_ : \"dark\";\n    // A list of utilities that are used by certain Tailwind CSS utilities but\n    // that don't exist on their own. This will result in them \"not existing\" and\n    // sorting could be weird since you still require them in order to make the\n    // host utilities work properly. (Thanks Biology)\n    let parasiteUtilities = [\n        prefix(context, darkClassName),\n        prefix(context, \"group\"),\n        prefix(context, \"peer\")\n    ];\n    context.getClassOrder = function getClassOrder(classes) {\n        // Sort classes so they're ordered in a deterministic manner\n        let sorted = [\n            ...classes\n        ].sort((a, z)=>{\n            if (a === z) return 0;\n            if (a < z) return -1;\n            return 1;\n        });\n        // Non-util classes won't be generated, so we default them to null\n        let sortedClassNames = new Map(sorted.map((className)=>[\n                className,\n                null\n            ]));\n        // Sort all classes in order\n        // Non-tailwind classes won't be generated and will be left as `null`\n        let rules = (0, _generateRules.generateRules)(new Set(sorted), context);\n        rules = context.offsets.sort(rules);\n        let idx = BigInt(parasiteUtilities.length);\n        for (const [, rule] of rules){\n            sortedClassNames.set(rule.raws.tailwind.candidate, idx++);\n        }\n        return classes.map((className)=>{\n            var _sortedClassNames_get;\n            let order = (_sortedClassNames_get = sortedClassNames.get(className)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : null;\n            let parasiteIndex = parasiteUtilities.indexOf(className);\n            if (order === null && parasiteIndex !== -1) {\n                // This will make sure that it is at the very beginning of the\n                // `components` layer which technically means 'before any\n                // components'.\n                order = BigInt(parasiteIndex);\n            }\n            return [\n                className,\n                order\n            ];\n        });\n    };\n    // Generate a list of strings for autocompletion purposes, e.g.\n    // ['uppercase', 'lowercase', ...]\n    context.getClassList = function getClassList(options = {}) {\n        let output = [];\n        for (let util of classList){\n            if (Array.isArray(util)) {\n                var _utilOptions_types;\n                let [utilName, utilOptions] = util;\n                let negativeClasses = [];\n                var _utilOptions_modifiers;\n                let modifiers = Object.keys((_utilOptions_modifiers = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.modifiers) !== null && _utilOptions_modifiers !== void 0 ? _utilOptions_modifiers : {});\n                if (utilOptions === null || utilOptions === void 0 ? void 0 : (_utilOptions_types = utilOptions.types) === null || _utilOptions_types === void 0 ? void 0 : _utilOptions_types.some(({ type  })=>type === \"color\")) {\n                    var _context_tailwindConfig_theme_opacity;\n                    modifiers.push(...Object.keys((_context_tailwindConfig_theme_opacity = context.tailwindConfig.theme.opacity) !== null && _context_tailwindConfig_theme_opacity !== void 0 ? _context_tailwindConfig_theme_opacity : {}));\n                }\n                let metadata = {\n                    modifiers\n                };\n                let includeMetadata = options.includeMetadata && modifiers.length > 0;\n                var _utilOptions_values;\n                for (let [key, value] of Object.entries((_utilOptions_values = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.values) !== null && _utilOptions_values !== void 0 ? _utilOptions_values : {})){\n                    // Ignore undefined and null values\n                    if (value == null) {\n                        continue;\n                    }\n                    let cls = (0, _nameClass.formatClass)(utilName, key);\n                    output.push(includeMetadata ? [\n                        cls,\n                        metadata\n                    ] : cls);\n                    if ((utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.supportsNegativeValues) && (0, _negateValue.default)(value)) {\n                        let cls = (0, _nameClass.formatClass)(utilName, `-${key}`);\n                        negativeClasses.push(includeMetadata ? [\n                            cls,\n                            metadata\n                        ] : cls);\n                    }\n                }\n                output.push(...negativeClasses);\n            } else {\n                output.push(util);\n            }\n        }\n        return output;\n    };\n    // Generate a list of available variants with meta information of the type of variant.\n    context.getVariants = function getVariants() {\n        let result = [];\n        for (let [name, options] of context.variantOptions.entries()){\n            if (options.variantInfo === VARIANT_INFO.Base) continue;\n            var _options_values;\n            result.push({\n                name,\n                isArbitrary: options.type === Symbol.for(\"MATCH_VARIANT\"),\n                values: Object.keys((_options_values = options.values) !== null && _options_values !== void 0 ? _options_values : {}),\n                hasDash: name !== \"@\",\n                selectors ({ modifier , value  } = {}) {\n                    let candidate = \"__TAILWIND_PLACEHOLDER__\";\n                    let rule = _postcss.default.rule({\n                        selector: `.${candidate}`\n                    });\n                    let container = _postcss.default.root({\n                        nodes: [\n                            rule.clone()\n                        ]\n                    });\n                    let before = container.toString();\n                    var _context_variantMap_get;\n                    let fns = ((_context_variantMap_get = context.variantMap.get(name)) !== null && _context_variantMap_get !== void 0 ? _context_variantMap_get : []).flatMap(([_, fn])=>fn);\n                    let formatStrings = [];\n                    for (let fn of fns){\n                        var _options_values;\n                        let localFormatStrings = [];\n                        var _options_values_value;\n                        let api = {\n                            args: {\n                                modifier,\n                                value: (_options_values_value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[value]) !== null && _options_values_value !== void 0 ? _options_values_value : value\n                            },\n                            separator: context.tailwindConfig.separator,\n                            modifySelectors (modifierFunction) {\n                                // Run the modifierFunction over each rule\n                                container.each((rule)=>{\n                                    if (rule.type !== \"rule\") {\n                                        return;\n                                    }\n                                    rule.selectors = rule.selectors.map((selector)=>{\n                                        return modifierFunction({\n                                            get className () {\n                                                return (0, _generateRules.getClassNameFromSelector)(selector);\n                                            },\n                                            selector\n                                        });\n                                    });\n                                });\n                                return container;\n                            },\n                            format (str) {\n                                localFormatStrings.push(str);\n                            },\n                            wrap (wrapper) {\n                                localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);\n                            },\n                            container\n                        };\n                        let ruleWithVariant = fn(api);\n                        if (localFormatStrings.length > 0) {\n                            formatStrings.push(localFormatStrings);\n                        }\n                        if (Array.isArray(ruleWithVariant)) {\n                            for (let variantFunction of ruleWithVariant){\n                                localFormatStrings = [];\n                                variantFunction(api);\n                                formatStrings.push(localFormatStrings);\n                            }\n                        }\n                    }\n                    // Reverse engineer the result of the `container`\n                    let manualFormatStrings = [];\n                    let after = container.toString();\n                    if (before !== after) {\n                        // Figure out all selectors\n                        container.walkRules((rule)=>{\n                            let modified = rule.selector;\n                            // Rebuild the base selector, this is what plugin authors would do\n                            // as well. E.g.: `${variant}${separator}${className}`.\n                            // However, plugin authors probably also prepend or append certain\n                            // classes, pseudos, ids, ...\n                            let rebuiltBase = (0, _postcssselectorparser.default)((selectors)=>{\n                                selectors.walkClasses((classNode)=>{\n                                    classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;\n                                });\n                            }).processSync(modified);\n                            // Now that we know the original selector, the new selector, and\n                            // the rebuild part in between, we can replace the part that plugin\n                            // authors need to rebuild with `&`, and eventually store it in the\n                            // collectedFormats. Similar to what `format('...')` would do.\n                            //\n                            // E.g.:\n                            //                   variant: foo\n                            //                  selector: .markdown > p\n                            //      modified (by plugin): .foo .foo\\\\:markdown > p\n                            //    rebuiltBase (internal): .foo\\\\:markdown > p\n                            //                    format: .foo &\n                            manualFormatStrings.push(modified.replace(rebuiltBase, \"&\").replace(candidate, \"&\"));\n                        });\n                        // Figure out all atrules\n                        container.walkAtRules((atrule)=>{\n                            manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);\n                        });\n                    }\n                    var _options_values1;\n                    let isArbitraryVariant = !(value in ((_options_values1 = options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {}));\n                    formatStrings = formatStrings.map((format)=>format.map((str)=>({\n                                format: str,\n                                isArbitraryVariant\n                            })));\n                    manualFormatStrings = manualFormatStrings.map((format)=>({\n                            format,\n                            isArbitraryVariant\n                        }));\n                    let opts = {\n                        candidate,\n                        context\n                    };\n                    let result = formatStrings.map((formats)=>(0, _formatVariantSelector.finalizeSelector)(`.${candidate}`, (0, _formatVariantSelector.formatVariantSelector)(formats, opts), opts).replace(`.${candidate}`, \"&\").replace(\"{ & }\", \"\").trim());\n                    if (manualFormatStrings.length > 0) {\n                        result.push((0, _formatVariantSelector.formatVariantSelector)(manualFormatStrings, opts).toString().replace(`.${candidate}`, \"&\"));\n                    }\n                    return result;\n                }\n            });\n        }\n        return result;\n    };\n}\n/**\n * Mark as class as retroactively invalid\n *\n *\n * @param {string} candidate\n */ function markInvalidUtilityCandidate(context, candidate) {\n    if (!context.classCache.has(candidate)) {\n        return;\n    }\n    // Mark this as not being a real utility\n    context.notClassCache.add(candidate);\n    // Remove it from any candidate-specific caches\n    context.classCache.delete(candidate);\n    context.applyClassCache.delete(candidate);\n    context.candidateRuleMap.delete(candidate);\n    context.candidateRuleCache.delete(candidate);\n    // Ensure the stylesheet gets rebuilt\n    context.stylesheetCache = null;\n}\n/**\n * Mark as class as retroactively invalid\n *\n * @param {import('postcss').Node} node\n */ function markInvalidUtilityNode(context, node) {\n    let candidate = node.raws.tailwind.candidate;\n    if (!candidate) {\n        return;\n    }\n    for (const entry of context.ruleCache){\n        if (entry[1].raws.tailwind.candidate === candidate) {\n            context.ruleCache.delete(entry);\n        // context.postCssNodeCache.delete(node)\n        }\n    }\n    markInvalidUtilityCandidate(context, candidate);\n}\nfunction createContext(tailwindConfig, changedContent = [], root = _postcss.default.root()) {\n    var _tailwindConfig_blocklist;\n    let context = {\n        disposables: [],\n        ruleCache: new Set(),\n        candidateRuleCache: new Map(),\n        classCache: new Map(),\n        applyClassCache: new Map(),\n        // Seed the not class cache with the blocklist (which is only strings)\n        notClassCache: new Set((_tailwindConfig_blocklist = tailwindConfig.blocklist) !== null && _tailwindConfig_blocklist !== void 0 ? _tailwindConfig_blocklist : []),\n        postCssNodeCache: new Map(),\n        candidateRuleMap: new Map(),\n        tailwindConfig,\n        changedContent: changedContent,\n        variantMap: new Map(),\n        stylesheetCache: null,\n        variantOptions: new Map(),\n        markInvalidUtilityCandidate: (candidate)=>markInvalidUtilityCandidate(context, candidate),\n        markInvalidUtilityNode: (node)=>markInvalidUtilityNode(context, node)\n    };\n    let resolvedPlugins = resolvePlugins(context, root);\n    registerPlugins(resolvedPlugins, context);\n    return context;\n}\nlet contextMap = _sharedState.contextMap;\nlet configContextMap = _sharedState.configContextMap;\nlet contextSourcesMap = _sharedState.contextSourcesMap;\nfunction getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n    let sourcePath = result.opts.from;\n    let isConfigFile = userConfigPath !== null;\n    _sharedState.env.DEBUG && console.log(\"Source path:\", sourcePath);\n    let existingContext;\n    if (isConfigFile && contextMap.has(sourcePath)) {\n        existingContext = contextMap.get(sourcePath);\n    } else if (configContextMap.has(tailwindConfigHash)) {\n        let context = configContextMap.get(tailwindConfigHash);\n        contextSourcesMap.get(context).add(sourcePath);\n        contextMap.set(sourcePath, context);\n        existingContext = context;\n    }\n    let cssDidChange = (0, _cacheInvalidation.hasContentChanged)(sourcePath, root);\n    // If there's already a context in the cache and we don't need to\n    // reset the context, return the cached context.\n    if (existingContext) {\n        let [contextDependenciesChanged, mtimesToCommit] = trackModified([\n            ...contextDependencies\n        ], getFileModifiedMap(existingContext));\n        if (!contextDependenciesChanged && !cssDidChange) {\n            return [\n                existingContext,\n                false,\n                mtimesToCommit\n            ];\n        }\n    }\n    // If this source is in the context map, get the old context.\n    // Remove this source from the context sources for the old context,\n    // and clean up that context if no one else is using it. This can be\n    // called by many processes in rapid succession, so we check for presence\n    // first because the first process to run this code will wipe it out first.\n    if (contextMap.has(sourcePath)) {\n        let oldContext = contextMap.get(sourcePath);\n        if (contextSourcesMap.has(oldContext)) {\n            contextSourcesMap.get(oldContext).delete(sourcePath);\n            if (contextSourcesMap.get(oldContext).size === 0) {\n                contextSourcesMap.delete(oldContext);\n                for (let [tailwindConfigHash, context] of configContextMap){\n                    if (context === oldContext) {\n                        configContextMap.delete(tailwindConfigHash);\n                    }\n                }\n                for (let disposable of oldContext.disposables.splice(0)){\n                    disposable(oldContext);\n                }\n            }\n        }\n    }\n    _sharedState.env.DEBUG && console.log(\"Setting up new context...\");\n    let context = createContext(tailwindConfig, [], root);\n    Object.assign(context, {\n        userConfigPath\n    });\n    let [, mtimesToCommit] = trackModified([\n        ...contextDependencies\n    ], getFileModifiedMap(context));\n    // ---\n    // Update all context tracking state\n    configContextMap.set(tailwindConfigHash, context);\n    contextMap.set(sourcePath, context);\n    if (!contextSourcesMap.has(context)) {\n        contextSourcesMap.set(context, new Set());\n    }\n    contextSourcesMap.get(context).add(sourcePath);\n    return [\n        context,\n        true,\n        mtimesToCommit\n    ];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}