{"ast":null,"code":"import { ContextualKeyword } from \"../parser/tokenizer/keywords\";\nimport { TokenType as tt } from \"../parser/tokenizer/types\";\nimport elideImportEquals from \"../util/elideImportEquals\";\nimport getDeclarationInfo, { EMPTY_DECLARATION_INFO } from \"../util/getDeclarationInfo\";\nimport getImportExportSpecifierInfo from \"../util/getImportExportSpecifierInfo\";\nimport { getNonTypeIdentifiers } from \"../util/getNonTypeIdentifiers\";\nimport { removeMaybeImportAssertion } from \"../util/removeMaybeImportAssertion\";\nimport shouldElideDefaultExport from \"../util/shouldElideDefaultExport\";\nimport Transformer from \"./Transformer\";\n\n/**\n * Class for editing import statements when we are keeping the code as ESM. We still need to remove\n * type-only imports in TypeScript and Flow.\n */\nexport default class ESMImportTransformer extends Transformer {\n  constructor(tokens, nameManager, helperManager, reactHotLoaderTransformer, isTypeScriptTransformEnabled, options) {\n    super();\n    this.tokens = tokens;\n    this.nameManager = nameManager;\n    this.helperManager = helperManager;\n    this.reactHotLoaderTransformer = reactHotLoaderTransformer;\n    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;\n    ;\n    this.nonTypeIdentifiers = isTypeScriptTransformEnabled ? getNonTypeIdentifiers(tokens, options) : new Set();\n    this.declarationInfo = isTypeScriptTransformEnabled ? getDeclarationInfo(tokens) : EMPTY_DECLARATION_INFO;\n    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);\n  }\n  process() {\n    // TypeScript `import foo = require('foo');` should always just be translated to plain require.\n    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {\n      return this.processImportEquals();\n    }\n    if (this.tokens.matches4(tt._import, tt.name, tt.name, tt.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {\n      // import type T = require('T')\n      this.tokens.removeInitialToken();\n      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.\n      for (let i = 0; i < 7; i++) {\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    if (this.tokens.matches2(tt._export, tt.eq)) {\n      this.tokens.replaceToken(\"module.exports\");\n      return true;\n    }\n    if (this.tokens.matches5(tt._export, tt._import, tt.name, tt.name, tt.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._type)) {\n      // export import type T = require('T')\n      this.tokens.removeInitialToken();\n      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.\n      for (let i = 0; i < 8; i++) {\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    if (this.tokens.matches1(tt._import)) {\n      return this.processImport();\n    }\n    if (this.tokens.matches2(tt._export, tt._default)) {\n      return this.processExportDefault();\n    }\n    if (this.tokens.matches2(tt._export, tt.braceL)) {\n      return this.processNamedExports();\n    }\n    if (this.tokens.matches2(tt._export, tt.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {\n      // export type {a};\n      // export type {a as b};\n      // export type {a} from './b';\n      // export type * from './b';\n      // export type * as ns from './b';\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      if (this.tokens.matches1(tt.braceL)) {\n        while (!this.tokens.matches1(tt.braceR)) {\n          this.tokens.removeToken();\n        }\n        this.tokens.removeToken();\n      } else {\n        // *\n        this.tokens.removeToken();\n        if (this.tokens.matches1(tt._as)) {\n          // as\n          this.tokens.removeToken();\n          // ns\n          this.tokens.removeToken();\n        }\n      }\n      // Remove type re-export `... } from './T'`\n      if (this.tokens.matchesContextual(ContextualKeyword._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        removeMaybeImportAssertion(this.tokens);\n      }\n      return true;\n    }\n    return false;\n  }\n  processImportEquals() {\n    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    if (this.isTypeName(importName)) {\n      // If this name is only used as a type, elide the whole import.\n      elideImportEquals(this.tokens);\n    } else if (this.injectCreateRequireForImportRequire) {\n      // We're using require in an environment (Node ESM) that doesn't provide\n      // it as a global, so generate a helper to import it.\n      // import -> const\n      this.tokens.replaceToken(\"const\");\n      // Foo\n      this.tokens.copyToken();\n      // =\n      this.tokens.copyToken();\n      // require\n      this.tokens.replaceToken(this.helperManager.getHelperName(\"require\"));\n    } else {\n      // Otherwise, just switch `import` to `const`.\n      this.tokens.replaceToken(\"const\");\n    }\n    return true;\n  }\n  processImport() {\n    if (this.tokens.matches2(tt._import, tt.parenL)) {\n      // Dynamic imports don't need to be transformed.\n      return false;\n    }\n    const snapshot = this.tokens.snapshot();\n    const allImportsRemoved = this.removeImportTypeBindings();\n    if (allImportsRemoved) {\n      this.tokens.restoreToSnapshot(snapshot);\n      while (!this.tokens.matches1(tt.string)) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n      removeMaybeImportAssertion(this.tokens);\n      if (this.tokens.matches1(tt.semi)) {\n        this.tokens.removeToken();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Remove type bindings from this import, leaving the rest of the import intact.\n   *\n   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out\n   * of the replacement operation, so we can return early here.\n   */\n  removeImportTypeBindings() {\n    this.tokens.copyExpectedToken(tt._import);\n    if (this.tokens.matchesContextual(ContextualKeyword._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)) {\n      // This is an \"import type\" statement, so exit early.\n      return true;\n    }\n    if (this.tokens.matches1(tt.string)) {\n      // This is a bare import, so we should proceed with the import.\n      this.tokens.copyToken();\n      return false;\n    }\n\n    // Skip the \"module\" token in import reflection.\n    if (this.tokens.matchesContextual(ContextualKeyword._module) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._from)) {\n      this.tokens.copyToken();\n    }\n    let foundNonTypeImport = false;\n    let needsComma = false;\n    if (this.tokens.matches1(tt.name)) {\n      if (this.isTypeName(this.tokens.identifierName())) {\n        this.tokens.removeToken();\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.removeToken();\n        }\n      } else {\n        foundNonTypeImport = true;\n        this.tokens.copyToken();\n        if (this.tokens.matches1(tt.comma)) {\n          // We're in a statement like:\n          // import A, * as B from './A';\n          // or\n          // import A, {foo} from './A';\n          // where the `A` is being kept. The comma should be removed if an only\n          // if the next part of the import statement is elided, but that's hard\n          // to determine at this point in the code. Instead, always remove it\n          // and set a flag to add it back if necessary.\n          needsComma = true;\n          this.tokens.removeToken();\n        }\n      }\n    }\n    if (this.tokens.matches1(tt.star)) {\n      if (this.isTypeName(this.tokens.identifierNameAtRelativeIndex(2))) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n      } else {\n        if (needsComma) {\n          this.tokens.appendCode(\",\");\n        }\n        foundNonTypeImport = true;\n        this.tokens.copyExpectedToken(tt.star);\n        this.tokens.copyExpectedToken(tt.name);\n        this.tokens.copyExpectedToken(tt.name);\n      }\n    } else if (this.tokens.matches1(tt.braceL)) {\n      if (needsComma) {\n        this.tokens.appendCode(\",\");\n      }\n      this.tokens.copyToken();\n      while (!this.tokens.matches1(tt.braceR)) {\n        const specifierInfo = getImportExportSpecifierInfo(this.tokens);\n        if (specifierInfo.isType || this.isTypeName(specifierInfo.rightName)) {\n          while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n            this.tokens.removeToken();\n          }\n          if (this.tokens.matches1(tt.comma)) {\n            this.tokens.removeToken();\n          }\n        } else {\n          foundNonTypeImport = true;\n          while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n            this.tokens.copyToken();\n          }\n          if (this.tokens.matches1(tt.comma)) {\n            this.tokens.copyToken();\n          }\n        }\n      }\n      this.tokens.copyExpectedToken(tt.braceR);\n    }\n    return !foundNonTypeImport;\n  }\n  isTypeName(name) {\n    return this.isTypeScriptTransformEnabled && !this.nonTypeIdentifiers.has(name);\n  }\n  processExportDefault() {\n    if (shouldElideDefaultExport(this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)) {\n      // If the exported value is just an identifier and should be elided by TypeScript\n      // rules, then remove it entirely. It will always have the form `export default e`,\n      // where `e` is an identifier.\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n      return true;\n    }\n    const alreadyHasName = this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||\n    // export default async function\n    this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._async) || this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) || this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name);\n    if (!alreadyHasName && this.reactHotLoaderTransformer) {\n      // This is a plain \"export default E\" statement and we need to assign E to a variable.\n      // Change \"export default E\" to \"let _default; export default _default = E\"\n      const defaultVarName = this.nameManager.claimFreeName(\"_default\");\n      this.tokens.replaceToken(`let ${defaultVarName}; export`);\n      this.tokens.copyToken();\n      this.tokens.appendCode(` ${defaultVarName} =`);\n      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * In TypeScript, we need to remove named exports that were never declared or only declared as a\n   * type.\n   */\n  processNamedExports() {\n    if (!this.isTypeScriptTransformEnabled) {\n      return false;\n    }\n    this.tokens.copyExpectedToken(tt._export);\n    this.tokens.copyExpectedToken(tt.braceL);\n    while (!this.tokens.matches1(tt.braceR)) {\n      const specifierInfo = getImportExportSpecifierInfo(this.tokens);\n      if (specifierInfo.isType || this.shouldElideExportedName(specifierInfo.leftName)) {\n        // Type export, so remove all tokens, including any comma.\n        while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n          this.tokens.removeToken();\n        }\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.removeToken();\n        }\n      } else {\n        // Non-type export, so copy all tokens, including any comma.\n        while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n          this.tokens.copyToken();\n        }\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.copyToken();\n        }\n      }\n    }\n    this.tokens.copyExpectedToken(tt.braceR);\n    return true;\n  }\n\n  /**\n   * ESM elides all imports with the rule that we only elide if we see that it's\n   * a type and never see it as a value. This is in contrast to CJS, which\n   * elides imports that are completely unknown.\n   */\n  shouldElideExportedName(name) {\n    return this.isTypeScriptTransformEnabled && this.declarationInfo.typeDeclarations.has(name) && !this.declarationInfo.valueDeclarations.has(name);\n  }\n}","map":{"version":3,"names":["ContextualKeyword","TokenType","tt","elideImportEquals","getDeclarationInfo","EMPTY_DECLARATION_INFO","getImportExportSpecifierInfo","getNonTypeIdentifiers","removeMaybeImportAssertion","shouldElideDefaultExport","Transformer","ESMImportTransformer","constructor","tokens","nameManager","helperManager","reactHotLoaderTransformer","isTypeScriptTransformEnabled","options","nonTypeIdentifiers","Set","declarationInfo","injectCreateRequireForImportRequire","Boolean","process","matches3","_import","name","eq","processImportEquals","matches4","matchesContextualAtIndex","currentIndex","_type","removeInitialToken","i","removeToken","matches2","_export","replaceToken","matches5","matches1","processImport","_default","processExportDefault","braceL","processNamedExports","braceR","_as","matchesContextual","_from","matches1AtIndex","string","importName","identifierNameAtIndex","isTypeName","copyToken","getHelperName","parenL","snapshot","allImportsRemoved","removeImportTypeBindings","restoreToSnapshot","semi","copyExpectedToken","comma","_module","foundNonTypeImport","needsComma","identifierName","star","identifierNameAtRelativeIndex","appendCode","specifierInfo","isType","rightName","endIndex","has","alreadyHasName","_function","_async","_class","_abstract","defaultVarName","claimFreeName","setExtractedDefaultExportName","shouldElideExportedName","leftName","typeDeclarations","valueDeclarations"],"sources":["/Users/manan/Desktop/hach-unicorn/StockSure/frontend1/node_modules/sucrase/dist/esm/transformers/ESMImportTransformer.js"],"sourcesContent":["\n\n\nimport {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport elideImportEquals from \"../util/elideImportEquals\";\nimport getDeclarationInfo, {\n\n  EMPTY_DECLARATION_INFO,\n} from \"../util/getDeclarationInfo\";\nimport getImportExportSpecifierInfo from \"../util/getImportExportSpecifierInfo\";\nimport {getNonTypeIdentifiers} from \"../util/getNonTypeIdentifiers\";\nimport {removeMaybeImportAssertion} from \"../util/removeMaybeImportAssertion\";\nimport shouldElideDefaultExport from \"../util/shouldElideDefaultExport\";\n\nimport Transformer from \"./Transformer\";\n\n/**\n * Class for editing import statements when we are keeping the code as ESM. We still need to remove\n * type-only imports in TypeScript and Flow.\n */\nexport default class ESMImportTransformer extends Transformer {\n  \n  \n  \n\n  constructor(\n     tokens,\n     nameManager,\n     helperManager,\n     reactHotLoaderTransformer,\n     isTypeScriptTransformEnabled,\n    options,\n  ) {\n    super();this.tokens = tokens;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;;\n    this.nonTypeIdentifiers = isTypeScriptTransformEnabled\n      ? getNonTypeIdentifiers(tokens, options)\n      : new Set();\n    this.declarationInfo = isTypeScriptTransformEnabled\n      ? getDeclarationInfo(tokens)\n      : EMPTY_DECLARATION_INFO;\n    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);\n  }\n\n  process() {\n    // TypeScript `import foo = require('foo');` should always just be translated to plain require.\n    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {\n      return this.processImportEquals();\n    }\n    if (\n      this.tokens.matches4(tt._import, tt.name, tt.name, tt.eq) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)\n    ) {\n      // import type T = require('T')\n      this.tokens.removeInitialToken();\n      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.\n      for (let i = 0; i < 7; i++) {\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    if (this.tokens.matches2(tt._export, tt.eq)) {\n      this.tokens.replaceToken(\"module.exports\");\n      return true;\n    }\n    if (\n      this.tokens.matches5(tt._export, tt._import, tt.name, tt.name, tt.eq) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._type)\n    ) {\n      // export import type T = require('T')\n      this.tokens.removeInitialToken();\n      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.\n      for (let i = 0; i < 8; i++) {\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    if (this.tokens.matches1(tt._import)) {\n      return this.processImport();\n    }\n    if (this.tokens.matches2(tt._export, tt._default)) {\n      return this.processExportDefault();\n    }\n    if (this.tokens.matches2(tt._export, tt.braceL)) {\n      return this.processNamedExports();\n    }\n    if (\n      this.tokens.matches2(tt._export, tt.name) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)\n    ) {\n      // export type {a};\n      // export type {a as b};\n      // export type {a} from './b';\n      // export type * from './b';\n      // export type * as ns from './b';\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      if (this.tokens.matches1(tt.braceL)) {\n        while (!this.tokens.matches1(tt.braceR)) {\n          this.tokens.removeToken();\n        }\n        this.tokens.removeToken();\n      } else {\n        // *\n        this.tokens.removeToken();\n        if (this.tokens.matches1(tt._as)) {\n          // as\n          this.tokens.removeToken();\n          // ns\n          this.tokens.removeToken();\n        }\n      }\n      // Remove type re-export `... } from './T'`\n      if (\n        this.tokens.matchesContextual(ContextualKeyword._from) &&\n        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)\n      ) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        removeMaybeImportAssertion(this.tokens);\n      }\n      return true;\n    }\n    return false;\n  }\n\n   processImportEquals() {\n    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    if (this.isTypeName(importName)) {\n      // If this name is only used as a type, elide the whole import.\n      elideImportEquals(this.tokens);\n    } else if (this.injectCreateRequireForImportRequire) {\n      // We're using require in an environment (Node ESM) that doesn't provide\n      // it as a global, so generate a helper to import it.\n      // import -> const\n      this.tokens.replaceToken(\"const\");\n      // Foo\n      this.tokens.copyToken();\n      // =\n      this.tokens.copyToken();\n      // require\n      this.tokens.replaceToken(this.helperManager.getHelperName(\"require\"));\n    } else {\n      // Otherwise, just switch `import` to `const`.\n      this.tokens.replaceToken(\"const\");\n    }\n    return true;\n  }\n\n   processImport() {\n    if (this.tokens.matches2(tt._import, tt.parenL)) {\n      // Dynamic imports don't need to be transformed.\n      return false;\n    }\n\n    const snapshot = this.tokens.snapshot();\n    const allImportsRemoved = this.removeImportTypeBindings();\n    if (allImportsRemoved) {\n      this.tokens.restoreToSnapshot(snapshot);\n      while (!this.tokens.matches1(tt.string)) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n      removeMaybeImportAssertion(this.tokens);\n      if (this.tokens.matches1(tt.semi)) {\n        this.tokens.removeToken();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Remove type bindings from this import, leaving the rest of the import intact.\n   *\n   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out\n   * of the replacement operation, so we can return early here.\n   */\n   removeImportTypeBindings() {\n    this.tokens.copyExpectedToken(tt._import);\n    if (\n      this.tokens.matchesContextual(ContextualKeyword._type) &&\n      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&\n      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)\n    ) {\n      // This is an \"import type\" statement, so exit early.\n      return true;\n    }\n\n    if (this.tokens.matches1(tt.string)) {\n      // This is a bare import, so we should proceed with the import.\n      this.tokens.copyToken();\n      return false;\n    }\n\n    // Skip the \"module\" token in import reflection.\n    if (\n      this.tokens.matchesContextual(ContextualKeyword._module) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._from)\n    ) {\n      this.tokens.copyToken();\n    }\n\n    let foundNonTypeImport = false;\n    let needsComma = false;\n\n    if (this.tokens.matches1(tt.name)) {\n      if (this.isTypeName(this.tokens.identifierName())) {\n        this.tokens.removeToken();\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.removeToken();\n        }\n      } else {\n        foundNonTypeImport = true;\n        this.tokens.copyToken();\n        if (this.tokens.matches1(tt.comma)) {\n          // We're in a statement like:\n          // import A, * as B from './A';\n          // or\n          // import A, {foo} from './A';\n          // where the `A` is being kept. The comma should be removed if an only\n          // if the next part of the import statement is elided, but that's hard\n          // to determine at this point in the code. Instead, always remove it\n          // and set a flag to add it back if necessary.\n          needsComma = true;\n          this.tokens.removeToken();\n        }\n      }\n    }\n\n    if (this.tokens.matches1(tt.star)) {\n      if (this.isTypeName(this.tokens.identifierNameAtRelativeIndex(2))) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n      } else {\n        if (needsComma) {\n          this.tokens.appendCode(\",\");\n        }\n        foundNonTypeImport = true;\n        this.tokens.copyExpectedToken(tt.star);\n        this.tokens.copyExpectedToken(tt.name);\n        this.tokens.copyExpectedToken(tt.name);\n      }\n    } else if (this.tokens.matches1(tt.braceL)) {\n      if (needsComma) {\n        this.tokens.appendCode(\",\");\n      }\n      this.tokens.copyToken();\n      while (!this.tokens.matches1(tt.braceR)) {\n        const specifierInfo = getImportExportSpecifierInfo(this.tokens);\n        if (specifierInfo.isType || this.isTypeName(specifierInfo.rightName)) {\n          while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n            this.tokens.removeToken();\n          }\n          if (this.tokens.matches1(tt.comma)) {\n            this.tokens.removeToken();\n          }\n        } else {\n          foundNonTypeImport = true;\n          while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n            this.tokens.copyToken();\n          }\n          if (this.tokens.matches1(tt.comma)) {\n            this.tokens.copyToken();\n          }\n        }\n      }\n      this.tokens.copyExpectedToken(tt.braceR);\n    }\n\n    return !foundNonTypeImport;\n  }\n\n   isTypeName(name) {\n    return this.isTypeScriptTransformEnabled && !this.nonTypeIdentifiers.has(name);\n  }\n\n   processExportDefault() {\n    if (\n      shouldElideDefaultExport(this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)\n    ) {\n      // If the exported value is just an identifier and should be elided by TypeScript\n      // rules, then remove it entirely. It will always have the form `export default e`,\n      // where `e` is an identifier.\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n      return true;\n    }\n\n    const alreadyHasName =\n      this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||\n      // export default async function\n      (this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) &&\n        this.tokens.matchesContextualAtIndex(\n          this.tokens.currentIndex() + 2,\n          ContextualKeyword._async,\n        )) ||\n      this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) ||\n      this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name);\n\n    if (!alreadyHasName && this.reactHotLoaderTransformer) {\n      // This is a plain \"export default E\" statement and we need to assign E to a variable.\n      // Change \"export default E\" to \"let _default; export default _default = E\"\n      const defaultVarName = this.nameManager.claimFreeName(\"_default\");\n      this.tokens.replaceToken(`let ${defaultVarName}; export`);\n      this.tokens.copyToken();\n      this.tokens.appendCode(` ${defaultVarName} =`);\n      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * In TypeScript, we need to remove named exports that were never declared or only declared as a\n   * type.\n   */\n   processNamedExports() {\n    if (!this.isTypeScriptTransformEnabled) {\n      return false;\n    }\n    this.tokens.copyExpectedToken(tt._export);\n    this.tokens.copyExpectedToken(tt.braceL);\n\n    while (!this.tokens.matches1(tt.braceR)) {\n      const specifierInfo = getImportExportSpecifierInfo(this.tokens);\n      if (specifierInfo.isType || this.shouldElideExportedName(specifierInfo.leftName)) {\n        // Type export, so remove all tokens, including any comma.\n        while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n          this.tokens.removeToken();\n        }\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.removeToken();\n        }\n      } else {\n        // Non-type export, so copy all tokens, including any comma.\n        while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n          this.tokens.copyToken();\n        }\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.copyToken();\n        }\n      }\n    }\n    this.tokens.copyExpectedToken(tt.braceR);\n    return true;\n  }\n\n  /**\n   * ESM elides all imports with the rule that we only elide if we see that it's\n   * a type and never see it as a value. This is in contrast to CJS, which\n   * elides imports that are completely unknown.\n   */\n   shouldElideExportedName(name) {\n    return (\n      this.isTypeScriptTransformEnabled &&\n      this.declarationInfo.typeDeclarations.has(name) &&\n      !this.declarationInfo.valueDeclarations.has(name)\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}