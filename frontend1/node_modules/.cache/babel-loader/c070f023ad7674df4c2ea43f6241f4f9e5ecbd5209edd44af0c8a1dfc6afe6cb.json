{"ast":null,"code":"/* eslint max-len: 0 */\n\nimport { eat, lookaheadType, lookaheadTypeAndKeyword, match, next, popTypeContext, pushTypeContext } from \"../tokenizer/index\";\nimport { ContextualKeyword } from \"../tokenizer/keywords\";\nimport { TokenType, TokenType as tt } from \"../tokenizer/types\";\nimport { input, state } from \"../traverser/base\";\nimport { baseParseMaybeAssign, baseParseSubscript, baseParseSubscripts, parseArrow, parseArrowExpression, parseCallExpressionArguments, parseExprAtom, parseExpression, parseFunctionBody, parseIdentifier, parseLiteral } from \"../traverser/expression\";\nimport { baseParseExportStar, parseExport, parseExportFrom, parseExportSpecifiers, parseFunctionParams, parseImport, parseStatement } from \"../traverser/statement\";\nimport { canInsertSemicolon, eatContextual, expect, expectContextual, isContextual, isLookaheadContextual, semicolon, unexpected } from \"../traverser/util\";\nfunction isMaybeDefaultImport(lookahead) {\n  return (lookahead.type === tt.name || !!(lookahead.type & TokenType.IS_KEYWORD)) && lookahead.contextualKeyword !== ContextualKeyword._from;\n}\nfunction flowParseTypeInitialiser(tok) {\n  const oldIsType = pushTypeContext(0);\n  expect(tok || tt.colon);\n  flowParseType();\n  popTypeContext(oldIsType);\n}\nfunction flowParsePredicate() {\n  expect(tt.modulo);\n  expectContextual(ContextualKeyword._checks);\n  if (eat(tt.parenL)) {\n    parseExpression();\n    expect(tt.parenR);\n  }\n}\nfunction flowParseTypeAndPredicateInitialiser() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.colon);\n  if (match(tt.modulo)) {\n    flowParsePredicate();\n  } else {\n    flowParseType();\n    if (match(tt.modulo)) {\n      flowParsePredicate();\n    }\n  }\n  popTypeContext(oldIsType);\n}\nfunction flowParseDeclareClass() {\n  next();\n  flowParseInterfaceish( /* isClass */true);\n}\nfunction flowParseDeclareFunction() {\n  next();\n  parseIdentifier();\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n  expect(tt.parenL);\n  flowParseFunctionTypeParams();\n  expect(tt.parenR);\n  flowParseTypeAndPredicateInitialiser();\n  semicolon();\n}\nfunction flowParseDeclare() {\n  if (match(tt._class)) {\n    flowParseDeclareClass();\n  } else if (match(tt._function)) {\n    flowParseDeclareFunction();\n  } else if (match(tt._var)) {\n    flowParseDeclareVariable();\n  } else if (eatContextual(ContextualKeyword._module)) {\n    if (eat(tt.dot)) {\n      flowParseDeclareModuleExports();\n    } else {\n      flowParseDeclareModule();\n    }\n  } else if (isContextual(ContextualKeyword._type)) {\n    flowParseDeclareTypeAlias();\n  } else if (isContextual(ContextualKeyword._opaque)) {\n    flowParseDeclareOpaqueType();\n  } else if (isContextual(ContextualKeyword._interface)) {\n    flowParseDeclareInterface();\n  } else if (match(tt._export)) {\n    flowParseDeclareExportDeclaration();\n  } else {\n    unexpected();\n  }\n}\nfunction flowParseDeclareVariable() {\n  next();\n  flowParseTypeAnnotatableIdentifier();\n  semicolon();\n}\nfunction flowParseDeclareModule() {\n  if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseIdentifier();\n  }\n  expect(tt.braceL);\n  while (!match(tt.braceR) && !state.error) {\n    if (match(tt._import)) {\n      next();\n      parseImport();\n    } else {\n      unexpected();\n    }\n  }\n  expect(tt.braceR);\n}\nfunction flowParseDeclareExportDeclaration() {\n  expect(tt._export);\n  if (eat(tt._default)) {\n    if (match(tt._function) || match(tt._class)) {\n      // declare export default class ...\n      // declare export default function ...\n      flowParseDeclare();\n    } else {\n      // declare export default [type];\n      flowParseType();\n      semicolon();\n    }\n  } else if (match(tt._var) ||\n  // declare export var ...\n  match(tt._function) ||\n  // declare export function ...\n  match(tt._class) ||\n  // declare export class ...\n  isContextual(ContextualKeyword._opaque) // declare export opaque ..\n  ) {\n    flowParseDeclare();\n  } else if (match(tt.star) ||\n  // declare export * from ''\n  match(tt.braceL) ||\n  // declare export {} ...\n  isContextual(ContextualKeyword._interface) ||\n  // declare export interface ...\n  isContextual(ContextualKeyword._type) ||\n  // declare export type ...\n  isContextual(ContextualKeyword._opaque) // declare export opaque type ...\n  ) {\n    parseExport();\n  } else {\n    unexpected();\n  }\n}\nfunction flowParseDeclareModuleExports() {\n  expectContextual(ContextualKeyword._exports);\n  flowParseTypeAnnotation();\n  semicolon();\n}\nfunction flowParseDeclareTypeAlias() {\n  next();\n  flowParseTypeAlias();\n}\nfunction flowParseDeclareOpaqueType() {\n  next();\n  flowParseOpaqueType(true);\n}\nfunction flowParseDeclareInterface() {\n  next();\n  flowParseInterfaceish();\n}\n\n// Interfaces\n\nfunction flowParseInterfaceish() {\n  let isClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  flowParseRestrictedIdentifier();\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n  if (eat(tt._extends)) {\n    do {\n      flowParseInterfaceExtends();\n    } while (!isClass && eat(tt.comma));\n  }\n  if (isContextual(ContextualKeyword._mixins)) {\n    next();\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n  if (isContextual(ContextualKeyword._implements)) {\n    next();\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n  flowParseObjectType(isClass, false, isClass);\n}\nfunction flowParseInterfaceExtends() {\n  flowParseQualifiedTypeIdentifier(false);\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n}\nfunction flowParseInterface() {\n  flowParseInterfaceish();\n}\nfunction flowParseRestrictedIdentifier() {\n  parseIdentifier();\n}\nfunction flowParseTypeAlias() {\n  flowParseRestrictedIdentifier();\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n  flowParseTypeInitialiser(tt.eq);\n  semicolon();\n}\nfunction flowParseOpaqueType(declare) {\n  expectContextual(ContextualKeyword._type);\n  flowParseRestrictedIdentifier();\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  // Parse the supertype\n  if (match(tt.colon)) {\n    flowParseTypeInitialiser(tt.colon);\n  }\n  if (!declare) {\n    flowParseTypeInitialiser(tt.eq);\n  }\n  semicolon();\n}\nfunction flowParseTypeParameter() {\n  flowParseVariance();\n  flowParseTypeAnnotatableIdentifier();\n  if (eat(tt.eq)) {\n    flowParseType();\n  }\n}\nexport function flowParseTypeParameterDeclaration() {\n  const oldIsType = pushTypeContext(0);\n  // istanbul ignore else: this condition is already checked at all call sites\n  if (match(tt.lessThan) || match(tt.typeParameterStart)) {\n    next();\n  } else {\n    unexpected();\n  }\n  do {\n    flowParseTypeParameter();\n    if (!match(tt.greaterThan)) {\n      expect(tt.comma);\n    }\n  } while (!match(tt.greaterThan) && !state.error);\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n}\nfunction flowParseTypeParameterInstantiation() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.lessThan);\n  while (!match(tt.greaterThan) && !state.error) {\n    flowParseType();\n    if (!match(tt.greaterThan)) {\n      expect(tt.comma);\n    }\n  }\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n}\nfunction flowParseInterfaceType() {\n  expectContextual(ContextualKeyword._interface);\n  if (eat(tt._extends)) {\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n  flowParseObjectType(false, false, false);\n}\nfunction flowParseObjectPropertyKey() {\n  if (match(tt.num) || match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseIdentifier();\n  }\n}\nfunction flowParseObjectTypeIndexer() {\n  // Note: bracketL has already been consumed\n  if (lookaheadType() === tt.colon) {\n    flowParseObjectPropertyKey();\n    flowParseTypeInitialiser();\n  } else {\n    flowParseType();\n  }\n  expect(tt.bracketR);\n  flowParseTypeInitialiser();\n}\nfunction flowParseObjectTypeInternalSlot() {\n  // Note: both bracketL have already been consumed\n  flowParseObjectPropertyKey();\n  expect(tt.bracketR);\n  expect(tt.bracketR);\n  if (match(tt.lessThan) || match(tt.parenL)) {\n    flowParseObjectTypeMethodish();\n  } else {\n    eat(tt.question);\n    flowParseTypeInitialiser();\n  }\n}\nfunction flowParseObjectTypeMethodish() {\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n  expect(tt.parenL);\n  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {\n    flowParseFunctionTypeParam();\n    if (!match(tt.parenR)) {\n      expect(tt.comma);\n    }\n  }\n  if (eat(tt.ellipsis)) {\n    flowParseFunctionTypeParam();\n  }\n  expect(tt.parenR);\n  flowParseTypeInitialiser();\n}\nfunction flowParseObjectTypeCallProperty() {\n  flowParseObjectTypeMethodish();\n}\nfunction flowParseObjectType(allowStatic, allowExact, allowProto) {\n  let endDelim;\n  if (allowExact && match(tt.braceBarL)) {\n    expect(tt.braceBarL);\n    endDelim = tt.braceBarR;\n  } else {\n    expect(tt.braceL);\n    endDelim = tt.braceR;\n  }\n  while (!match(endDelim) && !state.error) {\n    if (allowProto && isContextual(ContextualKeyword._proto)) {\n      const lookahead = lookaheadType();\n      if (lookahead !== tt.colon && lookahead !== tt.question) {\n        next();\n        allowStatic = false;\n      }\n    }\n    if (allowStatic && isContextual(ContextualKeyword._static)) {\n      const lookahead = lookaheadType();\n      if (lookahead !== tt.colon && lookahead !== tt.question) {\n        next();\n      }\n    }\n    flowParseVariance();\n    if (eat(tt.bracketL)) {\n      if (eat(tt.bracketL)) {\n        flowParseObjectTypeInternalSlot();\n      } else {\n        flowParseObjectTypeIndexer();\n      }\n    } else if (match(tt.parenL) || match(tt.lessThan)) {\n      flowParseObjectTypeCallProperty();\n    } else {\n      if (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) {\n        const lookahead = lookaheadType();\n        if (lookahead === tt.name || lookahead === tt.string || lookahead === tt.num) {\n          next();\n        }\n      }\n      flowParseObjectTypeProperty();\n    }\n    flowObjectTypeSemicolon();\n  }\n  expect(endDelim);\n}\nfunction flowParseObjectTypeProperty() {\n  if (match(tt.ellipsis)) {\n    expect(tt.ellipsis);\n    if (!eat(tt.comma)) {\n      eat(tt.semi);\n    }\n    // Explicit inexact object syntax.\n    if (match(tt.braceR)) {\n      return;\n    }\n    flowParseType();\n  } else {\n    flowParseObjectPropertyKey();\n    if (match(tt.lessThan) || match(tt.parenL)) {\n      // This is a method property\n      flowParseObjectTypeMethodish();\n    } else {\n      eat(tt.question);\n      flowParseTypeInitialiser();\n    }\n  }\n}\nfunction flowObjectTypeSemicolon() {\n  if (!eat(tt.semi) && !eat(tt.comma) && !match(tt.braceR) && !match(tt.braceBarR)) {\n    unexpected();\n  }\n}\nfunction flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {\n  if (!initialIdAlreadyParsed) {\n    parseIdentifier();\n  }\n  while (eat(tt.dot)) {\n    parseIdentifier();\n  }\n}\nfunction flowParseGenericType() {\n  flowParseQualifiedTypeIdentifier(true);\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n}\nfunction flowParseTypeofType() {\n  expect(tt._typeof);\n  flowParsePrimaryType();\n}\nfunction flowParseTupleType() {\n  expect(tt.bracketL);\n  // We allow trailing commas\n  while (state.pos < input.length && !match(tt.bracketR)) {\n    flowParseType();\n    if (match(tt.bracketR)) {\n      break;\n    }\n    expect(tt.comma);\n  }\n  expect(tt.bracketR);\n}\nfunction flowParseFunctionTypeParam() {\n  const lookahead = lookaheadType();\n  if (lookahead === tt.colon || lookahead === tt.question) {\n    parseIdentifier();\n    eat(tt.question);\n    flowParseTypeInitialiser();\n  } else {\n    flowParseType();\n  }\n}\nfunction flowParseFunctionTypeParams() {\n  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {\n    flowParseFunctionTypeParam();\n    if (!match(tt.parenR)) {\n      expect(tt.comma);\n    }\n  }\n  if (eat(tt.ellipsis)) {\n    flowParseFunctionTypeParam();\n  }\n}\n\n// The parsing of types roughly parallels the parsing of expressions, and\n// primary types are kind of like primary expressions...they're the\n// primitives with which other types are constructed.\nfunction flowParsePrimaryType() {\n  let isGroupedType = false;\n  const oldNoAnonFunctionType = state.noAnonFunctionType;\n  switch (state.type) {\n    case tt.name:\n      {\n        if (isContextual(ContextualKeyword._interface)) {\n          flowParseInterfaceType();\n          return;\n        }\n        parseIdentifier();\n        flowParseGenericType();\n        return;\n      }\n    case tt.braceL:\n      flowParseObjectType(false, false, false);\n      return;\n    case tt.braceBarL:\n      flowParseObjectType(false, true, false);\n      return;\n    case tt.bracketL:\n      flowParseTupleType();\n      return;\n    case tt.lessThan:\n      flowParseTypeParameterDeclaration();\n      expect(tt.parenL);\n      flowParseFunctionTypeParams();\n      expect(tt.parenR);\n      expect(tt.arrow);\n      flowParseType();\n      return;\n    case tt.parenL:\n      next();\n\n      // Check to see if this is actually a grouped type\n      if (!match(tt.parenR) && !match(tt.ellipsis)) {\n        if (match(tt.name)) {\n          const token = lookaheadType();\n          isGroupedType = token !== tt.question && token !== tt.colon;\n        } else {\n          isGroupedType = true;\n        }\n      }\n      if (isGroupedType) {\n        state.noAnonFunctionType = false;\n        flowParseType();\n        state.noAnonFunctionType = oldNoAnonFunctionType;\n\n        // A `,` or a `) =>` means this is an anonymous function type\n        if (state.noAnonFunctionType || !(match(tt.comma) || match(tt.parenR) && lookaheadType() === tt.arrow)) {\n          expect(tt.parenR);\n          return;\n        } else {\n          // Eat a comma if there is one\n          eat(tt.comma);\n        }\n      }\n      flowParseFunctionTypeParams();\n      expect(tt.parenR);\n      expect(tt.arrow);\n      flowParseType();\n      return;\n    case tt.minus:\n      next();\n      parseLiteral();\n      return;\n    case tt.string:\n    case tt.num:\n    case tt._true:\n    case tt._false:\n    case tt._null:\n    case tt._this:\n    case tt._void:\n    case tt.star:\n      next();\n      return;\n    default:\n      if (state.type === tt._typeof) {\n        flowParseTypeofType();\n        return;\n      } else if (state.type & TokenType.IS_KEYWORD) {\n        next();\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        return;\n      }\n  }\n  unexpected();\n}\nfunction flowParsePostfixType() {\n  flowParsePrimaryType();\n  while (!canInsertSemicolon() && (match(tt.bracketL) || match(tt.questionDot))) {\n    eat(tt.questionDot);\n    expect(tt.bracketL);\n    if (eat(tt.bracketR)) {\n      // Array type\n    } else {\n      // Indexed access type\n      flowParseType();\n      expect(tt.bracketR);\n    }\n  }\n}\nfunction flowParsePrefixType() {\n  if (eat(tt.question)) {\n    flowParsePrefixType();\n  } else {\n    flowParsePostfixType();\n  }\n}\nfunction flowParseAnonFunctionWithoutParens() {\n  flowParsePrefixType();\n  if (!state.noAnonFunctionType && eat(tt.arrow)) {\n    flowParseType();\n  }\n}\nfunction flowParseIntersectionType() {\n  eat(tt.bitwiseAND);\n  flowParseAnonFunctionWithoutParens();\n  while (eat(tt.bitwiseAND)) {\n    flowParseAnonFunctionWithoutParens();\n  }\n}\nfunction flowParseUnionType() {\n  eat(tt.bitwiseOR);\n  flowParseIntersectionType();\n  while (eat(tt.bitwiseOR)) {\n    flowParseIntersectionType();\n  }\n}\nfunction flowParseType() {\n  flowParseUnionType();\n}\nexport function flowParseTypeAnnotation() {\n  flowParseTypeInitialiser();\n}\nfunction flowParseTypeAnnotatableIdentifier() {\n  parseIdentifier();\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n}\nexport function flowParseVariance() {\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n    state.tokens[state.tokens.length - 1].isType = true;\n  }\n}\n\n// ==================================\n// Overrides\n// ==================================\n\nexport function flowParseFunctionBodyAndFinish(funcContextId) {\n  // For arrow functions, `parseArrow` handles the return type itself.\n  if (match(tt.colon)) {\n    flowParseTypeAndPredicateInitialiser();\n  }\n  parseFunctionBody(false, funcContextId);\n}\nexport function flowParseSubscript(startTokenIndex, noCalls, stopState) {\n  if (match(tt.questionDot) && lookaheadType() === tt.lessThan) {\n    if (noCalls) {\n      stopState.stop = true;\n      return;\n    }\n    next();\n    flowParseTypeParameterInstantiation();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n    return;\n  } else if (!noCalls && match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    flowParseTypeParameterInstantiation();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    } else {\n      return;\n    }\n  }\n  baseParseSubscript(startTokenIndex, noCalls, stopState);\n}\nexport function flowStartParseNewArguments() {\n  if (match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    flowParseTypeParameterInstantiation();\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n}\n\n// interfaces\nexport function flowTryParseStatement() {\n  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._interface) {\n    const oldIsType = pushTypeContext(0);\n    next();\n    flowParseInterface();\n    popTypeContext(oldIsType);\n    return true;\n  } else if (isContextual(ContextualKeyword._enum)) {\n    flowParseEnumDeclaration();\n    return true;\n  }\n  return false;\n}\nexport function flowTryParseExportDefaultExpression() {\n  if (isContextual(ContextualKeyword._enum)) {\n    flowParseEnumDeclaration();\n    return true;\n  }\n  return false;\n}\n\n// declares, interfaces and type aliases\nexport function flowParseIdentifierStatement(contextualKeyword) {\n  if (contextualKeyword === ContextualKeyword._declare) {\n    if (match(tt._class) || match(tt.name) || match(tt._function) || match(tt._var) || match(tt._export)) {\n      const oldIsType = pushTypeContext(1);\n      flowParseDeclare();\n      popTypeContext(oldIsType);\n    }\n  } else if (match(tt.name)) {\n    if (contextualKeyword === ContextualKeyword._interface) {\n      const oldIsType = pushTypeContext(1);\n      flowParseInterface();\n      popTypeContext(oldIsType);\n    } else if (contextualKeyword === ContextualKeyword._type) {\n      const oldIsType = pushTypeContext(1);\n      flowParseTypeAlias();\n      popTypeContext(oldIsType);\n    } else if (contextualKeyword === ContextualKeyword._opaque) {\n      const oldIsType = pushTypeContext(1);\n      flowParseOpaqueType(false);\n      popTypeContext(oldIsType);\n    }\n  }\n  semicolon();\n}\n\n// export type\nexport function flowShouldParseExportDeclaration() {\n  return isContextual(ContextualKeyword._type) || isContextual(ContextualKeyword._interface) || isContextual(ContextualKeyword._opaque) || isContextual(ContextualKeyword._enum);\n}\nexport function flowShouldDisallowExportDefaultSpecifier() {\n  return match(tt.name) && (state.contextualKeyword === ContextualKeyword._type || state.contextualKeyword === ContextualKeyword._interface || state.contextualKeyword === ContextualKeyword._opaque || state.contextualKeyword === ContextualKeyword._enum);\n}\nexport function flowParseExportDeclaration() {\n  if (isContextual(ContextualKeyword._type)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n    if (match(tt.braceL)) {\n      // export type { foo, bar };\n      parseExportSpecifiers();\n      parseExportFrom();\n    } else {\n      // export type Foo = Bar;\n      flowParseTypeAlias();\n    }\n    popTypeContext(oldIsType);\n  } else if (isContextual(ContextualKeyword._opaque)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n    // export opaque type Foo = Bar;\n    flowParseOpaqueType(false);\n    popTypeContext(oldIsType);\n  } else if (isContextual(ContextualKeyword._interface)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n    flowParseInterface();\n    popTypeContext(oldIsType);\n  } else {\n    parseStatement(true);\n  }\n}\nexport function flowShouldParseExportStar() {\n  return match(tt.star) || isContextual(ContextualKeyword._type) && lookaheadType() === tt.star;\n}\nexport function flowParseExportStar() {\n  if (eatContextual(ContextualKeyword._type)) {\n    const oldIsType = pushTypeContext(2);\n    baseParseExportStar();\n    popTypeContext(oldIsType);\n  } else {\n    baseParseExportStar();\n  }\n}\n\n// parse a the super class type parameters and implements\nexport function flowAfterParseClassSuper(hasSuper) {\n  if (hasSuper && match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n  if (isContextual(ContextualKeyword._implements)) {\n    const oldIsType = pushTypeContext(0);\n    next();\n    state.tokens[state.tokens.length - 1].type = tt._implements;\n    do {\n      flowParseRestrictedIdentifier();\n      if (match(tt.lessThan)) {\n        flowParseTypeParameterInstantiation();\n      }\n    } while (eat(tt.comma));\n    popTypeContext(oldIsType);\n  }\n}\n\n// parse type parameters for object method shorthand\nexport function flowStartParseObjPropValue() {\n  // method shorthand\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n    if (!match(tt.parenL)) unexpected();\n  }\n}\nexport function flowParseAssignableListItemTypes() {\n  const oldIsType = pushTypeContext(0);\n  eat(tt.question);\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n  popTypeContext(oldIsType);\n}\n\n// parse typeof and type imports\nexport function flowStartParseImportSpecifiers() {\n  if (match(tt._typeof) || isContextual(ContextualKeyword._type)) {\n    const lh = lookaheadTypeAndKeyword();\n    if (isMaybeDefaultImport(lh) || lh.type === tt.braceL || lh.type === tt.star) {\n      next();\n    }\n  }\n}\n\n// parse import-type/typeof shorthand\nexport function flowParseImportSpecifier() {\n  const isTypeKeyword = state.contextualKeyword === ContextualKeyword._type || state.type === tt._typeof;\n  if (isTypeKeyword) {\n    next();\n  } else {\n    parseIdentifier();\n  }\n  if (isContextual(ContextualKeyword._as) && !isLookaheadContextual(ContextualKeyword._as)) {\n    parseIdentifier();\n    if (isTypeKeyword && !match(tt.name) && !(state.type & TokenType.IS_KEYWORD)) {\n      // `import {type as ,` or `import {type as }`\n    } else {\n      // `import {type as foo`\n      parseIdentifier();\n    }\n  } else {\n    if (isTypeKeyword && (match(tt.name) || !!(state.type & TokenType.IS_KEYWORD))) {\n      // `import {type foo`\n      parseIdentifier();\n    }\n    if (eatContextual(ContextualKeyword._as)) {\n      parseIdentifier();\n    }\n  }\n}\n\n// parse function type parameters - function foo<T>() {}\nexport function flowStartParseFunctionParams() {\n  // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon\n  // anyway, so don't try to propagate that information.\n  if (match(tt.lessThan)) {\n    const oldIsType = pushTypeContext(0);\n    flowParseTypeParameterDeclaration();\n    popTypeContext(oldIsType);\n  }\n}\n\n// parse flow type annotations on variable declarator heads - let foo: string = bar\nexport function flowAfterParseVarHead() {\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n}\n\n// parse the return type of an async arrow function - let foo = (async (): number => {});\nexport function flowStartParseAsyncArrowFromCallExpression() {\n  if (match(tt.colon)) {\n    const oldNoAnonFunctionType = state.noAnonFunctionType;\n    state.noAnonFunctionType = true;\n    flowParseTypeAnnotation();\n    state.noAnonFunctionType = oldNoAnonFunctionType;\n  }\n}\n\n// We need to support type parameter declarations for arrow functions. This\n// is tricky. There are three situations we need to handle\n//\n// 1. This is either JSX or an arrow function. We'll try JSX first. If that\n//    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n//    error.\n// 2. This is an arrow function. We'll parse the type parameter declaration,\n//    parse the rest, make sure the rest is an arrow function, and go from\n//    there\n// 3. This is neither. Just call the super method\nexport function flowParseMaybeAssign(noIn, isWithinParens) {\n  if (match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n      state.type = tt.typeParameterStart;\n    } else {\n      return wasArrow;\n    }\n    const oldIsType = pushTypeContext(0);\n    flowParseTypeParameterDeclaration();\n    popTypeContext(oldIsType);\n    wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n    if (wasArrow) {\n      return true;\n    }\n    unexpected();\n  }\n  return baseParseMaybeAssign(noIn, isWithinParens);\n}\n\n// handle return types for arrow functions\nexport function flowParseArrow() {\n  if (match(tt.colon)) {\n    const oldIsType = pushTypeContext(0);\n    const snapshot = state.snapshot();\n    const oldNoAnonFunctionType = state.noAnonFunctionType;\n    state.noAnonFunctionType = true;\n    flowParseTypeAndPredicateInitialiser();\n    state.noAnonFunctionType = oldNoAnonFunctionType;\n    if (canInsertSemicolon()) unexpected();\n    if (!match(tt.arrow)) unexpected();\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n    popTypeContext(oldIsType);\n  }\n  return eat(tt.arrow);\n}\nexport function flowParseSubscripts(startTokenIndex) {\n  let noCalls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async && match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    const wasArrow = parseAsyncArrowWithTypeParameters();\n    if (wasArrow && !state.error) {\n      return;\n    }\n    state.restoreFromSnapshot(snapshot);\n  }\n  baseParseSubscripts(startTokenIndex, noCalls);\n}\n\n// Returns true if there was an arrow function here.\nfunction parseAsyncArrowWithTypeParameters() {\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  parseFunctionParams();\n  if (!parseArrow()) {\n    return false;\n  }\n  parseArrowExpression(startTokenIndex);\n  return true;\n}\nfunction flowParseEnumDeclaration() {\n  expectContextual(ContextualKeyword._enum);\n  state.tokens[state.tokens.length - 1].type = tt._enum;\n  parseIdentifier();\n  flowParseEnumBody();\n}\nfunction flowParseEnumBody() {\n  if (eatContextual(ContextualKeyword._of)) {\n    next();\n  }\n  expect(tt.braceL);\n  flowParseEnumMembers();\n  expect(tt.braceR);\n}\nfunction flowParseEnumMembers() {\n  while (!match(tt.braceR) && !state.error) {\n    if (eat(tt.ellipsis)) {\n      break;\n    }\n    flowParseEnumMember();\n    if (!match(tt.braceR)) {\n      expect(tt.comma);\n    }\n  }\n}\nfunction flowParseEnumMember() {\n  parseIdentifier();\n  if (eat(tt.eq)) {\n    // Flow enum values are always just one token (a string, number, or boolean literal).\n    next();\n  }\n}","map":{"version":3,"names":["eat","lookaheadType","lookaheadTypeAndKeyword","match","next","popTypeContext","pushTypeContext","ContextualKeyword","TokenType","tt","input","state","baseParseMaybeAssign","baseParseSubscript","baseParseSubscripts","parseArrow","parseArrowExpression","parseCallExpressionArguments","parseExprAtom","parseExpression","parseFunctionBody","parseIdentifier","parseLiteral","baseParseExportStar","parseExport","parseExportFrom","parseExportSpecifiers","parseFunctionParams","parseImport","parseStatement","canInsertSemicolon","eatContextual","expect","expectContextual","isContextual","isLookaheadContextual","semicolon","unexpected","isMaybeDefaultImport","lookahead","type","name","IS_KEYWORD","contextualKeyword","_from","flowParseTypeInitialiser","tok","oldIsType","colon","flowParseType","flowParsePredicate","modulo","_checks","parenL","parenR","flowParseTypeAndPredicateInitialiser","flowParseDeclareClass","flowParseInterfaceish","flowParseDeclareFunction","lessThan","flowParseTypeParameterDeclaration","flowParseFunctionTypeParams","flowParseDeclare","_class","_function","_var","flowParseDeclareVariable","_module","dot","flowParseDeclareModuleExports","flowParseDeclareModule","_type","flowParseDeclareTypeAlias","_opaque","flowParseDeclareOpaqueType","_interface","flowParseDeclareInterface","_export","flowParseDeclareExportDeclaration","flowParseTypeAnnotatableIdentifier","string","braceL","braceR","error","_import","_default","star","_exports","flowParseTypeAnnotation","flowParseTypeAlias","flowParseOpaqueType","isClass","arguments","length","undefined","flowParseRestrictedIdentifier","_extends","flowParseInterfaceExtends","comma","_mixins","_implements","flowParseObjectType","flowParseQualifiedTypeIdentifier","flowParseTypeParameterInstantiation","flowParseInterface","eq","declare","flowParseTypeParameter","flowParseVariance","typeParameterStart","greaterThan","flowParseInterfaceType","flowParseObjectPropertyKey","num","flowParseObjectTypeIndexer","bracketR","flowParseObjectTypeInternalSlot","flowParseObjectTypeMethodish","question","ellipsis","flowParseFunctionTypeParam","flowParseObjectTypeCallProperty","allowStatic","allowExact","allowProto","endDelim","braceBarL","braceBarR","_proto","_static","bracketL","_get","_set","flowParseObjectTypeProperty","flowObjectTypeSemicolon","semi","initialIdAlreadyParsed","flowParseGenericType","flowParseTypeofType","_typeof","flowParsePrimaryType","flowParseTupleType","pos","isGroupedType","oldNoAnonFunctionType","noAnonFunctionType","arrow","token","minus","_true","_false","_null","_this","_void","tokens","flowParsePostfixType","questionDot","flowParsePrefixType","flowParseAnonFunctionWithoutParens","flowParseIntersectionType","bitwiseAND","flowParseUnionType","bitwiseOR","plus","isType","flowParseFunctionBodyAndFinish","funcContextId","flowParseSubscript","startTokenIndex","noCalls","stopState","stop","snapshot","restoreFromSnapshot","flowStartParseNewArguments","flowTryParseStatement","_enum","flowParseEnumDeclaration","flowTryParseExportDefaultExpression","flowParseIdentifierStatement","_declare","flowShouldParseExportDeclaration","flowShouldDisallowExportDefaultSpecifier","flowParseExportDeclaration","flowShouldParseExportStar","flowParseExportStar","flowAfterParseClassSuper","hasSuper","flowStartParseObjPropValue","flowParseAssignableListItemTypes","flowStartParseImportSpecifiers","lh","flowParseImportSpecifier","isTypeKeyword","_as","flowStartParseFunctionParams","flowAfterParseVarHead","flowStartParseAsyncArrowFromCallExpression","flowParseMaybeAssign","noIn","isWithinParens","wasArrow","flowParseArrow","flowParseSubscripts","_async","parseAsyncArrowWithTypeParameters","scopeDepth","flowParseEnumBody","_of","flowParseEnumMembers","flowParseEnumMember"],"sources":["/Users/manan/Desktop/hach-unicorn/StockSure/frontend1/node_modules/sucrase/dist/esm/parser/plugins/flow.js"],"sourcesContent":["/* eslint max-len: 0 */\n\nimport {\n  eat,\n  lookaheadType,\n  lookaheadTypeAndKeyword,\n  match,\n  next,\n  popTypeContext,\n  pushTypeContext,\n\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {input, state} from \"../traverser/base\";\nimport {\n  baseParseMaybeAssign,\n  baseParseSubscript,\n  baseParseSubscripts,\n  parseArrow,\n  parseArrowExpression,\n  parseCallExpressionArguments,\n  parseExprAtom,\n  parseExpression,\n  parseFunctionBody,\n  parseIdentifier,\n  parseLiteral,\n\n} from \"../traverser/expression\";\nimport {\n  baseParseExportStar,\n  parseExport,\n  parseExportFrom,\n  parseExportSpecifiers,\n  parseFunctionParams,\n  parseImport,\n  parseStatement,\n} from \"../traverser/statement\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  isContextual,\n  isLookaheadContextual,\n  semicolon,\n  unexpected,\n} from \"../traverser/util\";\n\nfunction isMaybeDefaultImport(lookahead) {\n  return (\n    (lookahead.type === tt.name || !!(lookahead.type & TokenType.IS_KEYWORD)) &&\n    lookahead.contextualKeyword !== ContextualKeyword._from\n  );\n}\n\nfunction flowParseTypeInitialiser(tok) {\n  const oldIsType = pushTypeContext(0);\n  expect(tok || tt.colon);\n  flowParseType();\n  popTypeContext(oldIsType);\n}\n\nfunction flowParsePredicate() {\n  expect(tt.modulo);\n  expectContextual(ContextualKeyword._checks);\n  if (eat(tt.parenL)) {\n    parseExpression();\n    expect(tt.parenR);\n  }\n}\n\nfunction flowParseTypeAndPredicateInitialiser() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.colon);\n  if (match(tt.modulo)) {\n    flowParsePredicate();\n  } else {\n    flowParseType();\n    if (match(tt.modulo)) {\n      flowParsePredicate();\n    }\n  }\n  popTypeContext(oldIsType);\n}\n\nfunction flowParseDeclareClass() {\n  next();\n  flowParseInterfaceish(/* isClass */ true);\n}\n\nfunction flowParseDeclareFunction() {\n  next();\n  parseIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  expect(tt.parenL);\n  flowParseFunctionTypeParams();\n  expect(tt.parenR);\n\n  flowParseTypeAndPredicateInitialiser();\n\n  semicolon();\n}\n\nfunction flowParseDeclare() {\n  if (match(tt._class)) {\n    flowParseDeclareClass();\n  } else if (match(tt._function)) {\n    flowParseDeclareFunction();\n  } else if (match(tt._var)) {\n    flowParseDeclareVariable();\n  } else if (eatContextual(ContextualKeyword._module)) {\n    if (eat(tt.dot)) {\n      flowParseDeclareModuleExports();\n    } else {\n      flowParseDeclareModule();\n    }\n  } else if (isContextual(ContextualKeyword._type)) {\n    flowParseDeclareTypeAlias();\n  } else if (isContextual(ContextualKeyword._opaque)) {\n    flowParseDeclareOpaqueType();\n  } else if (isContextual(ContextualKeyword._interface)) {\n    flowParseDeclareInterface();\n  } else if (match(tt._export)) {\n    flowParseDeclareExportDeclaration();\n  } else {\n    unexpected();\n  }\n}\n\nfunction flowParseDeclareVariable() {\n  next();\n  flowParseTypeAnnotatableIdentifier();\n  semicolon();\n}\n\nfunction flowParseDeclareModule() {\n  if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseIdentifier();\n  }\n\n  expect(tt.braceL);\n  while (!match(tt.braceR) && !state.error) {\n    if (match(tt._import)) {\n      next();\n      parseImport();\n    } else {\n      unexpected();\n    }\n  }\n  expect(tt.braceR);\n}\n\nfunction flowParseDeclareExportDeclaration() {\n  expect(tt._export);\n\n  if (eat(tt._default)) {\n    if (match(tt._function) || match(tt._class)) {\n      // declare export default class ...\n      // declare export default function ...\n      flowParseDeclare();\n    } else {\n      // declare export default [type];\n      flowParseType();\n      semicolon();\n    }\n  } else if (\n    match(tt._var) || // declare export var ...\n    match(tt._function) || // declare export function ...\n    match(tt._class) || // declare export class ...\n    isContextual(ContextualKeyword._opaque) // declare export opaque ..\n  ) {\n    flowParseDeclare();\n  } else if (\n    match(tt.star) || // declare export * from ''\n    match(tt.braceL) || // declare export {} ...\n    isContextual(ContextualKeyword._interface) || // declare export interface ...\n    isContextual(ContextualKeyword._type) || // declare export type ...\n    isContextual(ContextualKeyword._opaque) // declare export opaque type ...\n  ) {\n    parseExport();\n  } else {\n    unexpected();\n  }\n}\n\nfunction flowParseDeclareModuleExports() {\n  expectContextual(ContextualKeyword._exports);\n  flowParseTypeAnnotation();\n  semicolon();\n}\n\nfunction flowParseDeclareTypeAlias() {\n  next();\n  flowParseTypeAlias();\n}\n\nfunction flowParseDeclareOpaqueType() {\n  next();\n  flowParseOpaqueType(true);\n}\n\nfunction flowParseDeclareInterface() {\n  next();\n  flowParseInterfaceish();\n}\n\n// Interfaces\n\nfunction flowParseInterfaceish(isClass = false) {\n  flowParseRestrictedIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  if (eat(tt._extends)) {\n    do {\n      flowParseInterfaceExtends();\n    } while (!isClass && eat(tt.comma));\n  }\n\n  if (isContextual(ContextualKeyword._mixins)) {\n    next();\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n\n  if (isContextual(ContextualKeyword._implements)) {\n    next();\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n\n  flowParseObjectType(isClass, false, isClass);\n}\n\nfunction flowParseInterfaceExtends() {\n  flowParseQualifiedTypeIdentifier(false);\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n}\n\nfunction flowParseInterface() {\n  flowParseInterfaceish();\n}\n\nfunction flowParseRestrictedIdentifier() {\n  parseIdentifier();\n}\n\nfunction flowParseTypeAlias() {\n  flowParseRestrictedIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  flowParseTypeInitialiser(tt.eq);\n  semicolon();\n}\n\nfunction flowParseOpaqueType(declare) {\n  expectContextual(ContextualKeyword._type);\n  flowParseRestrictedIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  // Parse the supertype\n  if (match(tt.colon)) {\n    flowParseTypeInitialiser(tt.colon);\n  }\n\n  if (!declare) {\n    flowParseTypeInitialiser(tt.eq);\n  }\n  semicolon();\n}\n\nfunction flowParseTypeParameter() {\n  flowParseVariance();\n  flowParseTypeAnnotatableIdentifier();\n\n  if (eat(tt.eq)) {\n    flowParseType();\n  }\n}\n\nexport function flowParseTypeParameterDeclaration() {\n  const oldIsType = pushTypeContext(0);\n  // istanbul ignore else: this condition is already checked at all call sites\n  if (match(tt.lessThan) || match(tt.typeParameterStart)) {\n    next();\n  } else {\n    unexpected();\n  }\n\n  do {\n    flowParseTypeParameter();\n    if (!match(tt.greaterThan)) {\n      expect(tt.comma);\n    }\n  } while (!match(tt.greaterThan) && !state.error);\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n}\n\nfunction flowParseTypeParameterInstantiation() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.lessThan);\n  while (!match(tt.greaterThan) && !state.error) {\n    flowParseType();\n    if (!match(tt.greaterThan)) {\n      expect(tt.comma);\n    }\n  }\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n}\n\nfunction flowParseInterfaceType() {\n  expectContextual(ContextualKeyword._interface);\n  if (eat(tt._extends)) {\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n  flowParseObjectType(false, false, false);\n}\n\nfunction flowParseObjectPropertyKey() {\n  if (match(tt.num) || match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseIdentifier();\n  }\n}\n\nfunction flowParseObjectTypeIndexer() {\n  // Note: bracketL has already been consumed\n  if (lookaheadType() === tt.colon) {\n    flowParseObjectPropertyKey();\n    flowParseTypeInitialiser();\n  } else {\n    flowParseType();\n  }\n  expect(tt.bracketR);\n  flowParseTypeInitialiser();\n}\n\nfunction flowParseObjectTypeInternalSlot() {\n  // Note: both bracketL have already been consumed\n  flowParseObjectPropertyKey();\n  expect(tt.bracketR);\n  expect(tt.bracketR);\n  if (match(tt.lessThan) || match(tt.parenL)) {\n    flowParseObjectTypeMethodish();\n  } else {\n    eat(tt.question);\n    flowParseTypeInitialiser();\n  }\n}\n\nfunction flowParseObjectTypeMethodish() {\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  expect(tt.parenL);\n  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {\n    flowParseFunctionTypeParam();\n    if (!match(tt.parenR)) {\n      expect(tt.comma);\n    }\n  }\n\n  if (eat(tt.ellipsis)) {\n    flowParseFunctionTypeParam();\n  }\n  expect(tt.parenR);\n  flowParseTypeInitialiser();\n}\n\nfunction flowParseObjectTypeCallProperty() {\n  flowParseObjectTypeMethodish();\n}\n\nfunction flowParseObjectType(allowStatic, allowExact, allowProto) {\n  let endDelim;\n  if (allowExact && match(tt.braceBarL)) {\n    expect(tt.braceBarL);\n    endDelim = tt.braceBarR;\n  } else {\n    expect(tt.braceL);\n    endDelim = tt.braceR;\n  }\n\n  while (!match(endDelim) && !state.error) {\n    if (allowProto && isContextual(ContextualKeyword._proto)) {\n      const lookahead = lookaheadType();\n      if (lookahead !== tt.colon && lookahead !== tt.question) {\n        next();\n        allowStatic = false;\n      }\n    }\n    if (allowStatic && isContextual(ContextualKeyword._static)) {\n      const lookahead = lookaheadType();\n      if (lookahead !== tt.colon && lookahead !== tt.question) {\n        next();\n      }\n    }\n\n    flowParseVariance();\n\n    if (eat(tt.bracketL)) {\n      if (eat(tt.bracketL)) {\n        flowParseObjectTypeInternalSlot();\n      } else {\n        flowParseObjectTypeIndexer();\n      }\n    } else if (match(tt.parenL) || match(tt.lessThan)) {\n      flowParseObjectTypeCallProperty();\n    } else {\n      if (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) {\n        const lookahead = lookaheadType();\n        if (lookahead === tt.name || lookahead === tt.string || lookahead === tt.num) {\n          next();\n        }\n      }\n\n      flowParseObjectTypeProperty();\n    }\n\n    flowObjectTypeSemicolon();\n  }\n\n  expect(endDelim);\n}\n\nfunction flowParseObjectTypeProperty() {\n  if (match(tt.ellipsis)) {\n    expect(tt.ellipsis);\n    if (!eat(tt.comma)) {\n      eat(tt.semi);\n    }\n    // Explicit inexact object syntax.\n    if (match(tt.braceR)) {\n      return;\n    }\n    flowParseType();\n  } else {\n    flowParseObjectPropertyKey();\n    if (match(tt.lessThan) || match(tt.parenL)) {\n      // This is a method property\n      flowParseObjectTypeMethodish();\n    } else {\n      eat(tt.question);\n      flowParseTypeInitialiser();\n    }\n  }\n}\n\nfunction flowObjectTypeSemicolon() {\n  if (!eat(tt.semi) && !eat(tt.comma) && !match(tt.braceR) && !match(tt.braceBarR)) {\n    unexpected();\n  }\n}\n\nfunction flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {\n  if (!initialIdAlreadyParsed) {\n    parseIdentifier();\n  }\n  while (eat(tt.dot)) {\n    parseIdentifier();\n  }\n}\n\nfunction flowParseGenericType() {\n  flowParseQualifiedTypeIdentifier(true);\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n}\n\nfunction flowParseTypeofType() {\n  expect(tt._typeof);\n  flowParsePrimaryType();\n}\n\nfunction flowParseTupleType() {\n  expect(tt.bracketL);\n  // We allow trailing commas\n  while (state.pos < input.length && !match(tt.bracketR)) {\n    flowParseType();\n    if (match(tt.bracketR)) {\n      break;\n    }\n    expect(tt.comma);\n  }\n  expect(tt.bracketR);\n}\n\nfunction flowParseFunctionTypeParam() {\n  const lookahead = lookaheadType();\n  if (lookahead === tt.colon || lookahead === tt.question) {\n    parseIdentifier();\n    eat(tt.question);\n    flowParseTypeInitialiser();\n  } else {\n    flowParseType();\n  }\n}\n\nfunction flowParseFunctionTypeParams() {\n  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {\n    flowParseFunctionTypeParam();\n    if (!match(tt.parenR)) {\n      expect(tt.comma);\n    }\n  }\n  if (eat(tt.ellipsis)) {\n    flowParseFunctionTypeParam();\n  }\n}\n\n// The parsing of types roughly parallels the parsing of expressions, and\n// primary types are kind of like primary expressions...they're the\n// primitives with which other types are constructed.\nfunction flowParsePrimaryType() {\n  let isGroupedType = false;\n  const oldNoAnonFunctionType = state.noAnonFunctionType;\n\n  switch (state.type) {\n    case tt.name: {\n      if (isContextual(ContextualKeyword._interface)) {\n        flowParseInterfaceType();\n        return;\n      }\n      parseIdentifier();\n      flowParseGenericType();\n      return;\n    }\n\n    case tt.braceL:\n      flowParseObjectType(false, false, false);\n      return;\n\n    case tt.braceBarL:\n      flowParseObjectType(false, true, false);\n      return;\n\n    case tt.bracketL:\n      flowParseTupleType();\n      return;\n\n    case tt.lessThan:\n      flowParseTypeParameterDeclaration();\n      expect(tt.parenL);\n      flowParseFunctionTypeParams();\n      expect(tt.parenR);\n      expect(tt.arrow);\n      flowParseType();\n      return;\n\n    case tt.parenL:\n      next();\n\n      // Check to see if this is actually a grouped type\n      if (!match(tt.parenR) && !match(tt.ellipsis)) {\n        if (match(tt.name)) {\n          const token = lookaheadType();\n          isGroupedType = token !== tt.question && token !== tt.colon;\n        } else {\n          isGroupedType = true;\n        }\n      }\n\n      if (isGroupedType) {\n        state.noAnonFunctionType = false;\n        flowParseType();\n        state.noAnonFunctionType = oldNoAnonFunctionType;\n\n        // A `,` or a `) =>` means this is an anonymous function type\n        if (\n          state.noAnonFunctionType ||\n          !(match(tt.comma) || (match(tt.parenR) && lookaheadType() === tt.arrow))\n        ) {\n          expect(tt.parenR);\n          return;\n        } else {\n          // Eat a comma if there is one\n          eat(tt.comma);\n        }\n      }\n\n      flowParseFunctionTypeParams();\n\n      expect(tt.parenR);\n      expect(tt.arrow);\n      flowParseType();\n      return;\n\n    case tt.minus:\n      next();\n      parseLiteral();\n      return;\n\n    case tt.string:\n    case tt.num:\n    case tt._true:\n    case tt._false:\n    case tt._null:\n    case tt._this:\n    case tt._void:\n    case tt.star:\n      next();\n      return;\n\n    default:\n      if (state.type === tt._typeof) {\n        flowParseTypeofType();\n        return;\n      } else if (state.type & TokenType.IS_KEYWORD) {\n        next();\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        return;\n      }\n  }\n\n  unexpected();\n}\n\nfunction flowParsePostfixType() {\n  flowParsePrimaryType();\n  while (!canInsertSemicolon() && (match(tt.bracketL) || match(tt.questionDot))) {\n    eat(tt.questionDot);\n    expect(tt.bracketL);\n    if (eat(tt.bracketR)) {\n      // Array type\n    } else {\n      // Indexed access type\n      flowParseType();\n      expect(tt.bracketR);\n    }\n  }\n}\n\nfunction flowParsePrefixType() {\n  if (eat(tt.question)) {\n    flowParsePrefixType();\n  } else {\n    flowParsePostfixType();\n  }\n}\n\nfunction flowParseAnonFunctionWithoutParens() {\n  flowParsePrefixType();\n  if (!state.noAnonFunctionType && eat(tt.arrow)) {\n    flowParseType();\n  }\n}\n\nfunction flowParseIntersectionType() {\n  eat(tt.bitwiseAND);\n  flowParseAnonFunctionWithoutParens();\n  while (eat(tt.bitwiseAND)) {\n    flowParseAnonFunctionWithoutParens();\n  }\n}\n\nfunction flowParseUnionType() {\n  eat(tt.bitwiseOR);\n  flowParseIntersectionType();\n  while (eat(tt.bitwiseOR)) {\n    flowParseIntersectionType();\n  }\n}\n\nfunction flowParseType() {\n  flowParseUnionType();\n}\n\nexport function flowParseTypeAnnotation() {\n  flowParseTypeInitialiser();\n}\n\nfunction flowParseTypeAnnotatableIdentifier() {\n  parseIdentifier();\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n}\n\nexport function flowParseVariance() {\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n    state.tokens[state.tokens.length - 1].isType = true;\n  }\n}\n\n// ==================================\n// Overrides\n// ==================================\n\nexport function flowParseFunctionBodyAndFinish(funcContextId) {\n  // For arrow functions, `parseArrow` handles the return type itself.\n  if (match(tt.colon)) {\n    flowParseTypeAndPredicateInitialiser();\n  }\n\n  parseFunctionBody(false, funcContextId);\n}\n\nexport function flowParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (match(tt.questionDot) && lookaheadType() === tt.lessThan) {\n    if (noCalls) {\n      stopState.stop = true;\n      return;\n    }\n    next();\n    flowParseTypeParameterInstantiation();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n    return;\n  } else if (!noCalls && match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    flowParseTypeParameterInstantiation();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    } else {\n      return;\n    }\n  }\n  baseParseSubscript(startTokenIndex, noCalls, stopState);\n}\n\nexport function flowStartParseNewArguments() {\n  if (match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    flowParseTypeParameterInstantiation();\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n}\n\n// interfaces\nexport function flowTryParseStatement() {\n  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._interface) {\n    const oldIsType = pushTypeContext(0);\n    next();\n    flowParseInterface();\n    popTypeContext(oldIsType);\n    return true;\n  } else if (isContextual(ContextualKeyword._enum)) {\n    flowParseEnumDeclaration();\n    return true;\n  }\n  return false;\n}\n\nexport function flowTryParseExportDefaultExpression() {\n  if (isContextual(ContextualKeyword._enum)) {\n    flowParseEnumDeclaration();\n    return true;\n  }\n  return false;\n}\n\n// declares, interfaces and type aliases\nexport function flowParseIdentifierStatement(contextualKeyword) {\n  if (contextualKeyword === ContextualKeyword._declare) {\n    if (\n      match(tt._class) ||\n      match(tt.name) ||\n      match(tt._function) ||\n      match(tt._var) ||\n      match(tt._export)\n    ) {\n      const oldIsType = pushTypeContext(1);\n      flowParseDeclare();\n      popTypeContext(oldIsType);\n    }\n  } else if (match(tt.name)) {\n    if (contextualKeyword === ContextualKeyword._interface) {\n      const oldIsType = pushTypeContext(1);\n      flowParseInterface();\n      popTypeContext(oldIsType);\n    } else if (contextualKeyword === ContextualKeyword._type) {\n      const oldIsType = pushTypeContext(1);\n      flowParseTypeAlias();\n      popTypeContext(oldIsType);\n    } else if (contextualKeyword === ContextualKeyword._opaque) {\n      const oldIsType = pushTypeContext(1);\n      flowParseOpaqueType(false);\n      popTypeContext(oldIsType);\n    }\n  }\n  semicolon();\n}\n\n// export type\nexport function flowShouldParseExportDeclaration() {\n  return (\n    isContextual(ContextualKeyword._type) ||\n    isContextual(ContextualKeyword._interface) ||\n    isContextual(ContextualKeyword._opaque) ||\n    isContextual(ContextualKeyword._enum)\n  );\n}\n\nexport function flowShouldDisallowExportDefaultSpecifier() {\n  return (\n    match(tt.name) &&\n    (state.contextualKeyword === ContextualKeyword._type ||\n      state.contextualKeyword === ContextualKeyword._interface ||\n      state.contextualKeyword === ContextualKeyword._opaque ||\n      state.contextualKeyword === ContextualKeyword._enum)\n  );\n}\n\nexport function flowParseExportDeclaration() {\n  if (isContextual(ContextualKeyword._type)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n\n    if (match(tt.braceL)) {\n      // export type { foo, bar };\n      parseExportSpecifiers();\n      parseExportFrom();\n    } else {\n      // export type Foo = Bar;\n      flowParseTypeAlias();\n    }\n    popTypeContext(oldIsType);\n  } else if (isContextual(ContextualKeyword._opaque)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n    // export opaque type Foo = Bar;\n    flowParseOpaqueType(false);\n    popTypeContext(oldIsType);\n  } else if (isContextual(ContextualKeyword._interface)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n    flowParseInterface();\n    popTypeContext(oldIsType);\n  } else {\n    parseStatement(true);\n  }\n}\n\nexport function flowShouldParseExportStar() {\n  return match(tt.star) || (isContextual(ContextualKeyword._type) && lookaheadType() === tt.star);\n}\n\nexport function flowParseExportStar() {\n  if (eatContextual(ContextualKeyword._type)) {\n    const oldIsType = pushTypeContext(2);\n    baseParseExportStar();\n    popTypeContext(oldIsType);\n  } else {\n    baseParseExportStar();\n  }\n}\n\n// parse a the super class type parameters and implements\nexport function flowAfterParseClassSuper(hasSuper) {\n  if (hasSuper && match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n  if (isContextual(ContextualKeyword._implements)) {\n    const oldIsType = pushTypeContext(0);\n    next();\n    state.tokens[state.tokens.length - 1].type = tt._implements;\n    do {\n      flowParseRestrictedIdentifier();\n      if (match(tt.lessThan)) {\n        flowParseTypeParameterInstantiation();\n      }\n    } while (eat(tt.comma));\n    popTypeContext(oldIsType);\n  }\n}\n\n// parse type parameters for object method shorthand\nexport function flowStartParseObjPropValue() {\n  // method shorthand\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n    if (!match(tt.parenL)) unexpected();\n  }\n}\n\nexport function flowParseAssignableListItemTypes() {\n  const oldIsType = pushTypeContext(0);\n  eat(tt.question);\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n  popTypeContext(oldIsType);\n}\n\n// parse typeof and type imports\nexport function flowStartParseImportSpecifiers() {\n  if (match(tt._typeof) || isContextual(ContextualKeyword._type)) {\n    const lh = lookaheadTypeAndKeyword();\n    if (isMaybeDefaultImport(lh) || lh.type === tt.braceL || lh.type === tt.star) {\n      next();\n    }\n  }\n}\n\n// parse import-type/typeof shorthand\nexport function flowParseImportSpecifier() {\n  const isTypeKeyword =\n    state.contextualKeyword === ContextualKeyword._type || state.type === tt._typeof;\n  if (isTypeKeyword) {\n    next();\n  } else {\n    parseIdentifier();\n  }\n\n  if (isContextual(ContextualKeyword._as) && !isLookaheadContextual(ContextualKeyword._as)) {\n    parseIdentifier();\n    if (isTypeKeyword && !match(tt.name) && !(state.type & TokenType.IS_KEYWORD)) {\n      // `import {type as ,` or `import {type as }`\n    } else {\n      // `import {type as foo`\n      parseIdentifier();\n    }\n  } else {\n    if (isTypeKeyword && (match(tt.name) || !!(state.type & TokenType.IS_KEYWORD))) {\n      // `import {type foo`\n      parseIdentifier();\n    }\n    if (eatContextual(ContextualKeyword._as)) {\n      parseIdentifier();\n    }\n  }\n}\n\n// parse function type parameters - function foo<T>() {}\nexport function flowStartParseFunctionParams() {\n  // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon\n  // anyway, so don't try to propagate that information.\n  if (match(tt.lessThan)) {\n    const oldIsType = pushTypeContext(0);\n    flowParseTypeParameterDeclaration();\n    popTypeContext(oldIsType);\n  }\n}\n\n// parse flow type annotations on variable declarator heads - let foo: string = bar\nexport function flowAfterParseVarHead() {\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n}\n\n// parse the return type of an async arrow function - let foo = (async (): number => {});\nexport function flowStartParseAsyncArrowFromCallExpression() {\n  if (match(tt.colon)) {\n    const oldNoAnonFunctionType = state.noAnonFunctionType;\n    state.noAnonFunctionType = true;\n    flowParseTypeAnnotation();\n    state.noAnonFunctionType = oldNoAnonFunctionType;\n  }\n}\n\n// We need to support type parameter declarations for arrow functions. This\n// is tricky. There are three situations we need to handle\n//\n// 1. This is either JSX or an arrow function. We'll try JSX first. If that\n//    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n//    error.\n// 2. This is an arrow function. We'll parse the type parameter declaration,\n//    parse the rest, make sure the rest is an arrow function, and go from\n//    there\n// 3. This is neither. Just call the super method\nexport function flowParseMaybeAssign(noIn, isWithinParens) {\n  if (match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n      state.type = tt.typeParameterStart;\n    } else {\n      return wasArrow;\n    }\n\n    const oldIsType = pushTypeContext(0);\n    flowParseTypeParameterDeclaration();\n    popTypeContext(oldIsType);\n    wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n    if (wasArrow) {\n      return true;\n    }\n    unexpected();\n  }\n\n  return baseParseMaybeAssign(noIn, isWithinParens);\n}\n\n// handle return types for arrow functions\nexport function flowParseArrow() {\n  if (match(tt.colon)) {\n    const oldIsType = pushTypeContext(0);\n    const snapshot = state.snapshot();\n\n    const oldNoAnonFunctionType = state.noAnonFunctionType;\n    state.noAnonFunctionType = true;\n    flowParseTypeAndPredicateInitialiser();\n    state.noAnonFunctionType = oldNoAnonFunctionType;\n\n    if (canInsertSemicolon()) unexpected();\n    if (!match(tt.arrow)) unexpected();\n\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n    popTypeContext(oldIsType);\n  }\n  return eat(tt.arrow);\n}\n\nexport function flowParseSubscripts(startTokenIndex, noCalls = false) {\n  if (\n    state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async &&\n    match(tt.lessThan)\n  ) {\n    const snapshot = state.snapshot();\n    const wasArrow = parseAsyncArrowWithTypeParameters();\n    if (wasArrow && !state.error) {\n      return;\n    }\n    state.restoreFromSnapshot(snapshot);\n  }\n\n  baseParseSubscripts(startTokenIndex, noCalls);\n}\n\n// Returns true if there was an arrow function here.\nfunction parseAsyncArrowWithTypeParameters() {\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  parseFunctionParams();\n  if (!parseArrow()) {\n    return false;\n  }\n  parseArrowExpression(startTokenIndex);\n  return true;\n}\n\nfunction flowParseEnumDeclaration() {\n  expectContextual(ContextualKeyword._enum);\n  state.tokens[state.tokens.length - 1].type = tt._enum;\n  parseIdentifier();\n  flowParseEnumBody();\n}\n\nfunction flowParseEnumBody() {\n  if (eatContextual(ContextualKeyword._of)) {\n    next();\n  }\n  expect(tt.braceL);\n  flowParseEnumMembers();\n  expect(tt.braceR);\n}\n\nfunction flowParseEnumMembers() {\n  while (!match(tt.braceR) && !state.error) {\n    if (eat(tt.ellipsis)) {\n      break;\n    }\n    flowParseEnumMember();\n    if (!match(tt.braceR)) {\n      expect(tt.comma);\n    }\n  }\n}\n\nfunction flowParseEnumMember() {\n  parseIdentifier();\n  if (eat(tt.eq)) {\n    // Flow enum values are always just one token (a string, number, or boolean literal).\n    next();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}