{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/set-array'), require('@jridgewell/sourcemap-codec'), require('@jridgewell/trace-mapping')) : typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/set-array', '@jridgewell/sourcemap-codec', '@jridgewell/trace-mapping'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.genMapping = {}, global.setArray, global.sourcemapCodec, global.traceMapping));\n})(this, function (exports, setArray, sourcemapCodec, traceMapping) {\n  'use strict';\n\n  const COLUMN = 0;\n  const SOURCES_INDEX = 1;\n  const SOURCE_LINE = 2;\n  const SOURCE_COLUMN = 3;\n  const NAMES_INDEX = 4;\n  const NO_NAME = -1;\n  /**\n   * A low-level API to associate a generated position with an original source position. Line and\n   * column here are 0-based, unlike `addMapping`.\n   */\n  exports.addSegment = void 0;\n  /**\n   * A high-level API to associate a generated position with an original source position. Line is\n   * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n   */\n  exports.addMapping = void 0;\n  /**\n   * Same as `addSegment`, but will only add the segment if it generates useful information in the\n   * resulting map. This only works correctly if segments are added **in order**, meaning you should\n   * not add a segment with a lower generated line/column than one that came before.\n   */\n  exports.maybeAddSegment = void 0;\n  /**\n   * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n   * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n   * not add a mapping with a lower generated line/column than one that came before.\n   */\n  exports.maybeAddMapping = void 0;\n  /**\n   * Adds/removes the content of the source file to the source map.\n   */\n  exports.setSourceContent = void 0;\n  /**\n   * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n  exports.toDecodedMap = void 0;\n  /**\n   * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n  exports.toEncodedMap = void 0;\n  /**\n   * Constructs a new GenMapping, using the already present mappings of the input.\n   */\n  exports.fromMap = void 0;\n  /**\n   * Returns an array of high-level mapping objects for every recorded segment, which could then be\n   * passed to the `source-map` library.\n   */\n  exports.allMappings = void 0;\n  // This split declaration is only so that terser can elminiate the static initialization block.\n  let addSegmentInternal;\n  /**\n   * Provides the state to generate a sourcemap.\n   */\n  class GenMapping {\n    constructor() {\n      let {\n        file,\n        sourceRoot\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this._names = new setArray.SetArray();\n      this._sources = new setArray.SetArray();\n      this._sourcesContent = [];\n      this._mappings = [];\n      this.file = file;\n      this.sourceRoot = sourceRoot;\n    }\n  }\n  (() => {\n    exports.addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n      return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n    };\n    exports.maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n      return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n    };\n    exports.addMapping = (map, mapping) => {\n      return addMappingInternal(false, map, mapping);\n    };\n    exports.maybeAddMapping = (map, mapping) => {\n      return addMappingInternal(true, map, mapping);\n    };\n    exports.setSourceContent = (map, source, content) => {\n      const {\n        _sources: sources,\n        _sourcesContent: sourcesContent\n      } = map;\n      sourcesContent[setArray.put(sources, source)] = content;\n    };\n    exports.toDecodedMap = map => {\n      const {\n        file,\n        sourceRoot,\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names\n      } = map;\n      removeEmptyFinalLines(mappings);\n      return {\n        version: 3,\n        file: file || undefined,\n        names: names.array,\n        sourceRoot: sourceRoot || undefined,\n        sources: sources.array,\n        sourcesContent,\n        mappings\n      };\n    };\n    exports.toEncodedMap = map => {\n      const decoded = exports.toDecodedMap(map);\n      return Object.assign(Object.assign({}, decoded), {\n        mappings: sourcemapCodec.encode(decoded.mappings)\n      });\n    };\n    exports.allMappings = map => {\n      const out = [];\n      const {\n        _mappings: mappings,\n        _sources: sources,\n        _names: names\n      } = map;\n      for (let i = 0; i < mappings.length; i++) {\n        const line = mappings[i];\n        for (let j = 0; j < line.length; j++) {\n          const seg = line[j];\n          const generated = {\n            line: i + 1,\n            column: seg[COLUMN]\n          };\n          let source = undefined;\n          let original = undefined;\n          let name = undefined;\n          if (seg.length !== 1) {\n            source = sources.array[seg[SOURCES_INDEX]];\n            original = {\n              line: seg[SOURCE_LINE] + 1,\n              column: seg[SOURCE_COLUMN]\n            };\n            if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n          }\n          out.push({\n            generated,\n            source,\n            original,\n            name\n          });\n        }\n      }\n      return out;\n    };\n    exports.fromMap = input => {\n      const map = new traceMapping.TraceMap(input);\n      const gen = new GenMapping({\n        file: map.file,\n        sourceRoot: map.sourceRoot\n      });\n      putAll(gen._names, map.names);\n      putAll(gen._sources, map.sources);\n      gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n      gen._mappings = traceMapping.decodedMappings(map);\n      return gen;\n    };\n    // Internal helpers\n    addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n      const {\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names\n      } = map;\n      const line = getLine(mappings, genLine);\n      const index = getColumnIndex(line, genColumn);\n      if (!source) {\n        if (skipable && skipSourceless(line, index)) return;\n        return insert(line, index, [genColumn]);\n      }\n      const sourcesIndex = setArray.put(sources, source);\n      const namesIndex = name ? setArray.put(names, name) : NO_NAME;\n      if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;\n      if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n        return;\n      }\n      return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n    };\n  })();\n  function getLine(mappings, index) {\n    for (let i = mappings.length; i <= index; i++) {\n      mappings[i] = [];\n    }\n    return mappings[index];\n  }\n  function getColumnIndex(line, genColumn) {\n    let index = line.length;\n    for (let i = index - 1; i >= 0; index = i--) {\n      const current = line[i];\n      if (genColumn >= current[COLUMN]) break;\n    }\n    return index;\n  }\n  function insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n      array[i] = array[i - 1];\n    }\n    array[index] = value;\n  }\n  function removeEmptyFinalLines(mappings) {\n    const {\n      length\n    } = mappings;\n    let len = length;\n    for (let i = len - 1; i >= 0; len = i, i--) {\n      if (mappings[i].length > 0) break;\n    }\n    if (len < length) mappings.length = len;\n  }\n  function putAll(strarr, array) {\n    for (let i = 0; i < array.length; i++) setArray.put(strarr, array[i]);\n  }\n  function skipSourceless(line, index) {\n    // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n    // doesn't generate any useful information.\n    if (index === 0) return true;\n    const prev = line[index - 1];\n    // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n    // genrate any new information. Else, this segment will end the source/named segment and point to\n    // a sourceless position, which is useful.\n    return prev.length === 1;\n  }\n  function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n    // A source/named segment at the start of a line gives position at that genColumn\n    if (index === 0) return false;\n    const prev = line[index - 1];\n    // If the previous segment is sourceless, then we're transitioning to a source.\n    if (prev.length === 1) return false;\n    // If the previous segment maps to the exact same source position, then this segment doesn't\n    // provide any new position information.\n    return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);\n  }\n  function addMappingInternal(skipable, map, mapping) {\n    const {\n      generated,\n      source,\n      original,\n      name,\n      content\n    } = mapping;\n    if (!source) {\n      return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);\n    }\n    const s = source;\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name, content);\n  }\n  exports.GenMapping = GenMapping;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","NO_NAME","exports","addSegment","addMapping","maybeAddSegment","maybeAddMapping","setSourceContent","toDecodedMap","toEncodedMap","fromMap","allMappings","addSegmentInternal","GenMapping","constructor","file","sourceRoot","arguments","length","undefined","_names","setArray","SetArray","_sources","_sourcesContent","_mappings","map","genLine","genColumn","source","sourceLine","sourceColumn","name","content","mapping","addMappingInternal","sources","sourcesContent","put","mappings","names","removeEmptyFinalLines","version","array","decoded","Object","assign","sourcemapCodec","encode","out","i","line","j","seg","generated","column","original","push","input","traceMapping","TraceMap","gen","putAll","decodedMappings","skipable","getLine","index","getColumnIndex","skipSourceless","insert","sourcesIndex","namesIndex","skipSource","current","value","len","strarr","prev","s"],"sources":["/Users/manan/Desktop/hach-unicorn/StockSure/frontend1/node_modules/@jridgewell/gen-mapping/src/sourcemap-segment.ts","/Users/manan/Desktop/hach-unicorn/StockSure/frontend1/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts"],"sourcesContent":["type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n","import { SetArray, put } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\n\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type { SourceMapInput } from '@jridgewell/trace-mapping';\nimport type { SourceMapSegment } from './sourcemap-segment';\nimport type { DecodedSourceMap, EncodedSourceMap, Pos, Mapping } from './types';\n\nexport type { DecodedSourceMap, EncodedSourceMap, Mapping };\n\nexport type Options = {\n  file?: string | null;\n  sourceRoot?: string | null;\n};\n\nconst NO_NAME = -1;\n\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nexport let addSegment: {\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source?: null,\n    sourceLine?: null,\n    sourceColumn?: null,\n    name?: null,\n    content?: null,\n  ): void;\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source: string,\n    sourceLine: number,\n    sourceColumn: number,\n    name?: null,\n    content?: string | null,\n  ): void;\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source: string,\n    sourceLine: number,\n    sourceColumn: number,\n    name: string,\n    content?: string | null,\n  ): void;\n};\n\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nexport let addMapping: {\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source?: null;\n      original?: null;\n      name?: null;\n      content?: null;\n    },\n  ): void;\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source: string;\n      original: Pos;\n      name?: null;\n      content?: string | null;\n    },\n  ): void;\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source: string;\n      original: Pos;\n      name: string;\n      content?: string | null;\n    },\n  ): void;\n};\n\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nexport let maybeAddSegment: typeof addSegment;\n\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nexport let maybeAddMapping: typeof addMapping;\n\n/**\n * Adds/removes the content of the source file to the source map.\n */\nexport let setSourceContent: (map: GenMapping, source: string, content: string | null) => void;\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let toDecodedMap: (map: GenMapping) => DecodedSourceMap;\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let toEncodedMap: (map: GenMapping) => EncodedSourceMap;\n\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nexport let fromMap: (input: SourceMapInput) => GenMapping;\n\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nexport let allMappings: (map: GenMapping) => Mapping[];\n\n// This split declaration is only so that terser can elminiate the static initialization block.\nlet addSegmentInternal: <S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: S,\n  sourceLine: S extends string ? number : null | undefined,\n  sourceColumn: S extends string ? number : null | undefined,\n  name: S extends string ? string | null | undefined : null | undefined,\n  content: S extends string ? string | null | undefined : null | undefined,\n) => void;\n\n/**\n * Provides the state to generate a sourcemap.\n */\nexport class GenMapping {\n  private _names = new SetArray();\n  private _sources = new SetArray();\n  private _sourcesContent: (string | null)[] = [];\n  private _mappings: SourceMapSegment[][] = [];\n  declare file: string | null | undefined;\n  declare sourceRoot: string | null | undefined;\n\n  constructor({ file, sourceRoot }: Options = {}) {\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n  }\n\n  static {\n    addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n      return addSegmentInternal(\n        false,\n        map,\n        genLine,\n        genColumn,\n        source,\n        sourceLine,\n        sourceColumn,\n        name,\n        content,\n      );\n    };\n\n    maybeAddSegment = (\n      map,\n      genLine,\n      genColumn,\n      source,\n      sourceLine,\n      sourceColumn,\n      name,\n      content,\n    ) => {\n      return addSegmentInternal(\n        true,\n        map,\n        genLine,\n        genColumn,\n        source,\n        sourceLine,\n        sourceColumn,\n        name,\n        content,\n      );\n    };\n\n    addMapping = (map, mapping) => {\n      return addMappingInternal(false, map, mapping as Parameters<typeof addMappingInternal>[2]);\n    };\n\n    maybeAddMapping = (map, mapping) => {\n      return addMappingInternal(true, map, mapping as Parameters<typeof addMappingInternal>[2]);\n    };\n\n    setSourceContent = (map, source, content) => {\n      const { _sources: sources, _sourcesContent: sourcesContent } = map;\n      sourcesContent[put(sources, source)] = content;\n    };\n\n    toDecodedMap = (map) => {\n      const {\n        file,\n        sourceRoot,\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names,\n      } = map;\n      removeEmptyFinalLines(mappings);\n\n      return {\n        version: 3,\n        file: file || undefined,\n        names: names.array,\n        sourceRoot: sourceRoot || undefined,\n        sources: sources.array,\n        sourcesContent,\n        mappings,\n      };\n    };\n\n    toEncodedMap = (map) => {\n      const decoded = toDecodedMap(map);\n      return {\n        ...decoded,\n        mappings: encode(decoded.mappings as SourceMapSegment[][]),\n      };\n    };\n\n    allMappings = (map) => {\n      const out: Mapping[] = [];\n      const { _mappings: mappings, _sources: sources, _names: names } = map;\n\n      for (let i = 0; i < mappings.length; i++) {\n        const line = mappings[i];\n        for (let j = 0; j < line.length; j++) {\n          const seg = line[j];\n\n          const generated = { line: i + 1, column: seg[COLUMN] };\n          let source: string | undefined = undefined;\n          let original: Pos | undefined = undefined;\n          let name: string | undefined = undefined;\n\n          if (seg.length !== 1) {\n            source = sources.array[seg[SOURCES_INDEX]];\n            original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n\n            if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n          }\n\n          out.push({ generated, source, original, name } as Mapping);\n        }\n      }\n\n      return out;\n    };\n\n    fromMap = (input) => {\n      const map = new TraceMap(input);\n      const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n\n      putAll(gen._names, map.names);\n      putAll(gen._sources, map.sources as string[]);\n      gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n      gen._mappings = decodedMappings(map) as GenMapping['_mappings'];\n\n      return gen;\n    };\n\n    // Internal helpers\n    addSegmentInternal = (\n      skipable,\n      map,\n      genLine,\n      genColumn,\n      source,\n      sourceLine,\n      sourceColumn,\n      name,\n      content,\n    ) => {\n      const {\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names,\n      } = map;\n      const line = getLine(mappings, genLine);\n      const index = getColumnIndex(line, genColumn);\n\n      if (!source) {\n        if (skipable && skipSourceless(line, index)) return;\n        return insert(line, index, [genColumn]);\n      }\n\n      // Sigh, TypeScript can't figure out sourceLine and sourceColumn aren't nullish if source\n      // isn't nullish.\n      assert<number>(sourceLine);\n      assert<number>(sourceColumn);\n\n      const sourcesIndex = put(sources, source);\n      const namesIndex = name ? put(names, name) : NO_NAME;\n      if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content ?? null;\n\n      if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n        return;\n      }\n\n      return insert(\n        line,\n        index,\n        name\n          ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n          : [genColumn, sourcesIndex, sourceLine, sourceColumn],\n      );\n    };\n  }\n}\n\nfunction assert<T>(_val: unknown): asserts _val is T {\n  // noop.\n}\n\nfunction getLine(mappings: SourceMapSegment[][], index: number): SourceMapSegment[] {\n  for (let i = mappings.length; i <= index; i++) {\n    mappings[i] = [];\n  }\n  return mappings[index];\n}\n\nfunction getColumnIndex(line: SourceMapSegment[], genColumn: number): number {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; index = i--) {\n    const current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n  return index;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\nfunction removeEmptyFinalLines(mappings: SourceMapSegment[][]) {\n  const { length } = mappings;\n  let len = length;\n  for (let i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n  if (len < length) mappings.length = len;\n}\n\nfunction putAll(strarr: SetArray, array: string[]) {\n  for (let i = 0; i < array.length; i++) put(strarr, array[i]);\n}\n\nfunction skipSourceless(line: SourceMapSegment[], index: number): boolean {\n  // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n  // doesn't generate any useful information.\n  if (index === 0) return true;\n\n  const prev = line[index - 1];\n  // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n  // genrate any new information. Else, this segment will end the source/named segment and point to\n  // a sourceless position, which is useful.\n  return prev.length === 1;\n}\n\nfunction skipSource(\n  line: SourceMapSegment[],\n  index: number,\n  sourcesIndex: number,\n  sourceLine: number,\n  sourceColumn: number,\n  namesIndex: number,\n): boolean {\n  // A source/named segment at the start of a line gives position at that genColumn\n  if (index === 0) return false;\n\n  const prev = line[index - 1];\n\n  // If the previous segment is sourceless, then we're transitioning to a source.\n  if (prev.length === 1) return false;\n\n  // If the previous segment maps to the exact same source position, then this segment doesn't\n  // provide any new position information.\n  return (\n    sourcesIndex === prev[SOURCES_INDEX] &&\n    sourceLine === prev[SOURCE_LINE] &&\n    sourceColumn === prev[SOURCE_COLUMN] &&\n    namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME)\n  );\n}\n\nfunction addMappingInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: S;\n    original: S extends string ? Pos : null | undefined;\n    name: S extends string ? string | null | undefined : null | undefined;\n    content: S extends string ? string | null | undefined : null | undefined;\n  },\n) {\n  const { generated, source, original, name, content } = mapping;\n  if (!source) {\n    return addSegmentInternal(\n      skipable,\n      map,\n      generated.line - 1,\n      generated.column,\n      null,\n      null,\n      null,\n      null,\n      null,\n    );\n  }\n  const s: string = source;\n  assert<Pos>(original);\n  return addSegmentInternal(\n    skipable,\n    map,\n    generated.line - 1,\n    generated.column,\n    s,\n    original.line - 1,\n    original.column,\n    name,\n    content,\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}