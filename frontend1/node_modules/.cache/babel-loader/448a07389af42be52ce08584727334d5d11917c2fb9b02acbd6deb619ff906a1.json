{"ast":null,"code":"import { IdentifierRole, isDeclaration, isObjectShorthandDeclaration } from \"../parser/tokenizer\";\nimport { ContextualKeyword } from \"../parser/tokenizer/keywords\";\nimport { TokenType as tt } from \"../parser/tokenizer/types\";\nimport elideImportEquals from \"../util/elideImportEquals\";\nimport getDeclarationInfo, { EMPTY_DECLARATION_INFO } from \"../util/getDeclarationInfo\";\nimport getImportExportSpecifierInfo from \"../util/getImportExportSpecifierInfo\";\nimport { removeMaybeImportAssertion } from \"../util/removeMaybeImportAssertion\";\nimport shouldElideDefaultExport from \"../util/shouldElideDefaultExport\";\nimport Transformer from \"./Transformer\";\n\n/**\n * Class for editing import statements when we are transforming to commonjs.\n */\nexport default class CJSImportTransformer extends Transformer {\n  __init() {\n    this.hadExport = false;\n  }\n  __init2() {\n    this.hadNamedExport = false;\n  }\n  __init3() {\n    this.hadDefaultExport = false;\n  }\n  constructor(rootTransformer, tokens, importProcessor, nameManager, helperManager, reactHotLoaderTransformer, enableLegacyBabel5ModuleInterop, enableLegacyTypeScriptModuleInterop, isTypeScriptTransformEnabled, preserveDynamicImport) {\n    super();\n    this.rootTransformer = rootTransformer;\n    this.tokens = tokens;\n    this.importProcessor = importProcessor;\n    this.nameManager = nameManager;\n    this.helperManager = helperManager;\n    this.reactHotLoaderTransformer = reactHotLoaderTransformer;\n    this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;\n    this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;\n    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;\n    this.preserveDynamicImport = preserveDynamicImport;\n    CJSImportTransformer.prototype.__init.call(this);\n    CJSImportTransformer.prototype.__init2.call(this);\n    CJSImportTransformer.prototype.__init3.call(this);\n    ;\n    this.declarationInfo = isTypeScriptTransformEnabled ? getDeclarationInfo(tokens) : EMPTY_DECLARATION_INFO;\n  }\n  getPrefixCode() {\n    let prefix = \"\";\n    if (this.hadExport) {\n      prefix += 'Object.defineProperty(exports, \"__esModule\", {value: true});';\n    }\n    return prefix;\n  }\n  getSuffixCode() {\n    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {\n      return \"\\nmodule.exports = exports.default;\\n\";\n    }\n    return \"\";\n  }\n  process() {\n    // TypeScript `import foo = require('foo');` should always just be translated to plain require.\n    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {\n      return this.processImportEquals();\n    }\n    if (this.tokens.matches1(tt._import)) {\n      this.processImport();\n      return true;\n    }\n    if (this.tokens.matches2(tt._export, tt.eq)) {\n      this.tokens.replaceToken(\"module.exports\");\n      return true;\n    }\n    if (this.tokens.matches1(tt._export) && !this.tokens.currentToken().isType) {\n      this.hadExport = true;\n      return this.processExport();\n    }\n    if (this.tokens.matches2(tt.name, tt.postIncDec)) {\n      // Fall through to normal identifier matching if this doesn't apply.\n      if (this.processPostIncDec()) {\n        return true;\n      }\n    }\n    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.jsxName)) {\n      return this.processIdentifier();\n    }\n    if (this.tokens.matches1(tt.eq)) {\n      return this.processAssignment();\n    }\n    if (this.tokens.matches1(tt.assign)) {\n      return this.processComplexAssignment();\n    }\n    if (this.tokens.matches1(tt.preIncDec)) {\n      return this.processPreIncDec();\n    }\n    return false;\n  }\n  processImportEquals() {\n    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    if (this.importProcessor.isTypeName(importName)) {\n      // If this name is only used as a type, elide the whole import.\n      elideImportEquals(this.tokens);\n    } else {\n      // Otherwise, switch `import` to `const`.\n      this.tokens.replaceToken(\"const\");\n    }\n    return true;\n  }\n\n  /**\n   * Transform this:\n   * import foo, {bar} from 'baz';\n   * into\n   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);\n   *\n   * The import code was already generated in the import preprocessing step, so\n   * we just need to look it up.\n   */\n  processImport() {\n    if (this.tokens.matches2(tt._import, tt.parenL)) {\n      if (this.preserveDynamicImport) {\n        // Bail out, only making progress for this one token.\n        this.tokens.copyToken();\n        return;\n      }\n      const requireWrapper = this.enableLegacyTypeScriptModuleInterop ? \"\" : `${this.helperManager.getHelperName(\"interopRequireWildcard\")}(`;\n      this.tokens.replaceToken(`Promise.resolve().then(() => ${requireWrapper}require`);\n      const contextId = this.tokens.currentToken().contextId;\n      if (contextId == null) {\n        throw new Error(\"Expected context ID on dynamic import invocation.\");\n      }\n      this.tokens.copyToken();\n      while (!this.tokens.matchesContextIdAndLabel(tt.parenR, contextId)) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.replaceToken(requireWrapper ? \")))\" : \"))\");\n      return;\n    }\n    const wasOnlyTypes = this.removeImportAndDetectIfType();\n    if (wasOnlyTypes) {\n      this.tokens.removeToken();\n    } else {\n      const path = this.tokens.stringValue();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n      this.tokens.appendCode(this.importProcessor.claimImportCode(path));\n    }\n    removeMaybeImportAssertion(this.tokens);\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n  /**\n   * Erase this import, and return true if it was either of the form \"import type\" or contained only\n   * \"type\" named imports. Such imports should not even do a side-effect import.\n   *\n   * The position should end at the import string.\n   */\n  removeImportAndDetectIfType() {\n    this.tokens.removeInitialToken();\n    if (this.tokens.matchesContextual(ContextualKeyword._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)) {\n      // This is an \"import type\" statement, so exit early.\n      this.removeRemainingImport();\n      return true;\n    }\n    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.star)) {\n      // We have a default import or namespace import, so there must be some\n      // non-type import.\n      this.removeRemainingImport();\n      return false;\n    }\n    if (this.tokens.matches1(tt.string)) {\n      // This is a bare import, so we should proceed with the import.\n      return false;\n    }\n    let foundNonType = false;\n    while (!this.tokens.matches1(tt.string)) {\n      // Check if any named imports are of the form \"foo\" or \"foo as bar\", with\n      // no leading \"type\".\n      if (!foundNonType && this.tokens.matches1(tt.braceL) || this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n        if (this.tokens.matches2(tt.name, tt.comma) || this.tokens.matches2(tt.name, tt.braceR) || this.tokens.matches4(tt.name, tt.name, tt.name, tt.comma) || this.tokens.matches4(tt.name, tt.name, tt.name, tt.braceR)) {\n          foundNonType = true;\n        }\n      }\n      this.tokens.removeToken();\n    }\n    return !foundNonType;\n  }\n  removeRemainingImport() {\n    while (!this.tokens.matches1(tt.string)) {\n      this.tokens.removeToken();\n    }\n  }\n  processIdentifier() {\n    const token = this.tokens.currentToken();\n    if (token.shadowsGlobal) {\n      return false;\n    }\n    if (token.identifierRole === IdentifierRole.ObjectShorthand) {\n      return this.processObjectShorthand();\n    }\n    if (token.identifierRole !== IdentifierRole.Access) {\n      return false;\n    }\n    const replacement = this.importProcessor.getIdentifierReplacement(this.tokens.identifierNameForToken(token));\n    if (!replacement) {\n      return false;\n    }\n    // Tolerate any number of closing parens while looking for an opening paren\n    // that indicates a function call.\n    let possibleOpenParenIndex = this.tokens.currentIndex() + 1;\n    while (possibleOpenParenIndex < this.tokens.tokens.length && this.tokens.tokens[possibleOpenParenIndex].type === tt.parenR) {\n      possibleOpenParenIndex++;\n    }\n    // Avoid treating imported functions as methods of their `exports` object\n    // by using `(0, f)` when the identifier is in a paren expression. Else\n    // use `Function.prototype.call` when the identifier is a guaranteed\n    // function call. When using `call`, pass undefined as the context.\n    if (this.tokens.tokens[possibleOpenParenIndex].type === tt.parenL) {\n      if (this.tokens.tokenAtRelativeIndex(1).type === tt.parenL && this.tokens.tokenAtRelativeIndex(-1).type !== tt._new) {\n        this.tokens.replaceToken(`${replacement}.call(void 0, `);\n        // Remove the old paren.\n        this.tokens.removeToken();\n        // Balance out the new paren.\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(tt.parenR);\n      } else {\n        // See here: http://2ality.com/2015/12/references.html\n        this.tokens.replaceToken(`(0, ${replacement})`);\n      }\n    } else {\n      this.tokens.replaceToken(replacement);\n    }\n    return true;\n  }\n  processObjectShorthand() {\n    const identifier = this.tokens.identifierName();\n    const replacement = this.importProcessor.getIdentifierReplacement(identifier);\n    if (!replacement) {\n      return false;\n    }\n    this.tokens.replaceToken(`${identifier}: ${replacement}`);\n    return true;\n  }\n  processExport() {\n    if (this.tokens.matches2(tt._export, tt._enum) || this.tokens.matches3(tt._export, tt._const, tt._enum)) {\n      // Let the TypeScript transform handle it.\n      return false;\n    }\n    if (this.tokens.matches2(tt._export, tt._default)) {\n      this.hadDefaultExport = true;\n      if (this.tokens.matches3(tt._export, tt._default, tt._enum)) {\n        // Flow export default enums need some special handling, so handle them\n        // in that tranform rather than this one.\n        return false;\n      }\n      this.processExportDefault();\n      return true;\n    }\n    this.hadNamedExport = true;\n    if (this.tokens.matches2(tt._export, tt._var) || this.tokens.matches2(tt._export, tt._let) || this.tokens.matches2(tt._export, tt._const)) {\n      this.processExportVar();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt._function) ||\n    // export async function\n    this.tokens.matches3(tt._export, tt.name, tt._function)) {\n      this.processExportFunction();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt._class) || this.tokens.matches3(tt._export, tt._abstract, tt._class) || this.tokens.matches2(tt._export, tt.at)) {\n      this.processExportClass();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt.braceL)) {\n      this.processExportBindings();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt.star)) {\n      this.processExportStar();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {\n      // export type {a};\n      // export type {a as b};\n      // export type {a} from './b';\n      // export type * from './b';\n      // export type * as ns from './b';\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      if (this.tokens.matches1(tt.braceL)) {\n        while (!this.tokens.matches1(tt.braceR)) {\n          this.tokens.removeToken();\n        }\n        this.tokens.removeToken();\n      } else {\n        // *\n        this.tokens.removeToken();\n        if (this.tokens.matches1(tt._as)) {\n          // as\n          this.tokens.removeToken();\n          // ns\n          this.tokens.removeToken();\n        }\n      }\n      // Remove type re-export `... } from './T'`\n      if (this.tokens.matchesContextual(ContextualKeyword._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        removeMaybeImportAssertion(this.tokens);\n      }\n      return true;\n    } else {\n      throw new Error(\"Unrecognized export syntax.\");\n    }\n  }\n  processAssignment() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index - 1];\n    // If the LHS is a type identifier, this must be a declaration like `let a: b = c;`,\n    // with `b` as the identifier, so nothing needs to be done in that case.\n    if (identifierToken.isType || identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {\n      return false;\n    }\n    if (index >= 2 && [tt._var, tt._let, tt._const].includes(this.tokens.tokens[index - 2].type)) {\n      // Declarations don't need an extra assignment. This doesn't avoid the\n      // assignment for comma-separated declarations, but it's still correct\n      // since the assignment is just redundant.\n      return false;\n    }\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(identifierToken));\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.copyToken();\n    this.tokens.appendCode(` ${assignmentSnippet} =`);\n    return true;\n  }\n\n  /**\n   * Process something like `a += 3`, where `a` might be an exported value.\n   */\n  processComplexAssignment() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index - 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {\n      return false;\n    }\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(identifierToken));\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.appendCode(` = ${assignmentSnippet}`);\n    this.tokens.copyToken();\n    return true;\n  }\n\n  /**\n   * Process something like `++a`, where `a` might be an exported value.\n   */\n  processPreIncDec() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index + 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    // Ignore things like ++a.b and ++a[b] and ++a().b.\n    if (index + 2 < this.tokens.tokens.length && (this.tokens.matches1AtIndex(index + 2, tt.dot) || this.tokens.matches1AtIndex(index + 2, tt.bracketL) || this.tokens.matches1AtIndex(index + 2, tt.parenL))) {\n      return false;\n    }\n    const identifierName = this.tokens.identifierNameForToken(identifierToken);\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.appendCode(`${assignmentSnippet} = `);\n    this.tokens.copyToken();\n    return true;\n  }\n\n  /**\n   * Process something like `a++`, where `a` might be an exported value.\n   * This starts at the `a`, not at the `++`.\n   */\n  processPostIncDec() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index];\n    const operatorToken = this.tokens.tokens[index + 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 1 && this.tokens.matches1AtIndex(index - 1, tt.dot)) {\n      return false;\n    }\n    const identifierName = this.tokens.identifierNameForToken(identifierToken);\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);\n    if (!assignmentSnippet) {\n      return false;\n    }\n    const operatorCode = this.tokens.rawCodeForToken(operatorToken);\n    // We might also replace the identifier with something like exports.x, so\n    // do that replacement here as well.\n    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;\n    if (operatorCode === \"++\") {\n      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);\n    } else if (operatorCode === \"--\") {\n      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);\n    } else {\n      throw new Error(`Unexpected operator: ${operatorCode}`);\n    }\n    this.tokens.removeToken();\n    return true;\n  }\n  processExportDefault() {\n    if (this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||\n    // export default async function\n    this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._async)) {\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      // Named function export case: change it to a top-level function\n      // declaration followed by exports statement.\n      const name = this.processNamedFunction();\n      this.tokens.appendCode(` exports.default = ${name};`);\n    } else if (this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) || this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name) || this.tokens.matches3(tt._export, tt._default, tt.at)) {\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.copyDecorators();\n      if (this.tokens.matches1(tt._abstract)) {\n        this.tokens.removeToken();\n      }\n      const name = this.rootTransformer.processNamedClass();\n      this.tokens.appendCode(` exports.default = ${name};`);\n      // After this point, this is a plain \"export default E\" statement.\n    } else if (shouldElideDefaultExport(this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)) {\n      // If the exported value is just an identifier and should be elided by TypeScript\n      // rules, then remove it entirely. It will always have the form `export default e`,\n      // where `e` is an identifier.\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n    } else if (this.reactHotLoaderTransformer) {\n      // We need to assign E to a variable. Change \"export default E\" to\n      // \"let _default; exports.default = _default = E\"\n      const defaultVarName = this.nameManager.claimFreeName(\"_default\");\n      this.tokens.replaceToken(`let ${defaultVarName}; exports.`);\n      this.tokens.copyToken();\n      this.tokens.appendCode(` = ${defaultVarName} =`);\n      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);\n    } else {\n      // Change \"export default E\" to \"exports.default = E\"\n      this.tokens.replaceToken(\"exports.\");\n      this.tokens.copyToken();\n      this.tokens.appendCode(\" =\");\n    }\n  }\n  copyDecorators() {\n    while (this.tokens.matches1(tt.at)) {\n      this.tokens.copyToken();\n      if (this.tokens.matches1(tt.parenL)) {\n        this.tokens.copyExpectedToken(tt.parenL);\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(tt.parenR);\n      } else {\n        this.tokens.copyExpectedToken(tt.name);\n        while (this.tokens.matches1(tt.dot)) {\n          this.tokens.copyExpectedToken(tt.dot);\n          this.tokens.copyExpectedToken(tt.name);\n        }\n        if (this.tokens.matches1(tt.parenL)) {\n          this.tokens.copyExpectedToken(tt.parenL);\n          this.rootTransformer.processBalancedCode();\n          this.tokens.copyExpectedToken(tt.parenR);\n        }\n      }\n    }\n  }\n\n  /**\n   * Transform a declaration like `export var`, `export let`, or `export const`.\n   */\n  processExportVar() {\n    if (this.isSimpleExportVar()) {\n      this.processSimpleExportVar();\n    } else {\n      this.processComplexExportVar();\n    }\n  }\n\n  /**\n   * Determine if the export is of the form:\n   * export var/let/const [varName] = [expr];\n   * In other words, determine if function name inference might apply.\n   */\n  isSimpleExportVar() {\n    let tokenIndex = this.tokens.currentIndex();\n    // export\n    tokenIndex++;\n    // var/let/const\n    tokenIndex++;\n    if (!this.tokens.matches1AtIndex(tokenIndex, tt.name)) {\n      return false;\n    }\n    tokenIndex++;\n    while (tokenIndex < this.tokens.tokens.length && this.tokens.tokens[tokenIndex].isType) {\n      tokenIndex++;\n    }\n    if (!this.tokens.matches1AtIndex(tokenIndex, tt.eq)) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Transform an `export var` declaration initializing a single variable.\n   *\n   * For example, this:\n   * export const f = () => {};\n   * becomes this:\n   * const f = () => {}; exports.f = f;\n   *\n   * The variable is unused (e.g. exports.f has the true value of the export).\n   * We need to produce an assignment of this form so that the function will\n   * have an inferred name of \"f\", which wouldn't happen in the more general\n   * case below.\n   */\n  processSimpleExportVar() {\n    // export\n    this.tokens.removeInitialToken();\n    // var/let/const\n    this.tokens.copyToken();\n    const varName = this.tokens.identifierName();\n    // x: number  ->  x\n    while (!this.tokens.matches1(tt.eq)) {\n      this.rootTransformer.processToken();\n    }\n    const endIndex = this.tokens.currentToken().rhsEndIndex;\n    if (endIndex == null) {\n      throw new Error(\"Expected = token with an end index.\");\n    }\n    while (this.tokens.currentIndex() < endIndex) {\n      this.rootTransformer.processToken();\n    }\n    this.tokens.appendCode(`; exports.${varName} = ${varName}`);\n  }\n\n  /**\n   * Transform normal declaration exports, including handling destructuring.\n   * For example, this:\n   * export const {x: [a = 2, b], c} = d;\n   * becomes this:\n   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)\n   */\n  processComplexExportVar() {\n    this.tokens.removeInitialToken();\n    this.tokens.removeToken();\n    const needsParens = this.tokens.matches1(tt.braceL);\n    if (needsParens) {\n      this.tokens.appendCode(\"(\");\n    }\n    let depth = 0;\n    while (true) {\n      if (this.tokens.matches1(tt.braceL) || this.tokens.matches1(tt.dollarBraceL) || this.tokens.matches1(tt.bracketL)) {\n        depth++;\n        this.tokens.copyToken();\n      } else if (this.tokens.matches1(tt.braceR) || this.tokens.matches1(tt.bracketR)) {\n        depth--;\n        this.tokens.copyToken();\n      } else if (depth === 0 && !this.tokens.matches1(tt.name) && !this.tokens.currentToken().isType) {\n        break;\n      } else if (this.tokens.matches1(tt.eq)) {\n        // Default values might have assignments in the RHS that we want to ignore, so skip past\n        // them.\n        const endIndex = this.tokens.currentToken().rhsEndIndex;\n        if (endIndex == null) {\n          throw new Error(\"Expected = token with an end index.\");\n        }\n        while (this.tokens.currentIndex() < endIndex) {\n          this.rootTransformer.processToken();\n        }\n      } else {\n        const token = this.tokens.currentToken();\n        if (isDeclaration(token)) {\n          const name = this.tokens.identifierName();\n          let replacement = this.importProcessor.getIdentifierReplacement(name);\n          if (replacement === null) {\n            throw new Error(`Expected a replacement for ${name} in \\`export var\\` syntax.`);\n          }\n          if (isObjectShorthandDeclaration(token)) {\n            replacement = `${name}: ${replacement}`;\n          }\n          this.tokens.replaceToken(replacement);\n        } else {\n          this.rootTransformer.processToken();\n        }\n      }\n    }\n    if (needsParens) {\n      // Seek to the end of the RHS.\n      const endIndex = this.tokens.currentToken().rhsEndIndex;\n      if (endIndex == null) {\n        throw new Error(\"Expected = token with an end index.\");\n      }\n      while (this.tokens.currentIndex() < endIndex) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.appendCode(\")\");\n    }\n  }\n\n  /**\n   * Transform this:\n   * export function foo() {}\n   * into this:\n   * function foo() {} exports.foo = foo;\n   */\n  processExportFunction() {\n    this.tokens.replaceToken(\"\");\n    const name = this.processNamedFunction();\n    this.tokens.appendCode(` exports.${name} = ${name};`);\n  }\n\n  /**\n   * Skip past a function with a name and return that name.\n   */\n  processNamedFunction() {\n    if (this.tokens.matches1(tt._function)) {\n      this.tokens.copyToken();\n    } else if (this.tokens.matches2(tt.name, tt._function)) {\n      if (!this.tokens.matchesContextual(ContextualKeyword._async)) {\n        throw new Error(\"Expected async keyword in function export.\");\n      }\n      this.tokens.copyToken();\n      this.tokens.copyToken();\n    }\n    if (this.tokens.matches1(tt.star)) {\n      this.tokens.copyToken();\n    }\n    if (!this.tokens.matches1(tt.name)) {\n      throw new Error(\"Expected identifier for exported function name.\");\n    }\n    const name = this.tokens.identifierName();\n    this.tokens.copyToken();\n    if (this.tokens.currentToken().isType) {\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentToken().isType) {\n        this.tokens.removeToken();\n      }\n    }\n    this.tokens.copyExpectedToken(tt.parenL);\n    this.rootTransformer.processBalancedCode();\n    this.tokens.copyExpectedToken(tt.parenR);\n    this.rootTransformer.processPossibleTypeRange();\n    this.tokens.copyExpectedToken(tt.braceL);\n    this.rootTransformer.processBalancedCode();\n    this.tokens.copyExpectedToken(tt.braceR);\n    return name;\n  }\n\n  /**\n   * Transform this:\n   * export class A {}\n   * into this:\n   * class A {} exports.A = A;\n   */\n  processExportClass() {\n    this.tokens.removeInitialToken();\n    this.copyDecorators();\n    if (this.tokens.matches1(tt._abstract)) {\n      this.tokens.removeToken();\n    }\n    const name = this.rootTransformer.processNamedClass();\n    this.tokens.appendCode(` exports.${name} = ${name};`);\n  }\n\n  /**\n   * Transform this:\n   * export {a, b as c};\n   * into this:\n   * exports.a = a; exports.c = b;\n   *\n   * OR\n   *\n   * Transform this:\n   * export {a, b as c} from './foo';\n   * into the pre-generated Object.defineProperty code from the ImportProcessor.\n   *\n   * For the first case, if the TypeScript transform is enabled, we need to skip\n   * exports that are only defined as types.\n   */\n  processExportBindings() {\n    this.tokens.removeInitialToken();\n    this.tokens.removeToken();\n    const exportStatements = [];\n    while (true) {\n      if (this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n        break;\n      }\n      const specifierInfo = getImportExportSpecifierInfo(this.tokens);\n      while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n        this.tokens.removeToken();\n      }\n      if (!specifierInfo.isType && !this.shouldElideExportedIdentifier(specifierInfo.leftName)) {\n        const localName = specifierInfo.leftName;\n        const exportedName = specifierInfo.rightName;\n        const newLocalName = this.importProcessor.getIdentifierReplacement(localName);\n        exportStatements.push(`exports.${exportedName} = ${newLocalName || localName};`);\n      }\n      if (this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n        break;\n      }\n      if (this.tokens.matches2(tt.comma, tt.braceR)) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        break;\n      } else if (this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n      } else {\n        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);\n      }\n    }\n    if (this.tokens.matchesContextual(ContextualKeyword._from)) {\n      // This is an export...from, so throw away the normal named export code\n      // and use the Object.defineProperty code from ImportProcessor.\n      this.tokens.removeToken();\n      const path = this.tokens.stringValue();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n      removeMaybeImportAssertion(this.tokens);\n    } else {\n      // This is a normal named export, so use that.\n      this.tokens.appendCode(exportStatements.join(\" \"));\n    }\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n  processExportStar() {\n    this.tokens.removeInitialToken();\n    while (!this.tokens.matches1(tt.string)) {\n      this.tokens.removeToken();\n    }\n    const path = this.tokens.stringValue();\n    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n    removeMaybeImportAssertion(this.tokens);\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n  shouldElideExportedIdentifier(name) {\n    return this.isTypeScriptTransformEnabled && !this.declarationInfo.valueDeclarations.has(name);\n  }\n}","map":{"version":3,"names":["IdentifierRole","isDeclaration","isObjectShorthandDeclaration","ContextualKeyword","TokenType","tt","elideImportEquals","getDeclarationInfo","EMPTY_DECLARATION_INFO","getImportExportSpecifierInfo","removeMaybeImportAssertion","shouldElideDefaultExport","Transformer","CJSImportTransformer","__init","hadExport","__init2","hadNamedExport","__init3","hadDefaultExport","constructor","rootTransformer","tokens","importProcessor","nameManager","helperManager","reactHotLoaderTransformer","enableLegacyBabel5ModuleInterop","enableLegacyTypeScriptModuleInterop","isTypeScriptTransformEnabled","preserveDynamicImport","prototype","call","declarationInfo","getPrefixCode","prefix","getSuffixCode","process","matches3","_import","name","eq","processImportEquals","matches1","processImport","matches2","_export","replaceToken","currentToken","isType","processExport","postIncDec","processPostIncDec","jsxName","processIdentifier","processAssignment","assign","processComplexAssignment","preIncDec","processPreIncDec","importName","identifierNameAtIndex","currentIndex","isTypeName","parenL","copyToken","requireWrapper","getHelperName","contextId","Error","matchesContextIdAndLabel","parenR","processToken","wasOnlyTypes","removeImportAndDetectIfType","removeToken","path","stringValue","replaceTokenTrimmingLeftWhitespace","claimImportCode","appendCode","semi","removeInitialToken","matchesContextual","_type","matches1AtIndex","comma","matchesContextualAtIndex","_from","removeRemainingImport","star","string","foundNonType","braceL","braceR","matches4","token","shadowsGlobal","identifierRole","ObjectShorthand","processObjectShorthand","Access","replacement","getIdentifierReplacement","identifierNameForToken","possibleOpenParenIndex","length","type","tokenAtRelativeIndex","_new","processBalancedCode","copyExpectedToken","identifier","identifierName","_enum","_const","_default","processExportDefault","_var","_let","processExportVar","_function","processExportFunction","_class","_abstract","at","processExportClass","processExportBindings","processExportStar","_as","index","identifierToken","dot","includes","assignmentSnippet","resolveExportBinding","bracketL","operatorToken","operatorCode","rawCodeForToken","base","matches5","_async","processNamedFunction","copyDecorators","processNamedClass","defaultVarName","claimFreeName","setExtractedDefaultExportName","isSimpleExportVar","processSimpleExportVar","processComplexExportVar","tokenIndex","varName","endIndex","rhsEndIndex","needsParens","depth","dollarBraceL","bracketR","processPossibleTypeRange","exportStatements","specifierInfo","shouldElideExportedIdentifier","leftName","localName","exportedName","rightName","newLocalName","push","JSON","stringify","join","valueDeclarations","has"],"sources":["/Users/manan/Desktop/hach-unicorn/StockSure/frontend1/node_modules/sucrase/dist/esm/transformers/CJSImportTransformer.js"],"sourcesContent":["\n\n\nimport {IdentifierRole, isDeclaration, isObjectShorthandDeclaration} from \"../parser/tokenizer\";\nimport {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport elideImportEquals from \"../util/elideImportEquals\";\nimport getDeclarationInfo, {\n\n  EMPTY_DECLARATION_INFO,\n} from \"../util/getDeclarationInfo\";\nimport getImportExportSpecifierInfo from \"../util/getImportExportSpecifierInfo\";\nimport {removeMaybeImportAssertion} from \"../util/removeMaybeImportAssertion\";\nimport shouldElideDefaultExport from \"../util/shouldElideDefaultExport\";\n\n\nimport Transformer from \"./Transformer\";\n\n/**\n * Class for editing import statements when we are transforming to commonjs.\n */\nexport default class CJSImportTransformer extends Transformer {\n   __init() {this.hadExport = false}\n   __init2() {this.hadNamedExport = false}\n   __init3() {this.hadDefaultExport = false}\n  \n\n  constructor(\n     rootTransformer,\n     tokens,\n     importProcessor,\n     nameManager,\n     helperManager,\n     reactHotLoaderTransformer,\n     enableLegacyBabel5ModuleInterop,\n     enableLegacyTypeScriptModuleInterop,\n     isTypeScriptTransformEnabled,\n     preserveDynamicImport,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.preserveDynamicImport = preserveDynamicImport;CJSImportTransformer.prototype.__init.call(this);CJSImportTransformer.prototype.__init2.call(this);CJSImportTransformer.prototype.__init3.call(this);;\n    this.declarationInfo = isTypeScriptTransformEnabled\n      ? getDeclarationInfo(tokens)\n      : EMPTY_DECLARATION_INFO;\n  }\n\n  getPrefixCode() {\n    let prefix = \"\";\n    if (this.hadExport) {\n      prefix += 'Object.defineProperty(exports, \"__esModule\", {value: true});';\n    }\n    return prefix;\n  }\n\n  getSuffixCode() {\n    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {\n      return \"\\nmodule.exports = exports.default;\\n\";\n    }\n    return \"\";\n  }\n\n  process() {\n    // TypeScript `import foo = require('foo');` should always just be translated to plain require.\n    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {\n      return this.processImportEquals();\n    }\n    if (this.tokens.matches1(tt._import)) {\n      this.processImport();\n      return true;\n    }\n    if (this.tokens.matches2(tt._export, tt.eq)) {\n      this.tokens.replaceToken(\"module.exports\");\n      return true;\n    }\n    if (this.tokens.matches1(tt._export) && !this.tokens.currentToken().isType) {\n      this.hadExport = true;\n      return this.processExport();\n    }\n    if (this.tokens.matches2(tt.name, tt.postIncDec)) {\n      // Fall through to normal identifier matching if this doesn't apply.\n      if (this.processPostIncDec()) {\n        return true;\n      }\n    }\n    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.jsxName)) {\n      return this.processIdentifier();\n    }\n    if (this.tokens.matches1(tt.eq)) {\n      return this.processAssignment();\n    }\n    if (this.tokens.matches1(tt.assign)) {\n      return this.processComplexAssignment();\n    }\n    if (this.tokens.matches1(tt.preIncDec)) {\n      return this.processPreIncDec();\n    }\n    return false;\n  }\n\n   processImportEquals() {\n    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    if (this.importProcessor.isTypeName(importName)) {\n      // If this name is only used as a type, elide the whole import.\n      elideImportEquals(this.tokens);\n    } else {\n      // Otherwise, switch `import` to `const`.\n      this.tokens.replaceToken(\"const\");\n    }\n    return true;\n  }\n\n  /**\n   * Transform this:\n   * import foo, {bar} from 'baz';\n   * into\n   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);\n   *\n   * The import code was already generated in the import preprocessing step, so\n   * we just need to look it up.\n   */\n   processImport() {\n    if (this.tokens.matches2(tt._import, tt.parenL)) {\n      if (this.preserveDynamicImport) {\n        // Bail out, only making progress for this one token.\n        this.tokens.copyToken();\n        return;\n      }\n      const requireWrapper = this.enableLegacyTypeScriptModuleInterop\n        ? \"\"\n        : `${this.helperManager.getHelperName(\"interopRequireWildcard\")}(`;\n      this.tokens.replaceToken(`Promise.resolve().then(() => ${requireWrapper}require`);\n      const contextId = this.tokens.currentToken().contextId;\n      if (contextId == null) {\n        throw new Error(\"Expected context ID on dynamic import invocation.\");\n      }\n      this.tokens.copyToken();\n      while (!this.tokens.matchesContextIdAndLabel(tt.parenR, contextId)) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.replaceToken(requireWrapper ? \")))\" : \"))\");\n      return;\n    }\n\n    const wasOnlyTypes = this.removeImportAndDetectIfType();\n\n    if (wasOnlyTypes) {\n      this.tokens.removeToken();\n    } else {\n      const path = this.tokens.stringValue();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n      this.tokens.appendCode(this.importProcessor.claimImportCode(path));\n    }\n    removeMaybeImportAssertion(this.tokens);\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n  /**\n   * Erase this import, and return true if it was either of the form \"import type\" or contained only\n   * \"type\" named imports. Such imports should not even do a side-effect import.\n   *\n   * The position should end at the import string.\n   */\n   removeImportAndDetectIfType() {\n    this.tokens.removeInitialToken();\n    if (\n      this.tokens.matchesContextual(ContextualKeyword._type) &&\n      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&\n      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)\n    ) {\n      // This is an \"import type\" statement, so exit early.\n      this.removeRemainingImport();\n      return true;\n    }\n\n    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.star)) {\n      // We have a default import or namespace import, so there must be some\n      // non-type import.\n      this.removeRemainingImport();\n      return false;\n    }\n\n    if (this.tokens.matches1(tt.string)) {\n      // This is a bare import, so we should proceed with the import.\n      return false;\n    }\n\n    let foundNonType = false;\n    while (!this.tokens.matches1(tt.string)) {\n      // Check if any named imports are of the form \"foo\" or \"foo as bar\", with\n      // no leading \"type\".\n      if ((!foundNonType && this.tokens.matches1(tt.braceL)) || this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n        if (\n          this.tokens.matches2(tt.name, tt.comma) ||\n          this.tokens.matches2(tt.name, tt.braceR) ||\n          this.tokens.matches4(tt.name, tt.name, tt.name, tt.comma) ||\n          this.tokens.matches4(tt.name, tt.name, tt.name, tt.braceR)\n        ) {\n          foundNonType = true;\n        }\n      }\n      this.tokens.removeToken();\n    }\n    return !foundNonType;\n  }\n\n   removeRemainingImport() {\n    while (!this.tokens.matches1(tt.string)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   processIdentifier() {\n    const token = this.tokens.currentToken();\n    if (token.shadowsGlobal) {\n      return false;\n    }\n\n    if (token.identifierRole === IdentifierRole.ObjectShorthand) {\n      return this.processObjectShorthand();\n    }\n\n    if (token.identifierRole !== IdentifierRole.Access) {\n      return false;\n    }\n    const replacement = this.importProcessor.getIdentifierReplacement(\n      this.tokens.identifierNameForToken(token),\n    );\n    if (!replacement) {\n      return false;\n    }\n    // Tolerate any number of closing parens while looking for an opening paren\n    // that indicates a function call.\n    let possibleOpenParenIndex = this.tokens.currentIndex() + 1;\n    while (\n      possibleOpenParenIndex < this.tokens.tokens.length &&\n      this.tokens.tokens[possibleOpenParenIndex].type === tt.parenR\n    ) {\n      possibleOpenParenIndex++;\n    }\n    // Avoid treating imported functions as methods of their `exports` object\n    // by using `(0, f)` when the identifier is in a paren expression. Else\n    // use `Function.prototype.call` when the identifier is a guaranteed\n    // function call. When using `call`, pass undefined as the context.\n    if (this.tokens.tokens[possibleOpenParenIndex].type === tt.parenL) {\n      if (\n        this.tokens.tokenAtRelativeIndex(1).type === tt.parenL &&\n        this.tokens.tokenAtRelativeIndex(-1).type !== tt._new\n      ) {\n        this.tokens.replaceToken(`${replacement}.call(void 0, `);\n        // Remove the old paren.\n        this.tokens.removeToken();\n        // Balance out the new paren.\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(tt.parenR);\n      } else {\n        // See here: http://2ality.com/2015/12/references.html\n        this.tokens.replaceToken(`(0, ${replacement})`);\n      }\n    } else {\n      this.tokens.replaceToken(replacement);\n    }\n    return true;\n  }\n\n  processObjectShorthand() {\n    const identifier = this.tokens.identifierName();\n    const replacement = this.importProcessor.getIdentifierReplacement(identifier);\n    if (!replacement) {\n      return false;\n    }\n    this.tokens.replaceToken(`${identifier}: ${replacement}`);\n    return true;\n  }\n\n  processExport() {\n    if (\n      this.tokens.matches2(tt._export, tt._enum) ||\n      this.tokens.matches3(tt._export, tt._const, tt._enum)\n    ) {\n      // Let the TypeScript transform handle it.\n      return false;\n    }\n    if (this.tokens.matches2(tt._export, tt._default)) {\n      this.hadDefaultExport = true;\n      if (this.tokens.matches3(tt._export, tt._default, tt._enum)) {\n        // Flow export default enums need some special handling, so handle them\n        // in that tranform rather than this one.\n        return false;\n      }\n      this.processExportDefault();\n      return true;\n    }\n    this.hadNamedExport = true;\n    if (\n      this.tokens.matches2(tt._export, tt._var) ||\n      this.tokens.matches2(tt._export, tt._let) ||\n      this.tokens.matches2(tt._export, tt._const)\n    ) {\n      this.processExportVar();\n      return true;\n    } else if (\n      this.tokens.matches2(tt._export, tt._function) ||\n      // export async function\n      this.tokens.matches3(tt._export, tt.name, tt._function)\n    ) {\n      this.processExportFunction();\n      return true;\n    } else if (\n      this.tokens.matches2(tt._export, tt._class) ||\n      this.tokens.matches3(tt._export, tt._abstract, tt._class) ||\n      this.tokens.matches2(tt._export, tt.at)\n    ) {\n      this.processExportClass();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt.braceL)) {\n      this.processExportBindings();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt.star)) {\n      this.processExportStar();\n      return true;\n    } else if (\n      this.tokens.matches2(tt._export, tt.name) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)\n    ) {\n      // export type {a};\n      // export type {a as b};\n      // export type {a} from './b';\n      // export type * from './b';\n      // export type * as ns from './b';\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      if (this.tokens.matches1(tt.braceL)) {\n        while (!this.tokens.matches1(tt.braceR)) {\n          this.tokens.removeToken();\n        }\n        this.tokens.removeToken();\n      } else {\n        // *\n        this.tokens.removeToken();\n        if (this.tokens.matches1(tt._as)) {\n          // as\n          this.tokens.removeToken();\n          // ns\n          this.tokens.removeToken();\n        }\n      }\n      // Remove type re-export `... } from './T'`\n      if (\n        this.tokens.matchesContextual(ContextualKeyword._from) &&\n        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)\n      ) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        removeMaybeImportAssertion(this.tokens);\n      }\n      return true;\n    } else {\n      throw new Error(\"Unrecognized export syntax.\");\n    }\n  }\n\n   processAssignment() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index - 1];\n    // If the LHS is a type identifier, this must be a declaration like `let a: b = c;`,\n    // with `b` as the identifier, so nothing needs to be done in that case.\n    if (identifierToken.isType || identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {\n      return false;\n    }\n    if (index >= 2 && [tt._var, tt._let, tt._const].includes(this.tokens.tokens[index - 2].type)) {\n      // Declarations don't need an extra assignment. This doesn't avoid the\n      // assignment for comma-separated declarations, but it's still correct\n      // since the assignment is just redundant.\n      return false;\n    }\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(\n      this.tokens.identifierNameForToken(identifierToken),\n    );\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.copyToken();\n    this.tokens.appendCode(` ${assignmentSnippet} =`);\n    return true;\n  }\n\n  /**\n   * Process something like `a += 3`, where `a` might be an exported value.\n   */\n   processComplexAssignment() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index - 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {\n      return false;\n    }\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(\n      this.tokens.identifierNameForToken(identifierToken),\n    );\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.appendCode(` = ${assignmentSnippet}`);\n    this.tokens.copyToken();\n    return true;\n  }\n\n  /**\n   * Process something like `++a`, where `a` might be an exported value.\n   */\n   processPreIncDec() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index + 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    // Ignore things like ++a.b and ++a[b] and ++a().b.\n    if (\n      index + 2 < this.tokens.tokens.length &&\n      (this.tokens.matches1AtIndex(index + 2, tt.dot) ||\n        this.tokens.matches1AtIndex(index + 2, tt.bracketL) ||\n        this.tokens.matches1AtIndex(index + 2, tt.parenL))\n    ) {\n      return false;\n    }\n    const identifierName = this.tokens.identifierNameForToken(identifierToken);\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.appendCode(`${assignmentSnippet} = `);\n    this.tokens.copyToken();\n    return true;\n  }\n\n  /**\n   * Process something like `a++`, where `a` might be an exported value.\n   * This starts at the `a`, not at the `++`.\n   */\n   processPostIncDec() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index];\n    const operatorToken = this.tokens.tokens[index + 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 1 && this.tokens.matches1AtIndex(index - 1, tt.dot)) {\n      return false;\n    }\n    const identifierName = this.tokens.identifierNameForToken(identifierToken);\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);\n    if (!assignmentSnippet) {\n      return false;\n    }\n    const operatorCode = this.tokens.rawCodeForToken(operatorToken);\n    // We might also replace the identifier with something like exports.x, so\n    // do that replacement here as well.\n    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;\n    if (operatorCode === \"++\") {\n      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);\n    } else if (operatorCode === \"--\") {\n      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);\n    } else {\n      throw new Error(`Unexpected operator: ${operatorCode}`);\n    }\n    this.tokens.removeToken();\n    return true;\n  }\n\n   processExportDefault() {\n    if (\n      this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||\n      // export default async function\n      (this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) &&\n        this.tokens.matchesContextualAtIndex(\n          this.tokens.currentIndex() + 2,\n          ContextualKeyword._async,\n        ))\n    ) {\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      // Named function export case: change it to a top-level function\n      // declaration followed by exports statement.\n      const name = this.processNamedFunction();\n      this.tokens.appendCode(` exports.default = ${name};`);\n    } else if (\n      this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) ||\n      this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name) ||\n      this.tokens.matches3(tt._export, tt._default, tt.at)\n    ) {\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.copyDecorators();\n      if (this.tokens.matches1(tt._abstract)) {\n        this.tokens.removeToken();\n      }\n      const name = this.rootTransformer.processNamedClass();\n      this.tokens.appendCode(` exports.default = ${name};`);\n      // After this point, this is a plain \"export default E\" statement.\n    } else if (\n      shouldElideDefaultExport(this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)\n    ) {\n      // If the exported value is just an identifier and should be elided by TypeScript\n      // rules, then remove it entirely. It will always have the form `export default e`,\n      // where `e` is an identifier.\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n    } else if (this.reactHotLoaderTransformer) {\n      // We need to assign E to a variable. Change \"export default E\" to\n      // \"let _default; exports.default = _default = E\"\n      const defaultVarName = this.nameManager.claimFreeName(\"_default\");\n      this.tokens.replaceToken(`let ${defaultVarName}; exports.`);\n      this.tokens.copyToken();\n      this.tokens.appendCode(` = ${defaultVarName} =`);\n      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);\n    } else {\n      // Change \"export default E\" to \"exports.default = E\"\n      this.tokens.replaceToken(\"exports.\");\n      this.tokens.copyToken();\n      this.tokens.appendCode(\" =\");\n    }\n  }\n\n   copyDecorators() {\n    while (this.tokens.matches1(tt.at)) {\n      this.tokens.copyToken();\n      if (this.tokens.matches1(tt.parenL)) {\n        this.tokens.copyExpectedToken(tt.parenL);\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(tt.parenR);\n      } else {\n        this.tokens.copyExpectedToken(tt.name);\n        while (this.tokens.matches1(tt.dot)) {\n          this.tokens.copyExpectedToken(tt.dot);\n          this.tokens.copyExpectedToken(tt.name);\n        }\n        if (this.tokens.matches1(tt.parenL)) {\n          this.tokens.copyExpectedToken(tt.parenL);\n          this.rootTransformer.processBalancedCode();\n          this.tokens.copyExpectedToken(tt.parenR);\n        }\n      }\n    }\n  }\n\n  /**\n   * Transform a declaration like `export var`, `export let`, or `export const`.\n   */\n   processExportVar() {\n    if (this.isSimpleExportVar()) {\n      this.processSimpleExportVar();\n    } else {\n      this.processComplexExportVar();\n    }\n  }\n\n  /**\n   * Determine if the export is of the form:\n   * export var/let/const [varName] = [expr];\n   * In other words, determine if function name inference might apply.\n   */\n   isSimpleExportVar() {\n    let tokenIndex = this.tokens.currentIndex();\n    // export\n    tokenIndex++;\n    // var/let/const\n    tokenIndex++;\n    if (!this.tokens.matches1AtIndex(tokenIndex, tt.name)) {\n      return false;\n    }\n    tokenIndex++;\n    while (tokenIndex < this.tokens.tokens.length && this.tokens.tokens[tokenIndex].isType) {\n      tokenIndex++;\n    }\n    if (!this.tokens.matches1AtIndex(tokenIndex, tt.eq)) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Transform an `export var` declaration initializing a single variable.\n   *\n   * For example, this:\n   * export const f = () => {};\n   * becomes this:\n   * const f = () => {}; exports.f = f;\n   *\n   * The variable is unused (e.g. exports.f has the true value of the export).\n   * We need to produce an assignment of this form so that the function will\n   * have an inferred name of \"f\", which wouldn't happen in the more general\n   * case below.\n   */\n   processSimpleExportVar() {\n    // export\n    this.tokens.removeInitialToken();\n    // var/let/const\n    this.tokens.copyToken();\n    const varName = this.tokens.identifierName();\n    // x: number  ->  x\n    while (!this.tokens.matches1(tt.eq)) {\n      this.rootTransformer.processToken();\n    }\n    const endIndex = this.tokens.currentToken().rhsEndIndex;\n    if (endIndex == null) {\n      throw new Error(\"Expected = token with an end index.\");\n    }\n    while (this.tokens.currentIndex() < endIndex) {\n      this.rootTransformer.processToken();\n    }\n    this.tokens.appendCode(`; exports.${varName} = ${varName}`);\n  }\n\n  /**\n   * Transform normal declaration exports, including handling destructuring.\n   * For example, this:\n   * export const {x: [a = 2, b], c} = d;\n   * becomes this:\n   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)\n   */\n   processComplexExportVar() {\n    this.tokens.removeInitialToken();\n    this.tokens.removeToken();\n    const needsParens = this.tokens.matches1(tt.braceL);\n    if (needsParens) {\n      this.tokens.appendCode(\"(\");\n    }\n\n    let depth = 0;\n    while (true) {\n      if (\n        this.tokens.matches1(tt.braceL) ||\n        this.tokens.matches1(tt.dollarBraceL) ||\n        this.tokens.matches1(tt.bracketL)\n      ) {\n        depth++;\n        this.tokens.copyToken();\n      } else if (this.tokens.matches1(tt.braceR) || this.tokens.matches1(tt.bracketR)) {\n        depth--;\n        this.tokens.copyToken();\n      } else if (\n        depth === 0 &&\n        !this.tokens.matches1(tt.name) &&\n        !this.tokens.currentToken().isType\n      ) {\n        break;\n      } else if (this.tokens.matches1(tt.eq)) {\n        // Default values might have assignments in the RHS that we want to ignore, so skip past\n        // them.\n        const endIndex = this.tokens.currentToken().rhsEndIndex;\n        if (endIndex == null) {\n          throw new Error(\"Expected = token with an end index.\");\n        }\n        while (this.tokens.currentIndex() < endIndex) {\n          this.rootTransformer.processToken();\n        }\n      } else {\n        const token = this.tokens.currentToken();\n        if (isDeclaration(token)) {\n          const name = this.tokens.identifierName();\n          let replacement = this.importProcessor.getIdentifierReplacement(name);\n          if (replacement === null) {\n            throw new Error(`Expected a replacement for ${name} in \\`export var\\` syntax.`);\n          }\n          if (isObjectShorthandDeclaration(token)) {\n            replacement = `${name}: ${replacement}`;\n          }\n          this.tokens.replaceToken(replacement);\n        } else {\n          this.rootTransformer.processToken();\n        }\n      }\n    }\n\n    if (needsParens) {\n      // Seek to the end of the RHS.\n      const endIndex = this.tokens.currentToken().rhsEndIndex;\n      if (endIndex == null) {\n        throw new Error(\"Expected = token with an end index.\");\n      }\n      while (this.tokens.currentIndex() < endIndex) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.appendCode(\")\");\n    }\n  }\n\n  /**\n   * Transform this:\n   * export function foo() {}\n   * into this:\n   * function foo() {} exports.foo = foo;\n   */\n   processExportFunction() {\n    this.tokens.replaceToken(\"\");\n    const name = this.processNamedFunction();\n    this.tokens.appendCode(` exports.${name} = ${name};`);\n  }\n\n  /**\n   * Skip past a function with a name and return that name.\n   */\n   processNamedFunction() {\n    if (this.tokens.matches1(tt._function)) {\n      this.tokens.copyToken();\n    } else if (this.tokens.matches2(tt.name, tt._function)) {\n      if (!this.tokens.matchesContextual(ContextualKeyword._async)) {\n        throw new Error(\"Expected async keyword in function export.\");\n      }\n      this.tokens.copyToken();\n      this.tokens.copyToken();\n    }\n    if (this.tokens.matches1(tt.star)) {\n      this.tokens.copyToken();\n    }\n    if (!this.tokens.matches1(tt.name)) {\n      throw new Error(\"Expected identifier for exported function name.\");\n    }\n    const name = this.tokens.identifierName();\n    this.tokens.copyToken();\n    if (this.tokens.currentToken().isType) {\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentToken().isType) {\n        this.tokens.removeToken();\n      }\n    }\n    this.tokens.copyExpectedToken(tt.parenL);\n    this.rootTransformer.processBalancedCode();\n    this.tokens.copyExpectedToken(tt.parenR);\n    this.rootTransformer.processPossibleTypeRange();\n    this.tokens.copyExpectedToken(tt.braceL);\n    this.rootTransformer.processBalancedCode();\n    this.tokens.copyExpectedToken(tt.braceR);\n    return name;\n  }\n\n  /**\n   * Transform this:\n   * export class A {}\n   * into this:\n   * class A {} exports.A = A;\n   */\n   processExportClass() {\n    this.tokens.removeInitialToken();\n    this.copyDecorators();\n    if (this.tokens.matches1(tt._abstract)) {\n      this.tokens.removeToken();\n    }\n    const name = this.rootTransformer.processNamedClass();\n    this.tokens.appendCode(` exports.${name} = ${name};`);\n  }\n\n  /**\n   * Transform this:\n   * export {a, b as c};\n   * into this:\n   * exports.a = a; exports.c = b;\n   *\n   * OR\n   *\n   * Transform this:\n   * export {a, b as c} from './foo';\n   * into the pre-generated Object.defineProperty code from the ImportProcessor.\n   *\n   * For the first case, if the TypeScript transform is enabled, we need to skip\n   * exports that are only defined as types.\n   */\n   processExportBindings() {\n    this.tokens.removeInitialToken();\n    this.tokens.removeToken();\n\n    const exportStatements = [];\n    while (true) {\n      if (this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n        break;\n      }\n\n      const specifierInfo = getImportExportSpecifierInfo(this.tokens);\n      while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n        this.tokens.removeToken();\n      }\n      if (!specifierInfo.isType && !this.shouldElideExportedIdentifier(specifierInfo.leftName)) {\n        const localName = specifierInfo.leftName;\n        const exportedName = specifierInfo.rightName;\n        const newLocalName = this.importProcessor.getIdentifierReplacement(localName);\n        exportStatements.push(`exports.${exportedName} = ${newLocalName || localName};`);\n      }\n\n      if (this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n        break;\n      }\n      if (this.tokens.matches2(tt.comma, tt.braceR)) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        break;\n      } else if (this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n      } else {\n        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);\n      }\n    }\n\n    if (this.tokens.matchesContextual(ContextualKeyword._from)) {\n      // This is an export...from, so throw away the normal named export code\n      // and use the Object.defineProperty code from ImportProcessor.\n      this.tokens.removeToken();\n      const path = this.tokens.stringValue();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n      removeMaybeImportAssertion(this.tokens);\n    } else {\n      // This is a normal named export, so use that.\n      this.tokens.appendCode(exportStatements.join(\" \"));\n    }\n\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   processExportStar() {\n    this.tokens.removeInitialToken();\n    while (!this.tokens.matches1(tt.string)) {\n      this.tokens.removeToken();\n    }\n    const path = this.tokens.stringValue();\n    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n    removeMaybeImportAssertion(this.tokens);\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   shouldElideExportedIdentifier(name) {\n    return this.isTypeScriptTransformEnabled && !this.declarationInfo.valueDeclarations.has(name);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}