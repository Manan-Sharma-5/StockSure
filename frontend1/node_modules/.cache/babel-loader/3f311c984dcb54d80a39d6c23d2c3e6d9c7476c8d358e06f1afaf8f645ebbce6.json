{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils = require(\"../../utils\");\nclass EntryFilter {\n  constructor(_settings, _micromatchOptions) {\n    this._settings = _settings;\n    this._micromatchOptions = _micromatchOptions;\n    this.index = new Map();\n  }\n  getFilter(positive, negative) {\n    const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);\n    const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);\n    return entry => this._filter(entry, positiveRe, negativeRe);\n  }\n  _filter(entry, positiveRe, negativeRe) {\n    if (this._settings.unique && this._isDuplicateEntry(entry)) {\n      return false;\n    }\n    if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {\n      return false;\n    }\n    if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {\n      return false;\n    }\n    const filepath = this._settings.baseNameMatch ? entry.name : entry.path;\n    const isDirectory = entry.dirent.isDirectory();\n    const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(entry.path, negativeRe, isDirectory);\n    if (this._settings.unique && isMatched) {\n      this._createIndexRecord(entry);\n    }\n    return isMatched;\n  }\n  _isDuplicateEntry(entry) {\n    return this.index.has(entry.path);\n  }\n  _createIndexRecord(entry) {\n    this.index.set(entry.path, undefined);\n  }\n  _onlyFileFilter(entry) {\n    return this._settings.onlyFiles && !entry.dirent.isFile();\n  }\n  _onlyDirectoryFilter(entry) {\n    return this._settings.onlyDirectories && !entry.dirent.isDirectory();\n  }\n  _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {\n    if (!this._settings.absolute) {\n      return false;\n    }\n    const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);\n    return utils.pattern.matchAny(fullpath, patternsRe);\n  }\n  _isMatchToPatterns(entryPath, patternsRe, isDirectory) {\n    const filepath = utils.path.removeLeadingDotSegment(entryPath);\n    // Trying to match files and directories by patterns.\n    const isMatched = utils.pattern.matchAny(filepath, patternsRe);\n    // A pattern with a trailling slash can be used for directory matching.\n    // To apply such pattern, we need to add a tralling slash to the path.\n    if (!isMatched && isDirectory) {\n      return utils.pattern.matchAny(filepath + '/', patternsRe);\n    }\n    return isMatched;\n  }\n}\nexports.default = EntryFilter;","map":{"version":3,"names":["Object","defineProperty","exports","value","utils","require","EntryFilter","constructor","_settings","_micromatchOptions","index","Map","getFilter","positive","negative","positiveRe","pattern","convertPatternsToRe","negativeRe","entry","_filter","unique","_isDuplicateEntry","_onlyFileFilter","_onlyDirectoryFilter","_isSkippedByAbsoluteNegativePatterns","path","filepath","baseNameMatch","name","isDirectory","dirent","isMatched","_isMatchToPatterns","_createIndexRecord","has","set","undefined","onlyFiles","isFile","onlyDirectories","entryPath","patternsRe","absolute","fullpath","makeAbsolute","cwd","matchAny","removeLeadingDotSegment","default"],"sources":["/Users/manan/Desktop/hach-unicorn/StockSure/frontend1/node_modules/fast-glob/out/providers/filters/entry.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = require(\"../../utils\");\r\nclass EntryFilter {\r\n    constructor(_settings, _micromatchOptions) {\r\n        this._settings = _settings;\r\n        this._micromatchOptions = _micromatchOptions;\r\n        this.index = new Map();\r\n    }\r\n    getFilter(positive, negative) {\r\n        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);\r\n        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);\r\n        return (entry) => this._filter(entry, positiveRe, negativeRe);\r\n    }\r\n    _filter(entry, positiveRe, negativeRe) {\r\n        if (this._settings.unique && this._isDuplicateEntry(entry)) {\r\n            return false;\r\n        }\r\n        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {\r\n            return false;\r\n        }\r\n        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {\r\n            return false;\r\n        }\r\n        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;\r\n        const isDirectory = entry.dirent.isDirectory();\r\n        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(entry.path, negativeRe, isDirectory);\r\n        if (this._settings.unique && isMatched) {\r\n            this._createIndexRecord(entry);\r\n        }\r\n        return isMatched;\r\n    }\r\n    _isDuplicateEntry(entry) {\r\n        return this.index.has(entry.path);\r\n    }\r\n    _createIndexRecord(entry) {\r\n        this.index.set(entry.path, undefined);\r\n    }\r\n    _onlyFileFilter(entry) {\r\n        return this._settings.onlyFiles && !entry.dirent.isFile();\r\n    }\r\n    _onlyDirectoryFilter(entry) {\r\n        return this._settings.onlyDirectories && !entry.dirent.isDirectory();\r\n    }\r\n    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {\r\n        if (!this._settings.absolute) {\r\n            return false;\r\n        }\r\n        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);\r\n        return utils.pattern.matchAny(fullpath, patternsRe);\r\n    }\r\n    _isMatchToPatterns(entryPath, patternsRe, isDirectory) {\r\n        const filepath = utils.path.removeLeadingDotSegment(entryPath);\r\n        // Trying to match files and directories by patterns.\r\n        const isMatched = utils.pattern.matchAny(filepath, patternsRe);\r\n        // A pattern with a trailling slash can be used for directory matching.\r\n        // To apply such pattern, we need to add a tralling slash to the path.\r\n        if (!isMatched && isDirectory) {\r\n            return utils.pattern.matchAny(filepath + '/', patternsRe);\r\n        }\r\n        return isMatched;\r\n    }\r\n}\r\nexports.default = EntryFilter;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}