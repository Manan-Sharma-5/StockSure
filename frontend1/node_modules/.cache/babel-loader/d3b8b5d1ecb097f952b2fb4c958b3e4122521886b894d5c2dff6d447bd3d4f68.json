{"ast":null,"code":"import { TokenType as tt } from \"../parser/tokenizer/types\";\n\n/**\n * Determine information about this named import or named export specifier.\n *\n * This syntax is the `a` from statements like these:\n * import {A} from \"./foo\";\n * export {A};\n * export {A} from \"./foo\";\n *\n * As it turns out, we can exactly characterize the syntax meaning by simply\n * counting the number of tokens, which can be from 1 to 4:\n * {A}\n * {type A}\n * {A as B}\n * {type A as B}\n *\n * In the type case, we never actually need the names in practice, so don't get\n * them.\n *\n * TODO: There's some redundancy with the type detection here and the isType\n * flag that's already present on tokens in TS mode. This function could\n * potentially be simplified and/or pushed to the call sites to avoid the object\n * allocation.\n */\nexport default function getImportExportSpecifierInfo(tokens) {\n  let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tokens.currentIndex();\n  let endIndex = index + 1;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {A}\n    const name = tokens.identifierNameAtIndex(index);\n    return {\n      isType: false,\n      leftName: name,\n      rightName: name,\n      endIndex\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {type A}\n    return {\n      isType: true,\n      leftName: null,\n      rightName: null,\n      endIndex\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {A as B}\n    return {\n      isType: false,\n      leftName: tokens.identifierNameAtIndex(index),\n      rightName: tokens.identifierNameAtIndex(index + 2),\n      endIndex\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {type A as B}\n    return {\n      isType: true,\n      leftName: null,\n      rightName: null,\n      endIndex\n    };\n  }\n  throw new Error(`Unexpected import/export specifier at ${index}`);\n}\nfunction isSpecifierEnd(tokens, index) {\n  const token = tokens.tokens[index];\n  return token.type === tt.braceR || token.type === tt.comma;\n}","map":{"version":3,"names":["TokenType","tt","getImportExportSpecifierInfo","tokens","index","arguments","length","undefined","currentIndex","endIndex","isSpecifierEnd","name","identifierNameAtIndex","isType","leftName","rightName","Error","token","type","braceR","comma"],"sources":["/Users/manan/Desktop/hach-unicorn/StockSure/frontend1/node_modules/sucrase/dist/esm/util/getImportExportSpecifierInfo.js"],"sourcesContent":["import {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Determine information about this named import or named export specifier.\n *\n * This syntax is the `a` from statements like these:\n * import {A} from \"./foo\";\n * export {A};\n * export {A} from \"./foo\";\n *\n * As it turns out, we can exactly characterize the syntax meaning by simply\n * counting the number of tokens, which can be from 1 to 4:\n * {A}\n * {type A}\n * {A as B}\n * {type A as B}\n *\n * In the type case, we never actually need the names in practice, so don't get\n * them.\n *\n * TODO: There's some redundancy with the type detection here and the isType\n * flag that's already present on tokens in TS mode. This function could\n * potentially be simplified and/or pushed to the call sites to avoid the object\n * allocation.\n */\nexport default function getImportExportSpecifierInfo(\n  tokens,\n  index = tokens.currentIndex(),\n) {\n  let endIndex = index + 1;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {A}\n    const name = tokens.identifierNameAtIndex(index);\n    return {\n      isType: false,\n      leftName: name,\n      rightName: name,\n      endIndex,\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {type A}\n    return {\n      isType: true,\n      leftName: null,\n      rightName: null,\n      endIndex,\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {A as B}\n    return {\n      isType: false,\n      leftName: tokens.identifierNameAtIndex(index),\n      rightName: tokens.identifierNameAtIndex(index + 2),\n      endIndex,\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {type A as B}\n    return {\n      isType: true,\n      leftName: null,\n      rightName: null,\n      endIndex,\n    };\n  }\n  throw new Error(`Unexpected import/export specifier at ${index}`);\n}\n\nfunction isSpecifierEnd(tokens, index) {\n  const token = tokens.tokens[index];\n  return token.type === tt.braceR || token.type === tt.comma;\n}\n"],"mappings":"AAAA,SAAQA,SAAS,IAAIC,EAAE,QAAO,2BAA2B;;AAiBzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,4BAA4BA,CAClDC,MAAM,EAEN;EAAA,IADAC,KAAK,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGF,MAAM,CAACK,YAAY,CAAC,CAAC;EAE7B,IAAIC,QAAQ,GAAGL,KAAK,GAAG,CAAC;EACxB,IAAIM,cAAc,CAACP,MAAM,EAAEM,QAAQ,CAAC,EAAE;IACpC;IACA,MAAME,IAAI,GAAGR,MAAM,CAACS,qBAAqB,CAACR,KAAK,CAAC;IAChD,OAAO;MACLS,MAAM,EAAE,KAAK;MACbC,QAAQ,EAAEH,IAAI;MACdI,SAAS,EAAEJ,IAAI;MACfF;IACF,CAAC;EACH;EACAA,QAAQ,EAAE;EACV,IAAIC,cAAc,CAACP,MAAM,EAAEM,QAAQ,CAAC,EAAE;IACpC;IACA,OAAO;MACLI,MAAM,EAAE,IAAI;MACZC,QAAQ,EAAE,IAAI;MACdC,SAAS,EAAE,IAAI;MACfN;IACF,CAAC;EACH;EACAA,QAAQ,EAAE;EACV,IAAIC,cAAc,CAACP,MAAM,EAAEM,QAAQ,CAAC,EAAE;IACpC;IACA,OAAO;MACLI,MAAM,EAAE,KAAK;MACbC,QAAQ,EAAEX,MAAM,CAACS,qBAAqB,CAACR,KAAK,CAAC;MAC7CW,SAAS,EAAEZ,MAAM,CAACS,qBAAqB,CAACR,KAAK,GAAG,CAAC,CAAC;MAClDK;IACF,CAAC;EACH;EACAA,QAAQ,EAAE;EACV,IAAIC,cAAc,CAACP,MAAM,EAAEM,QAAQ,CAAC,EAAE;IACpC;IACA,OAAO;MACLI,MAAM,EAAE,IAAI;MACZC,QAAQ,EAAE,IAAI;MACdC,SAAS,EAAE,IAAI;MACfN;IACF,CAAC;EACH;EACA,MAAM,IAAIO,KAAK,CAAE,yCAAwCZ,KAAM,EAAC,CAAC;AACnE;AAEA,SAASM,cAAcA,CAACP,MAAM,EAAEC,KAAK,EAAE;EACrC,MAAMa,KAAK,GAAGd,MAAM,CAACA,MAAM,CAACC,KAAK,CAAC;EAClC,OAAOa,KAAK,CAACC,IAAI,KAAKjB,EAAE,CAACkB,MAAM,IAAIF,KAAK,CAACC,IAAI,KAAKjB,EAAE,CAACmB,KAAK;AAC5D"},"metadata":{},"sourceType":"module","externalDependencies":[]}