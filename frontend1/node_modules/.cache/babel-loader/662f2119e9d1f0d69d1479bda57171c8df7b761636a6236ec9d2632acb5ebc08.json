{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils = require(\"../../utils\");\nclass Matcher {\n  constructor(_patterns, _settings, _micromatchOptions) {\n    this._patterns = _patterns;\n    this._settings = _settings;\n    this._micromatchOptions = _micromatchOptions;\n    this._storage = [];\n    this._fillStorage();\n  }\n  _fillStorage() {\n    /**\r\n     * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).\r\n     * So, before expand patterns with brace expansion into separated patterns.\r\n     */\n    const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);\n    for (const pattern of patterns) {\n      const segments = this._getPatternSegments(pattern);\n      const sections = this._splitSegmentsIntoSections(segments);\n      this._storage.push({\n        complete: sections.length <= 1,\n        pattern,\n        segments,\n        sections\n      });\n    }\n  }\n  _getPatternSegments(pattern) {\n    const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);\n    return parts.map(part => {\n      const dynamic = utils.pattern.isDynamicPattern(part, this._settings);\n      if (!dynamic) {\n        return {\n          dynamic: false,\n          pattern: part\n        };\n      }\n      return {\n        dynamic: true,\n        pattern: part,\n        patternRe: utils.pattern.makeRe(part, this._micromatchOptions)\n      };\n    });\n  }\n  _splitSegmentsIntoSections(segments) {\n    return utils.array.splitWhen(segments, segment => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));\n  }\n}\nexports.default = Matcher;","map":{"version":3,"names":["Object","defineProperty","exports","value","utils","require","Matcher","constructor","_patterns","_settings","_micromatchOptions","_storage","_fillStorage","patterns","pattern","expandPatternsWithBraceExpansion","segments","_getPatternSegments","sections","_splitSegmentsIntoSections","push","complete","length","parts","getPatternParts","map","part","dynamic","isDynamicPattern","patternRe","makeRe","array","splitWhen","segment","hasGlobStar","default"],"sources":["/Users/manan/Desktop/hach-unicorn/StockSure/frontend1/node_modules/fast-glob/out/providers/matchers/matcher.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = require(\"../../utils\");\r\nclass Matcher {\r\n    constructor(_patterns, _settings, _micromatchOptions) {\r\n        this._patterns = _patterns;\r\n        this._settings = _settings;\r\n        this._micromatchOptions = _micromatchOptions;\r\n        this._storage = [];\r\n        this._fillStorage();\r\n    }\r\n    _fillStorage() {\r\n        /**\r\n         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).\r\n         * So, before expand patterns with brace expansion into separated patterns.\r\n         */\r\n        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);\r\n        for (const pattern of patterns) {\r\n            const segments = this._getPatternSegments(pattern);\r\n            const sections = this._splitSegmentsIntoSections(segments);\r\n            this._storage.push({\r\n                complete: sections.length <= 1,\r\n                pattern,\r\n                segments,\r\n                sections\r\n            });\r\n        }\r\n    }\r\n    _getPatternSegments(pattern) {\r\n        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);\r\n        return parts.map((part) => {\r\n            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);\r\n            if (!dynamic) {\r\n                return {\r\n                    dynamic: false,\r\n                    pattern: part\r\n                };\r\n            }\r\n            return {\r\n                dynamic: true,\r\n                pattern: part,\r\n                patternRe: utils.pattern.makeRe(part, this._micromatchOptions)\r\n            };\r\n        });\r\n    }\r\n    _splitSegmentsIntoSections(segments) {\r\n        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));\r\n    }\r\n}\r\nexports.default = Matcher;\r\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,MAAMC,KAAK,GAAGC,OAAO,CAAC,aAAa,CAAC;AACpC,MAAMC,OAAO,CAAC;EACVC,WAAWA,CAACC,SAAS,EAAEC,SAAS,EAAEC,kBAAkB,EAAE;IAClD,IAAI,CAACF,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACC,YAAY,CAAC,CAAC;EACvB;EACAA,YAAYA,CAAA,EAAG;IACX;AACR;AACA;AACA;IACQ,MAAMC,QAAQ,GAAGT,KAAK,CAACU,OAAO,CAACC,gCAAgC,CAAC,IAAI,CAACP,SAAS,CAAC;IAC/E,KAAK,MAAMM,OAAO,IAAID,QAAQ,EAAE;MAC5B,MAAMG,QAAQ,GAAG,IAAI,CAACC,mBAAmB,CAACH,OAAO,CAAC;MAClD,MAAMI,QAAQ,GAAG,IAAI,CAACC,0BAA0B,CAACH,QAAQ,CAAC;MAC1D,IAAI,CAACL,QAAQ,CAACS,IAAI,CAAC;QACfC,QAAQ,EAAEH,QAAQ,CAACI,MAAM,IAAI,CAAC;QAC9BR,OAAO;QACPE,QAAQ;QACRE;MACJ,CAAC,CAAC;IACN;EACJ;EACAD,mBAAmBA,CAACH,OAAO,EAAE;IACzB,MAAMS,KAAK,GAAGnB,KAAK,CAACU,OAAO,CAACU,eAAe,CAACV,OAAO,EAAE,IAAI,CAACJ,kBAAkB,CAAC;IAC7E,OAAOa,KAAK,CAACE,GAAG,CAAEC,IAAI,IAAK;MACvB,MAAMC,OAAO,GAAGvB,KAAK,CAACU,OAAO,CAACc,gBAAgB,CAACF,IAAI,EAAE,IAAI,CAACjB,SAAS,CAAC;MACpE,IAAI,CAACkB,OAAO,EAAE;QACV,OAAO;UACHA,OAAO,EAAE,KAAK;UACdb,OAAO,EAAEY;QACb,CAAC;MACL;MACA,OAAO;QACHC,OAAO,EAAE,IAAI;QACbb,OAAO,EAAEY,IAAI;QACbG,SAAS,EAAEzB,KAAK,CAACU,OAAO,CAACgB,MAAM,CAACJ,IAAI,EAAE,IAAI,CAAChB,kBAAkB;MACjE,CAAC;IACL,CAAC,CAAC;EACN;EACAS,0BAA0BA,CAACH,QAAQ,EAAE;IACjC,OAAOZ,KAAK,CAAC2B,KAAK,CAACC,SAAS,CAAChB,QAAQ,EAAGiB,OAAO,IAAKA,OAAO,CAACN,OAAO,IAAIvB,KAAK,CAACU,OAAO,CAACoB,WAAW,CAACD,OAAO,CAACnB,OAAO,CAAC,CAAC;EACtH;AACJ;AACAZ,OAAO,CAACiC,OAAO,GAAG7B,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}