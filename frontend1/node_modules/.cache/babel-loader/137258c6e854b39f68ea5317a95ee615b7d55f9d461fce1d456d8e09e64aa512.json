{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  getClassNameFromSelector: function () {\n    return getClassNameFromSelector;\n  },\n  resolveMatches: function () {\n    return resolveMatches;\n  },\n  generateRules: function () {\n    return generateRules;\n  }\n});\nconst _postcss = /*#__PURE__*/_interop_require_default(require(\"postcss\"));\nconst _postcssselectorparser = /*#__PURE__*/_interop_require_default(require(\"postcss-selector-parser\"));\nconst _parseObjectStyles = /*#__PURE__*/_interop_require_default(require(\"../util/parseObjectStyles\"));\nconst _isPlainObject = /*#__PURE__*/_interop_require_default(require(\"../util/isPlainObject\"));\nconst _prefixSelector = /*#__PURE__*/_interop_require_default(require(\"../util/prefixSelector\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _log = /*#__PURE__*/_interop_require_default(require(\"../util/log\"));\nconst _sharedState = /*#__PURE__*/_interop_require_wildcard(require(\"./sharedState\"));\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nconst _nameClass = require(\"../util/nameClass\");\nconst _dataTypes = require(\"../util/dataTypes\");\nconst _setupContextUtils = require(\"./setupContextUtils\");\nconst _isSyntacticallyValidPropertyValue = /*#__PURE__*/_interop_require_default(require(\"../util/isSyntacticallyValidPropertyValue\"));\nconst _splitAtTopLevelOnly = require(\"../util/splitAtTopLevelOnly.js\");\nconst _featureFlags = require(\"../featureFlags\");\nconst _applyImportantSelector = require(\"../util/applyImportantSelector\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nlet classNameParser = (0, _postcssselectorparser.default)(selectors => {\n  return selectors.first.filter(_ref => {\n    let {\n      type\n    } = _ref;\n    return type === \"class\";\n  }).pop().value;\n});\nfunction getClassNameFromSelector(selector) {\n  return classNameParser.transformSync(selector);\n}\n// Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\nfunction* candidatePermutations(candidate) {\n  let lastIndex = Infinity;\n  while (lastIndex >= 0) {\n    let dashIdx;\n    let wasSlash = false;\n    if (lastIndex === Infinity && candidate.endsWith(\"]\")) {\n      let bracketIdx = candidate.indexOf(\"[\");\n      // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n      // eg. string[]\n      if (candidate[bracketIdx - 1] === \"-\") {\n        dashIdx = bracketIdx - 1;\n      } else if (candidate[bracketIdx - 1] === \"/\") {\n        dashIdx = bracketIdx - 1;\n        wasSlash = true;\n      } else {\n        dashIdx = -1;\n      }\n    } else if (lastIndex === Infinity && candidate.includes(\"/\")) {\n      dashIdx = candidate.lastIndexOf(\"/\");\n      wasSlash = true;\n    } else {\n      dashIdx = candidate.lastIndexOf(\"-\", lastIndex);\n    }\n    if (dashIdx < 0) {\n      break;\n    }\n    let prefix = candidate.slice(0, dashIdx);\n    let modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);\n    lastIndex = dashIdx - 1;\n    // TODO: This feels a bit hacky\n    if (prefix === \"\" || modifier === \"/\") {\n      continue;\n    }\n    yield [prefix, modifier];\n  }\n}\nfunction applyPrefix(matches, context) {\n  if (matches.length === 0 || context.tailwindConfig.prefix === \"\") {\n    return matches;\n  }\n  for (let match of matches) {\n    let [meta] = match;\n    if (meta.options.respectPrefix) {\n      let container = _postcss.default.root({\n        nodes: [match[1].clone()]\n      });\n      let classCandidate = match[1].raws.tailwind.classCandidate;\n      container.walkRules(r => {\n        // If this is a negative utility with a dash *before* the prefix we\n        // have to ensure that the generated selector matches the candidate\n        // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`\n        // The disconnect between candidate <-> class can cause @apply to hard crash.\n        let shouldPrependNegative = classCandidate.startsWith(\"-\");\n        r.selector = (0, _prefixSelector.default)(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);\n      });\n      match[1] = container.nodes[0];\n    }\n  }\n  return matches;\n}\nfunction applyImportant(matches, classCandidate) {\n  if (matches.length === 0) {\n    return matches;\n  }\n  let result = [];\n  for (let [meta, rule] of matches) {\n    let container = _postcss.default.root({\n      nodes: [rule.clone()]\n    });\n    container.walkRules(r => {\n      let ast = (0, _postcssselectorparser.default)().astSync(r.selector);\n      // Remove extraneous selectors that do not include the base candidate\n      ast.each(sel => (0, _formatVariantSelector.eliminateIrrelevantSelectors)(sel, classCandidate));\n      // Update all instances of the base candidate to include the important marker\n      (0, _pluginUtils.updateAllClasses)(ast, className => className === classCandidate ? `!${className}` : className);\n      r.selector = ast.toString();\n      r.walkDecls(d => d.important = true);\n    });\n    result.push([{\n      ...meta,\n      important: true\n    }, container.nodes[0]]);\n  }\n  return result;\n}\n// Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\nfunction applyVariant(variant, matches, context) {\n  if (matches.length === 0) {\n    return matches;\n  }\n  /** @type {{modifier: string | null, value: string | null}} */\n  let args = {\n    modifier: null,\n    value: _sharedState.NONE\n  };\n  // Retrieve \"modifier\"\n  {\n    let [baseVariant, ...modifiers] = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(variant, \"/\");\n    // This is a hack to support variants with `/` in them, like `ar-1/10/20:text-red-500`\n    // In this case 1/10 is a value but /20 is a modifier\n    if (modifiers.length > 1) {\n      baseVariant = baseVariant + \"/\" + modifiers.slice(0, -1).join(\"/\");\n      modifiers = modifiers.slice(-1);\n    }\n    if (modifiers.length && !context.variantMap.has(variant)) {\n      variant = baseVariant;\n      args.modifier = modifiers[0];\n      if (!(0, _featureFlags.flagEnabled)(context.tailwindConfig, \"generalizedModifiers\")) {\n        return [];\n      }\n    }\n  }\n  // Retrieve \"arbitrary value\"\n  if (variant.endsWith(\"]\") && !variant.startsWith(\"[\")) {\n    // We either have:\n    //   @[200px]\n    //   group-[:hover]\n    //\n    // But we don't want:\n    //   @-[200px]        (`-` is incorrect)\n    //   group[:hover]    (`-` is missing)\n    let match = /(.)(-?)\\[(.*)\\]/g.exec(variant);\n    if (match) {\n      let [, char, seperator, value] = match;\n      // @-[200px] case\n      if (char === \"@\" && seperator === \"-\") return [];\n      // group[:hover] case\n      if (char !== \"@\" && seperator === \"\") return [];\n      variant = variant.replace(`${seperator}[${value}]`, \"\");\n      args.value = value;\n    }\n  }\n  // Register arbitrary variants\n  if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {\n    let sort = context.offsets.recordVariant(variant);\n    let selector = (0, _dataTypes.normalize)(variant.slice(1, -1));\n    let selectors = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(selector, \",\");\n    // We do not support multiple selectors for arbitrary variants\n    if (selectors.length > 1) {\n      return [];\n    }\n    if (!selectors.every(_setupContextUtils.isValidVariantFormatString)) {\n      return [];\n    }\n    let records = selectors.map((sel, idx) => [context.offsets.applyParallelOffset(sort, idx), (0, _setupContextUtils.parseVariant)(sel.trim())]);\n    context.variantMap.set(variant, records);\n  }\n  if (context.variantMap.has(variant)) {\n    let isArbitraryVariant = isArbitraryValue(variant);\n    let variantFunctionTuples = context.variantMap.get(variant).slice();\n    let result = [];\n    for (let [meta, rule] of matches) {\n      // Don't generate variants for user css\n      if (meta.layer === \"user\") {\n        continue;\n      }\n      let container = _postcss.default.root({\n        nodes: [rule.clone()]\n      });\n      for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples) {\n        let clone = (containerFromArray !== null && containerFromArray !== void 0 ? containerFromArray : container).clone();\n        let collectedFormats = [];\n        function prepareBackup() {\n          // Already prepared, chicken out\n          if (clone.raws.neededBackup) {\n            return;\n          }\n          clone.raws.neededBackup = true;\n          clone.walkRules(rule => rule.raws.originalSelector = rule.selector);\n        }\n        function modifySelectors(modifierFunction) {\n          prepareBackup();\n          clone.each(rule => {\n            if (rule.type !== \"rule\") {\n              return;\n            }\n            rule.selectors = rule.selectors.map(selector => {\n              return modifierFunction({\n                get className() {\n                  return getClassNameFromSelector(selector);\n                },\n                selector\n              });\n            });\n          });\n          return clone;\n        }\n        let ruleWithVariant = variantFunction({\n          // Public API\n          get container() {\n            prepareBackup();\n            return clone;\n          },\n          separator: context.tailwindConfig.separator,\n          modifySelectors,\n          // Private API for now\n          wrap(wrapper) {\n            let nodes = clone.nodes;\n            clone.removeAll();\n            wrapper.append(nodes);\n            clone.append(wrapper);\n          },\n          format(selectorFormat) {\n            collectedFormats.push({\n              format: selectorFormat,\n              isArbitraryVariant\n            });\n          },\n          args\n        });\n        // It can happen that a list of format strings is returned from within the function. In that\n        // case, we have to process them as well. We can use the existing `variantSort`.\n        if (Array.isArray(ruleWithVariant)) {\n          for (let [idx, variantFunction] of ruleWithVariant.entries()) {\n            // This is a little bit scary since we are pushing to an array of items that we are\n            // currently looping over. However, you can also think of it like a processing queue\n            // where you keep handling jobs until everything is done and each job can queue more\n            // jobs if needed.\n            variantFunctionTuples.push([context.offsets.applyParallelOffset(variantSort, idx), variantFunction,\n            // If the clone has been modified we have to pass that back\n            // though so each rule can use the modified container\n            clone.clone()]);\n          }\n          continue;\n        }\n        if (typeof ruleWithVariant === \"string\") {\n          collectedFormats.push({\n            format: ruleWithVariant,\n            isArbitraryVariant\n          });\n        }\n        if (ruleWithVariant === null) {\n          continue;\n        }\n        // We had to backup selectors, therefore we assume that somebody touched\n        // `container` or `modifySelectors`. Let's see if they did, so that we\n        // can restore the selectors, and collect the format strings.\n        if (clone.raws.neededBackup) {\n          delete clone.raws.neededBackup;\n          clone.walkRules(rule => {\n            let before = rule.raws.originalSelector;\n            if (!before) return;\n            delete rule.raws.originalSelector;\n            if (before === rule.selector) return; // No mutation happened\n            let modified = rule.selector;\n            // Rebuild the base selector, this is what plugin authors would do\n            // as well. E.g.: `${variant}${separator}${className}`.\n            // However, plugin authors probably also prepend or append certain\n            // classes, pseudos, ids, ...\n            let rebuiltBase = (0, _postcssselectorparser.default)(selectors => {\n              selectors.walkClasses(classNode => {\n                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;\n              });\n            }).processSync(before);\n            // Now that we know the original selector, the new selector, and\n            // the rebuild part in between, we can replace the part that plugin\n            // authors need to rebuild with `&`, and eventually store it in the\n            // collectedFormats. Similar to what `format('...')` would do.\n            //\n            // E.g.:\n            //                   variant: foo\n            //                  selector: .markdown > p\n            //      modified (by plugin): .foo .foo\\\\:markdown > p\n            //    rebuiltBase (internal): .foo\\\\:markdown > p\n            //                    format: .foo &\n            collectedFormats.push({\n              format: modified.replace(rebuiltBase, \"&\"),\n              isArbitraryVariant\n            });\n            rule.selector = before;\n          });\n        }\n        // This tracks the originating layer for the variant\n        // For example:\n        // .sm:underline {} is a variant of something in the utilities layer\n        // .sm:container {} is a variant of the container component\n        clone.nodes[0].raws.tailwind = {\n          ...clone.nodes[0].raws.tailwind,\n          parentLayer: meta.layer\n        };\n        var _meta_collectedFormats;\n        let withOffset = [{\n          ...meta,\n          sort: context.offsets.applyVariantOffset(meta.sort, variantSort, Object.assign(args, context.variantOptions.get(variant))),\n          collectedFormats: ((_meta_collectedFormats = meta.collectedFormats) !== null && _meta_collectedFormats !== void 0 ? _meta_collectedFormats : []).concat(collectedFormats)\n        }, clone.nodes[0]];\n        result.push(withOffset);\n      }\n    }\n    return result;\n  }\n  return [];\n}\nfunction parseRules(rule, cache) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // PostCSS node\n  if (!(0, _isPlainObject.default)(rule) && !Array.isArray(rule)) {\n    return [[rule], options];\n  }\n  // Tuple\n  if (Array.isArray(rule)) {\n    return parseRules(rule[0], cache, rule[1]);\n  }\n  // Simple object\n  if (!cache.has(rule)) {\n    cache.set(rule, (0, _parseObjectStyles.default)(rule));\n  }\n  return [cache.get(rule), options];\n}\nconst IS_VALID_PROPERTY_NAME = /^[a-z_-]/;\nfunction isValidPropName(name) {\n  return IS_VALID_PROPERTY_NAME.test(name);\n}\n/**\n * @param {string} declaration\n * @returns {boolean}\n */\nfunction looksLikeUri(declaration) {\n  // Quick bailout for obvious non-urls\n  // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem\n  if (!declaration.includes(\"://\")) {\n    return false;\n  }\n  try {\n    const url = new URL(declaration);\n    return url.scheme !== \"\" && url.host !== \"\";\n  } catch (err) {\n    // Definitely not a valid url\n    return false;\n  }\n}\nfunction isParsableNode(node) {\n  let isParsable = true;\n  node.walkDecls(decl => {\n    if (!isParsableCssValue(decl.prop, decl.value)) {\n      isParsable = false;\n      return false;\n    }\n  });\n  return isParsable;\n}\nfunction isParsableCssValue(property, value) {\n  // We don't want to to treat [https://example.com] as a custom property\n  // Even though, according to the CSS grammar, it's a totally valid CSS declaration\n  // So we short-circuit here by checking if the custom property looks like a url\n  if (looksLikeUri(`${property}:${value}`)) {\n    return false;\n  }\n  try {\n    _postcss.default.parse(`a{${property}:${value}}`).toResult();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\nfunction extractArbitraryProperty(classCandidate, context) {\n  var _classCandidate_match;\n  let [, property, value] = (_classCandidate_match = classCandidate.match(/^\\[([a-zA-Z0-9-_]+):(\\S+)\\]$/)) !== null && _classCandidate_match !== void 0 ? _classCandidate_match : [];\n  if (value === undefined) {\n    return null;\n  }\n  if (!isValidPropName(property)) {\n    return null;\n  }\n  if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n    return null;\n  }\n  let normalized = (0, _dataTypes.normalize)(value);\n  if (!isParsableCssValue(property, normalized)) {\n    return null;\n  }\n  let sort = context.offsets.arbitraryProperty();\n  return [[{\n    sort,\n    layer: \"utilities\"\n  }, () => ({\n    [(0, _nameClass.asClass)(classCandidate)]: {\n      [property]: normalized\n    }\n  })]];\n}\nfunction* resolveMatchedPlugins(classCandidate, context) {\n  if (context.candidateRuleMap.has(classCandidate)) {\n    yield [context.candidateRuleMap.get(classCandidate), \"DEFAULT\"];\n  }\n  yield* function* (arbitraryPropertyRule) {\n    if (arbitraryPropertyRule !== null) {\n      yield [arbitraryPropertyRule, \"DEFAULT\"];\n    }\n  }(extractArbitraryProperty(classCandidate, context));\n  let candidatePrefix = classCandidate;\n  let negative = false;\n  const twConfigPrefix = context.tailwindConfig.prefix;\n  const twConfigPrefixLen = twConfigPrefix.length;\n  const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);\n  if (candidatePrefix[twConfigPrefixLen] === \"-\" && hasMatchingPrefix) {\n    negative = true;\n    candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n  }\n  if (negative && context.candidateRuleMap.has(candidatePrefix)) {\n    yield [context.candidateRuleMap.get(candidatePrefix), \"-DEFAULT\"];\n  }\n  for (let [prefix, modifier] of candidatePermutations(candidatePrefix)) {\n    if (context.candidateRuleMap.has(prefix)) {\n      yield [context.candidateRuleMap.get(prefix), negative ? `-${modifier}` : modifier];\n    }\n  }\n}\nfunction splitWithSeparator(input, separator) {\n  if (input === _sharedState.NOT_ON_DEMAND) {\n    return [_sharedState.NOT_ON_DEMAND];\n  }\n  return (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, separator);\n}\nfunction* recordCandidates(matches, classCandidate) {\n  for (const match of matches) {\n    var _match__options;\n    var _match__options_preserveSource;\n    match[1].raws.tailwind = {\n      ...match[1].raws.tailwind,\n      classCandidate,\n      preserveSource: (_match__options_preserveSource = (_match__options = match[0].options) === null || _match__options === void 0 ? void 0 : _match__options.preserveSource) !== null && _match__options_preserveSource !== void 0 ? _match__options_preserveSource : false\n    };\n    yield match;\n  }\n}\nfunction resolveMatches(candidate, context) {\n  let original = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : candidate;\n  return function* () {\n    let separator = context.tailwindConfig.separator;\n    let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();\n    let important = false;\n    if (classCandidate.startsWith(\"!\")) {\n      important = true;\n      classCandidate = classCandidate.slice(1);\n    }\n    if ((0, _featureFlags.flagEnabled)(context.tailwindConfig, \"variantGrouping\")) {\n      if (classCandidate.startsWith(\"(\") && classCandidate.endsWith(\")\")) {\n        let base = variants.slice().reverse().join(separator);\n        for (let part of (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(classCandidate.slice(1, -1), \",\")) {\n          yield* resolveMatches(base + separator + part, context, original);\n        }\n      }\n    }\n    // TODO: Reintroduce this in ways that doesn't break on false positives\n    // function sortAgainst(toSort, against) {\n    //   return toSort.slice().sort((a, z) => {\n    //     return bigSign(against.get(a)[0] - against.get(z)[0])\n    //   })\n    // }\n    // let sorted = sortAgainst(variants, context.variantMap)\n    // if (sorted.toString() !== variants.toString()) {\n    //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n    //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n    // }\n    for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {\n      let matches = [];\n      let typesByMatches = new Map();\n      let [plugins, modifier] = matchedPlugins;\n      let isOnlyPlugin = plugins.length === 1;\n      for (let [sort, plugin] of plugins) {\n        let matchesPerPlugin = [];\n        if (typeof plugin === \"function\") {\n          for (let ruleSet of [].concat(plugin(modifier, {\n            isOnlyPlugin\n          }))) {\n            let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n            for (let rule of rules) {\n              matchesPerPlugin.push([{\n                ...sort,\n                options: {\n                  ...sort.options,\n                  ...options\n                }\n              }, rule]);\n            }\n          }\n        } else if (modifier === \"DEFAULT\" || modifier === \"-DEFAULT\") {\n          let ruleSet = plugin;\n          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n          for (let rule of rules) {\n            matchesPerPlugin.push([{\n              ...sort,\n              options: {\n                ...sort.options,\n                ...options\n              }\n            }, rule]);\n          }\n        }\n        if (matchesPerPlugin.length > 0) {\n          var _sort_options;\n          var _sort_options_types, _sort_options1;\n          let matchingTypes = Array.from((0, _pluginUtils.getMatchingTypes)((_sort_options_types = (_sort_options = sort.options) === null || _sort_options === void 0 ? void 0 : _sort_options.types) !== null && _sort_options_types !== void 0 ? _sort_options_types : [], modifier, (_sort_options1 = sort.options) !== null && _sort_options1 !== void 0 ? _sort_options1 : {}, context.tailwindConfig)).map(_ref2 => {\n            let [_, type] = _ref2;\n            return type;\n          });\n          if (matchingTypes.length > 0) {\n            typesByMatches.set(matchesPerPlugin, matchingTypes);\n          }\n          matches.push(matchesPerPlugin);\n        }\n      }\n      if (isArbitraryValue(modifier)) {\n        if (matches.length > 1) {\n          // Partition plugins in 2 categories so that we can start searching in the plugins that\n          // don't have `any` as a type first.\n          let [withAny, withoutAny] = matches.reduce((group, plugin) => {\n            let hasAnyType = plugin.some(_ref3 => {\n              let [{\n                options\n              }] = _ref3;\n              return options.types.some(_ref4 => {\n                let {\n                  type\n                } = _ref4;\n                return type === \"any\";\n              });\n            });\n            if (hasAnyType) {\n              group[0].push(plugin);\n            } else {\n              group[1].push(plugin);\n            }\n            return group;\n          }, [[], []]);\n          function findFallback(matches) {\n            // If only a single plugin matches, let's take that one\n            if (matches.length === 1) {\n              return matches[0];\n            }\n            // Otherwise, find the plugin that creates a valid rule given the arbitrary value, and\n            // also has the correct type which preferOnConflicts the plugin in case of clashes.\n            return matches.find(rules => {\n              let matchingTypes = typesByMatches.get(rules);\n              return rules.some(_ref5 => {\n                let [{\n                  options\n                }, rule] = _ref5;\n                if (!isParsableNode(rule)) {\n                  return false;\n                }\n                return options.types.some(_ref6 => {\n                  let {\n                    type,\n                    preferOnConflict\n                  } = _ref6;\n                  return matchingTypes.includes(type) && preferOnConflict;\n                });\n              });\n            });\n          }\n          var _findFallback;\n          // Try to find a fallback plugin, because we already know that multiple plugins matched for\n          // the given arbitrary value.\n          let fallback = (_findFallback = findFallback(withoutAny)) !== null && _findFallback !== void 0 ? _findFallback : findFallback(withAny);\n          if (fallback) {\n            matches = [fallback];\n          } else {\n            var _typesByMatches_get;\n            let typesPerPlugin = matches.map(match => new Set([...((_typesByMatches_get = typesByMatches.get(match)) !== null && _typesByMatches_get !== void 0 ? _typesByMatches_get : [])]));\n            // Remove duplicates, so that we can detect proper unique types for each plugin.\n            for (let pluginTypes of typesPerPlugin) {\n              for (let type of pluginTypes) {\n                let removeFromOwnGroup = false;\n                for (let otherGroup of typesPerPlugin) {\n                  if (pluginTypes === otherGroup) continue;\n                  if (otherGroup.has(type)) {\n                    otherGroup.delete(type);\n                    removeFromOwnGroup = true;\n                  }\n                }\n                if (removeFromOwnGroup) pluginTypes.delete(type);\n              }\n            }\n            let messages = [];\n            for (let [idx, group] of typesPerPlugin.entries()) {\n              for (let type of group) {\n                let rules = matches[idx].map(_ref7 => {\n                  let [, rule] = _ref7;\n                  return rule;\n                }).flat().map(rule => rule.toString().split(\"\\n\").slice(1, -1) // Remove selector and closing '}'\n                .map(line => line.trim()).map(x => `      ${x}`) // Re-indent\n                .join(\"\\n\")).join(\"\\n\\n\");\n                messages.push(`  Use \\`${candidate.replace(\"[\", `[${type}:`)}\\` for \\`${rules.trim()}\\``);\n                break;\n              }\n            }\n            _log.default.warn([`The class \\`${candidate}\\` is ambiguous and matches multiple utilities.`, ...messages, `If this is content and not a class, replace it with \\`${candidate.replace(\"[\", \"&lsqb;\").replace(\"]\", \"&rsqb;\")}\\` to silence this warning.`]);\n            continue;\n          }\n        }\n        matches = matches.map(list => list.filter(match => isParsableNode(match[1])));\n      }\n      matches = matches.flat();\n      matches = Array.from(recordCandidates(matches, classCandidate));\n      matches = applyPrefix(matches, context);\n      if (important) {\n        matches = applyImportant(matches, classCandidate);\n      }\n      for (let variant of variants) {\n        matches = applyVariant(variant, matches, context);\n      }\n      for (let match of matches) {\n        match[1].raws.tailwind = {\n          ...match[1].raws.tailwind,\n          candidate\n        };\n        // Apply final format selector\n        match = applyFinalFormat(match, {\n          context,\n          candidate,\n          original\n        });\n        // Skip rules with invalid selectors\n        // This will cause the candidate to be added to the \"not class\"\n        // cache skipping it entirely for future builds\n        if (match === null) {\n          continue;\n        }\n        yield match;\n      }\n    }\n  }();\n}\nfunction applyFinalFormat(match, _ref8) {\n  let {\n    context,\n    candidate,\n    original\n  } = _ref8;\n  if (!match[0].collectedFormats) {\n    return match;\n  }\n  let isValid = true;\n  let finalFormat;\n  try {\n    finalFormat = (0, _formatVariantSelector.formatVariantSelector)(match[0].collectedFormats, {\n      context,\n      candidate\n    });\n  } catch {\n    // The format selector we produced is invalid\n    // This could be because:\n    // - A bug exists\n    // - A plugin introduced an invalid variant selector (ex: `addVariant('foo', '&;foo')`)\n    // - The user used an invalid arbitrary variant (ex: `[&;foo]:underline`)\n    // Either way the build will fail because of this\n    // We would rather that the build pass \"silently\" given that this could\n    // happen because of picking up invalid things when scanning content\n    // So we'll throw out the candidate instead\n    return null;\n  }\n  let container = _postcss.default.root({\n    nodes: [match[1].clone()]\n  });\n  container.walkRules(rule => {\n    if (inKeyframes(rule)) {\n      return;\n    }\n    try {\n      rule.selector = (0, _formatVariantSelector.finalizeSelector)(rule.selector, finalFormat, {\n        candidate: original,\n        context\n      });\n    } catch {\n      // If this selector is invalid we also want to skip it\n      // But it's likely that being invalid here means there's a bug in a plugin rather than too loosely matching content\n      isValid = false;\n      return false;\n    }\n  });\n  if (!isValid) {\n    return null;\n  }\n  match[1] = container.nodes[0];\n  return match;\n}\nfunction inKeyframes(rule) {\n  return rule.parent && rule.parent.type === \"atrule\" && rule.parent.name === \"keyframes\";\n}\nfunction getImportantStrategy(important) {\n  if (important === true) {\n    return rule => {\n      if (inKeyframes(rule)) {\n        return;\n      }\n      rule.walkDecls(d => {\n        if (d.parent.type === \"rule\" && !inKeyframes(d.parent)) {\n          d.important = true;\n        }\n      });\n    };\n  }\n  if (typeof important === \"string\") {\n    return rule => {\n      if (inKeyframes(rule)) {\n        return;\n      }\n      rule.selectors = rule.selectors.map(selector => {\n        return (0, _applyImportantSelector.applyImportantSelector)(selector, important);\n      });\n    };\n  }\n}\nfunction generateRules(candidates, context) {\n  let allRules = [];\n  let strategy = getImportantStrategy(context.tailwindConfig.important);\n  for (let candidate of candidates) {\n    if (context.notClassCache.has(candidate)) {\n      continue;\n    }\n    if (context.candidateRuleCache.has(candidate)) {\n      allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));\n      continue;\n    }\n    let matches = Array.from(resolveMatches(candidate, context));\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n    context.classCache.set(candidate, matches);\n    var _context_candidateRuleCache_get;\n    let rules = (_context_candidateRuleCache_get = context.candidateRuleCache.get(candidate)) !== null && _context_candidateRuleCache_get !== void 0 ? _context_candidateRuleCache_get : new Set();\n    context.candidateRuleCache.set(candidate, rules);\n    for (const match of matches) {\n      let [{\n        sort,\n        options\n      }, rule] = match;\n      if (options.respectImportant && strategy) {\n        let container = _postcss.default.root({\n          nodes: [rule.clone()]\n        });\n        container.walkRules(strategy);\n        rule = container.nodes[0];\n      }\n      let newEntry = [sort, rule];\n      rules.add(newEntry);\n      context.ruleCache.add(newEntry);\n      allRules.push(newEntry);\n    }\n  }\n  return allRules;\n}\nfunction isArbitraryValue(input) {\n  return input.startsWith(\"[\") && input.endsWith(\"]\");\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","getClassNameFromSelector","resolveMatches","generateRules","_postcss","_interop_require_default","require","_postcssselectorparser","_parseObjectStyles","_isPlainObject","_prefixSelector","_pluginUtils","_log","_sharedState","_interop_require_wildcard","_formatVariantSelector","_nameClass","_dataTypes","_setupContextUtils","_isSyntacticallyValidPropertyValue","_splitAtTopLevelOnly","_featureFlags","_applyImportantSelector","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","classNameParser","selectors","first","filter","_ref","type","pop","selector","transformSync","candidatePermutations","candidate","lastIndex","Infinity","dashIdx","wasSlash","endsWith","bracketIdx","indexOf","includes","lastIndexOf","prefix","slice","modifier","applyPrefix","matches","context","length","tailwindConfig","match","meta","options","respectPrefix","container","root","nodes","clone","classCandidate","raws","tailwind","walkRules","r","shouldPrependNegative","startsWith","applyImportant","result","rule","ast","astSync","each","sel","eliminateIrrelevantSelectors","updateAllClasses","className","toString","walkDecls","d","important","push","applyVariant","variant","args","NONE","baseVariant","modifiers","splitAtTopLevelOnly","join","variantMap","flagEnabled","exec","char","seperator","replace","isArbitraryValue","sort","offsets","recordVariant","normalize","every","isValidVariantFormatString","records","map","idx","applyParallelOffset","parseVariant","trim","isArbitraryVariant","variantFunctionTuples","layer","variantSort","variantFunction","containerFromArray","collectedFormats","prepareBackup","neededBackup","originalSelector","modifySelectors","modifierFunction","ruleWithVariant","separator","wrap","wrapper","removeAll","append","format","selectorFormat","Array","isArray","entries","before","modified","rebuiltBase","walkClasses","classNode","processSync","parentLayer","_meta_collectedFormats","withOffset","applyVariantOffset","assign","variantOptions","concat","parseRules","arguments","undefined","IS_VALID_PROPERTY_NAME","isValidPropName","test","looksLikeUri","declaration","url","URL","scheme","host","err","isParsableNode","node","isParsable","decl","isParsableCssValue","prop","property","parse","toResult","extractArbitraryProperty","_classCandidate_match","normalized","arbitraryProperty","asClass","resolveMatchedPlugins","candidateRuleMap","arbitraryPropertyRule","candidatePrefix","negative","twConfigPrefix","twConfigPrefixLen","hasMatchingPrefix","splitWithSeparator","input","NOT_ON_DEMAND","recordCandidates","_match__options","_match__options_preserveSource","preserveSource","original","variants","reverse","base","part","matchedPlugins","typesByMatches","Map","plugins","isOnlyPlugin","plugin","matchesPerPlugin","ruleSet","rules","postCssNodeCache","_sort_options","_sort_options_types","_sort_options1","matchingTypes","from","getMatchingTypes","types","_ref2","_","withAny","withoutAny","reduce","group","hasAnyType","some","_ref3","_ref4","findFallback","find","_ref5","_ref6","preferOnConflict","_findFallback","fallback","_typesByMatches_get","typesPerPlugin","Set","pluginTypes","removeFromOwnGroup","otherGroup","delete","messages","_ref7","flat","split","line","x","warn","list","applyFinalFormat","_ref8","isValid","finalFormat","formatVariantSelector","inKeyframes","finalizeSelector","parent","getImportantStrategy","applyImportantSelector","candidates","allRules","strategy","notClassCache","candidateRuleCache","add","classCache","_context_candidateRuleCache_get","respectImportant","newEntry","ruleCache"],"sources":["/Users/manan/Desktop/hach-unicorn/StockSure/frontend1/node_modules/tailwindcss/lib/lib/generateRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getClassNameFromSelector: function() {\n        return getClassNameFromSelector;\n    },\n    resolveMatches: function() {\n        return resolveMatches;\n    },\n    generateRules: function() {\n        return generateRules;\n    }\n});\nconst _postcss = /*#__PURE__*/ _interop_require_default(require(\"postcss\"));\nconst _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser\"));\nconst _parseObjectStyles = /*#__PURE__*/ _interop_require_default(require(\"../util/parseObjectStyles\"));\nconst _isPlainObject = /*#__PURE__*/ _interop_require_default(require(\"../util/isPlainObject\"));\nconst _prefixSelector = /*#__PURE__*/ _interop_require_default(require(\"../util/prefixSelector\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _log = /*#__PURE__*/ _interop_require_default(require(\"../util/log\"));\nconst _sharedState = /*#__PURE__*/ _interop_require_wildcard(require(\"./sharedState\"));\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nconst _nameClass = require(\"../util/nameClass\");\nconst _dataTypes = require(\"../util/dataTypes\");\nconst _setupContextUtils = require(\"./setupContextUtils\");\nconst _isSyntacticallyValidPropertyValue = /*#__PURE__*/ _interop_require_default(require(\"../util/isSyntacticallyValidPropertyValue\"));\nconst _splitAtTopLevelOnly = require(\"../util/splitAtTopLevelOnly.js\");\nconst _featureFlags = require(\"../featureFlags\");\nconst _applyImportantSelector = require(\"../util/applyImportantSelector\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet classNameParser = (0, _postcssselectorparser.default)((selectors)=>{\n    return selectors.first.filter(({ type  })=>type === \"class\").pop().value;\n});\nfunction getClassNameFromSelector(selector) {\n    return classNameParser.transformSync(selector);\n}\n// Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\nfunction* candidatePermutations(candidate) {\n    let lastIndex = Infinity;\n    while(lastIndex >= 0){\n        let dashIdx;\n        let wasSlash = false;\n        if (lastIndex === Infinity && candidate.endsWith(\"]\")) {\n            let bracketIdx = candidate.indexOf(\"[\");\n            // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n            // eg. string[]\n            if (candidate[bracketIdx - 1] === \"-\") {\n                dashIdx = bracketIdx - 1;\n            } else if (candidate[bracketIdx - 1] === \"/\") {\n                dashIdx = bracketIdx - 1;\n                wasSlash = true;\n            } else {\n                dashIdx = -1;\n            }\n        } else if (lastIndex === Infinity && candidate.includes(\"/\")) {\n            dashIdx = candidate.lastIndexOf(\"/\");\n            wasSlash = true;\n        } else {\n            dashIdx = candidate.lastIndexOf(\"-\", lastIndex);\n        }\n        if (dashIdx < 0) {\n            break;\n        }\n        let prefix = candidate.slice(0, dashIdx);\n        let modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);\n        lastIndex = dashIdx - 1;\n        // TODO: This feels a bit hacky\n        if (prefix === \"\" || modifier === \"/\") {\n            continue;\n        }\n        yield [\n            prefix,\n            modifier\n        ];\n    }\n}\nfunction applyPrefix(matches, context) {\n    if (matches.length === 0 || context.tailwindConfig.prefix === \"\") {\n        return matches;\n    }\n    for (let match of matches){\n        let [meta] = match;\n        if (meta.options.respectPrefix) {\n            let container = _postcss.default.root({\n                nodes: [\n                    match[1].clone()\n                ]\n            });\n            let classCandidate = match[1].raws.tailwind.classCandidate;\n            container.walkRules((r)=>{\n                // If this is a negative utility with a dash *before* the prefix we\n                // have to ensure that the generated selector matches the candidate\n                // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`\n                // The disconnect between candidate <-> class can cause @apply to hard crash.\n                let shouldPrependNegative = classCandidate.startsWith(\"-\");\n                r.selector = (0, _prefixSelector.default)(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);\n            });\n            match[1] = container.nodes[0];\n        }\n    }\n    return matches;\n}\nfunction applyImportant(matches, classCandidate) {\n    if (matches.length === 0) {\n        return matches;\n    }\n    let result = [];\n    for (let [meta, rule] of matches){\n        let container = _postcss.default.root({\n            nodes: [\n                rule.clone()\n            ]\n        });\n        container.walkRules((r)=>{\n            let ast = (0, _postcssselectorparser.default)().astSync(r.selector);\n            // Remove extraneous selectors that do not include the base candidate\n            ast.each((sel)=>(0, _formatVariantSelector.eliminateIrrelevantSelectors)(sel, classCandidate));\n            // Update all instances of the base candidate to include the important marker\n            (0, _pluginUtils.updateAllClasses)(ast, (className)=>className === classCandidate ? `!${className}` : className);\n            r.selector = ast.toString();\n            r.walkDecls((d)=>d.important = true);\n        });\n        result.push([\n            {\n                ...meta,\n                important: true\n            },\n            container.nodes[0]\n        ]);\n    }\n    return result;\n}\n// Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\nfunction applyVariant(variant, matches, context) {\n    if (matches.length === 0) {\n        return matches;\n    }\n    /** @type {{modifier: string | null, value: string | null}} */ let args = {\n        modifier: null,\n        value: _sharedState.NONE\n    };\n    // Retrieve \"modifier\"\n    {\n        let [baseVariant, ...modifiers] = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(variant, \"/\");\n        // This is a hack to support variants with `/` in them, like `ar-1/10/20:text-red-500`\n        // In this case 1/10 is a value but /20 is a modifier\n        if (modifiers.length > 1) {\n            baseVariant = baseVariant + \"/\" + modifiers.slice(0, -1).join(\"/\");\n            modifiers = modifiers.slice(-1);\n        }\n        if (modifiers.length && !context.variantMap.has(variant)) {\n            variant = baseVariant;\n            args.modifier = modifiers[0];\n            if (!(0, _featureFlags.flagEnabled)(context.tailwindConfig, \"generalizedModifiers\")) {\n                return [];\n            }\n        }\n    }\n    // Retrieve \"arbitrary value\"\n    if (variant.endsWith(\"]\") && !variant.startsWith(\"[\")) {\n        // We either have:\n        //   @[200px]\n        //   group-[:hover]\n        //\n        // But we don't want:\n        //   @-[200px]        (`-` is incorrect)\n        //   group[:hover]    (`-` is missing)\n        let match = /(.)(-?)\\[(.*)\\]/g.exec(variant);\n        if (match) {\n            let [, char, seperator, value] = match;\n            // @-[200px] case\n            if (char === \"@\" && seperator === \"-\") return [];\n            // group[:hover] case\n            if (char !== \"@\" && seperator === \"\") return [];\n            variant = variant.replace(`${seperator}[${value}]`, \"\");\n            args.value = value;\n        }\n    }\n    // Register arbitrary variants\n    if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {\n        let sort = context.offsets.recordVariant(variant);\n        let selector = (0, _dataTypes.normalize)(variant.slice(1, -1));\n        let selectors = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(selector, \",\");\n        // We do not support multiple selectors for arbitrary variants\n        if (selectors.length > 1) {\n            return [];\n        }\n        if (!selectors.every(_setupContextUtils.isValidVariantFormatString)) {\n            return [];\n        }\n        let records = selectors.map((sel, idx)=>[\n                context.offsets.applyParallelOffset(sort, idx),\n                (0, _setupContextUtils.parseVariant)(sel.trim())\n            ]);\n        context.variantMap.set(variant, records);\n    }\n    if (context.variantMap.has(variant)) {\n        let isArbitraryVariant = isArbitraryValue(variant);\n        let variantFunctionTuples = context.variantMap.get(variant).slice();\n        let result = [];\n        for (let [meta, rule] of matches){\n            // Don't generate variants for user css\n            if (meta.layer === \"user\") {\n                continue;\n            }\n            let container = _postcss.default.root({\n                nodes: [\n                    rule.clone()\n                ]\n            });\n            for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples){\n                let clone = (containerFromArray !== null && containerFromArray !== void 0 ? containerFromArray : container).clone();\n                let collectedFormats = [];\n                function prepareBackup() {\n                    // Already prepared, chicken out\n                    if (clone.raws.neededBackup) {\n                        return;\n                    }\n                    clone.raws.neededBackup = true;\n                    clone.walkRules((rule)=>rule.raws.originalSelector = rule.selector);\n                }\n                function modifySelectors(modifierFunction) {\n                    prepareBackup();\n                    clone.each((rule)=>{\n                        if (rule.type !== \"rule\") {\n                            return;\n                        }\n                        rule.selectors = rule.selectors.map((selector)=>{\n                            return modifierFunction({\n                                get className () {\n                                    return getClassNameFromSelector(selector);\n                                },\n                                selector\n                            });\n                        });\n                    });\n                    return clone;\n                }\n                let ruleWithVariant = variantFunction({\n                    // Public API\n                    get container () {\n                        prepareBackup();\n                        return clone;\n                    },\n                    separator: context.tailwindConfig.separator,\n                    modifySelectors,\n                    // Private API for now\n                    wrap (wrapper) {\n                        let nodes = clone.nodes;\n                        clone.removeAll();\n                        wrapper.append(nodes);\n                        clone.append(wrapper);\n                    },\n                    format (selectorFormat) {\n                        collectedFormats.push({\n                            format: selectorFormat,\n                            isArbitraryVariant\n                        });\n                    },\n                    args\n                });\n                // It can happen that a list of format strings is returned from within the function. In that\n                // case, we have to process them as well. We can use the existing `variantSort`.\n                if (Array.isArray(ruleWithVariant)) {\n                    for (let [idx, variantFunction] of ruleWithVariant.entries()){\n                        // This is a little bit scary since we are pushing to an array of items that we are\n                        // currently looping over. However, you can also think of it like a processing queue\n                        // where you keep handling jobs until everything is done and each job can queue more\n                        // jobs if needed.\n                        variantFunctionTuples.push([\n                            context.offsets.applyParallelOffset(variantSort, idx),\n                            variantFunction,\n                            // If the clone has been modified we have to pass that back\n                            // though so each rule can use the modified container\n                            clone.clone()\n                        ]);\n                    }\n                    continue;\n                }\n                if (typeof ruleWithVariant === \"string\") {\n                    collectedFormats.push({\n                        format: ruleWithVariant,\n                        isArbitraryVariant\n                    });\n                }\n                if (ruleWithVariant === null) {\n                    continue;\n                }\n                // We had to backup selectors, therefore we assume that somebody touched\n                // `container` or `modifySelectors`. Let's see if they did, so that we\n                // can restore the selectors, and collect the format strings.\n                if (clone.raws.neededBackup) {\n                    delete clone.raws.neededBackup;\n                    clone.walkRules((rule)=>{\n                        let before = rule.raws.originalSelector;\n                        if (!before) return;\n                        delete rule.raws.originalSelector;\n                        if (before === rule.selector) return; // No mutation happened\n                        let modified = rule.selector;\n                        // Rebuild the base selector, this is what plugin authors would do\n                        // as well. E.g.: `${variant}${separator}${className}`.\n                        // However, plugin authors probably also prepend or append certain\n                        // classes, pseudos, ids, ...\n                        let rebuiltBase = (0, _postcssselectorparser.default)((selectors)=>{\n                            selectors.walkClasses((classNode)=>{\n                                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;\n                            });\n                        }).processSync(before);\n                        // Now that we know the original selector, the new selector, and\n                        // the rebuild part in between, we can replace the part that plugin\n                        // authors need to rebuild with `&`, and eventually store it in the\n                        // collectedFormats. Similar to what `format('...')` would do.\n                        //\n                        // E.g.:\n                        //                   variant: foo\n                        //                  selector: .markdown > p\n                        //      modified (by plugin): .foo .foo\\\\:markdown > p\n                        //    rebuiltBase (internal): .foo\\\\:markdown > p\n                        //                    format: .foo &\n                        collectedFormats.push({\n                            format: modified.replace(rebuiltBase, \"&\"),\n                            isArbitraryVariant\n                        });\n                        rule.selector = before;\n                    });\n                }\n                // This tracks the originating layer for the variant\n                // For example:\n                // .sm:underline {} is a variant of something in the utilities layer\n                // .sm:container {} is a variant of the container component\n                clone.nodes[0].raws.tailwind = {\n                    ...clone.nodes[0].raws.tailwind,\n                    parentLayer: meta.layer\n                };\n                var _meta_collectedFormats;\n                let withOffset = [\n                    {\n                        ...meta,\n                        sort: context.offsets.applyVariantOffset(meta.sort, variantSort, Object.assign(args, context.variantOptions.get(variant))),\n                        collectedFormats: ((_meta_collectedFormats = meta.collectedFormats) !== null && _meta_collectedFormats !== void 0 ? _meta_collectedFormats : []).concat(collectedFormats)\n                    },\n                    clone.nodes[0]\n                ];\n                result.push(withOffset);\n            }\n        }\n        return result;\n    }\n    return [];\n}\nfunction parseRules(rule, cache, options = {}) {\n    // PostCSS node\n    if (!(0, _isPlainObject.default)(rule) && !Array.isArray(rule)) {\n        return [\n            [\n                rule\n            ],\n            options\n        ];\n    }\n    // Tuple\n    if (Array.isArray(rule)) {\n        return parseRules(rule[0], cache, rule[1]);\n    }\n    // Simple object\n    if (!cache.has(rule)) {\n        cache.set(rule, (0, _parseObjectStyles.default)(rule));\n    }\n    return [\n        cache.get(rule),\n        options\n    ];\n}\nconst IS_VALID_PROPERTY_NAME = /^[a-z_-]/;\nfunction isValidPropName(name) {\n    return IS_VALID_PROPERTY_NAME.test(name);\n}\n/**\n * @param {string} declaration\n * @returns {boolean}\n */ function looksLikeUri(declaration) {\n    // Quick bailout for obvious non-urls\n    // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem\n    if (!declaration.includes(\"://\")) {\n        return false;\n    }\n    try {\n        const url = new URL(declaration);\n        return url.scheme !== \"\" && url.host !== \"\";\n    } catch (err) {\n        // Definitely not a valid url\n        return false;\n    }\n}\nfunction isParsableNode(node) {\n    let isParsable = true;\n    node.walkDecls((decl)=>{\n        if (!isParsableCssValue(decl.prop, decl.value)) {\n            isParsable = false;\n            return false;\n        }\n    });\n    return isParsable;\n}\nfunction isParsableCssValue(property, value) {\n    // We don't want to to treat [https://example.com] as a custom property\n    // Even though, according to the CSS grammar, it's a totally valid CSS declaration\n    // So we short-circuit here by checking if the custom property looks like a url\n    if (looksLikeUri(`${property}:${value}`)) {\n        return false;\n    }\n    try {\n        _postcss.default.parse(`a{${property}:${value}}`).toResult();\n        return true;\n    } catch (err) {\n        return false;\n    }\n}\nfunction extractArbitraryProperty(classCandidate, context) {\n    var _classCandidate_match;\n    let [, property, value] = (_classCandidate_match = classCandidate.match(/^\\[([a-zA-Z0-9-_]+):(\\S+)\\]$/)) !== null && _classCandidate_match !== void 0 ? _classCandidate_match : [];\n    if (value === undefined) {\n        return null;\n    }\n    if (!isValidPropName(property)) {\n        return null;\n    }\n    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n        return null;\n    }\n    let normalized = (0, _dataTypes.normalize)(value);\n    if (!isParsableCssValue(property, normalized)) {\n        return null;\n    }\n    let sort = context.offsets.arbitraryProperty();\n    return [\n        [\n            {\n                sort,\n                layer: \"utilities\"\n            },\n            ()=>({\n                    [(0, _nameClass.asClass)(classCandidate)]: {\n                        [property]: normalized\n                    }\n                })\n        ]\n    ];\n}\nfunction* resolveMatchedPlugins(classCandidate, context) {\n    if (context.candidateRuleMap.has(classCandidate)) {\n        yield [\n            context.candidateRuleMap.get(classCandidate),\n            \"DEFAULT\"\n        ];\n    }\n    yield* function*(arbitraryPropertyRule) {\n        if (arbitraryPropertyRule !== null) {\n            yield [\n                arbitraryPropertyRule,\n                \"DEFAULT\"\n            ];\n        }\n    }(extractArbitraryProperty(classCandidate, context));\n    let candidatePrefix = classCandidate;\n    let negative = false;\n    const twConfigPrefix = context.tailwindConfig.prefix;\n    const twConfigPrefixLen = twConfigPrefix.length;\n    const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);\n    if (candidatePrefix[twConfigPrefixLen] === \"-\" && hasMatchingPrefix) {\n        negative = true;\n        candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n    }\n    if (negative && context.candidateRuleMap.has(candidatePrefix)) {\n        yield [\n            context.candidateRuleMap.get(candidatePrefix),\n            \"-DEFAULT\"\n        ];\n    }\n    for (let [prefix, modifier] of candidatePermutations(candidatePrefix)){\n        if (context.candidateRuleMap.has(prefix)) {\n            yield [\n                context.candidateRuleMap.get(prefix),\n                negative ? `-${modifier}` : modifier\n            ];\n        }\n    }\n}\nfunction splitWithSeparator(input, separator) {\n    if (input === _sharedState.NOT_ON_DEMAND) {\n        return [\n            _sharedState.NOT_ON_DEMAND\n        ];\n    }\n    return (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, separator);\n}\nfunction* recordCandidates(matches, classCandidate) {\n    for (const match of matches){\n        var _match__options;\n        var _match__options_preserveSource;\n        match[1].raws.tailwind = {\n            ...match[1].raws.tailwind,\n            classCandidate,\n            preserveSource: (_match__options_preserveSource = (_match__options = match[0].options) === null || _match__options === void 0 ? void 0 : _match__options.preserveSource) !== null && _match__options_preserveSource !== void 0 ? _match__options_preserveSource : false\n        };\n        yield match;\n    }\n}\nfunction* resolveMatches(candidate, context, original = candidate) {\n    let separator = context.tailwindConfig.separator;\n    let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();\n    let important = false;\n    if (classCandidate.startsWith(\"!\")) {\n        important = true;\n        classCandidate = classCandidate.slice(1);\n    }\n    if ((0, _featureFlags.flagEnabled)(context.tailwindConfig, \"variantGrouping\")) {\n        if (classCandidate.startsWith(\"(\") && classCandidate.endsWith(\")\")) {\n            let base = variants.slice().reverse().join(separator);\n            for (let part of (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(classCandidate.slice(1, -1), \",\")){\n                yield* resolveMatches(base + separator + part, context, original);\n            }\n        }\n    }\n    // TODO: Reintroduce this in ways that doesn't break on false positives\n    // function sortAgainst(toSort, against) {\n    //   return toSort.slice().sort((a, z) => {\n    //     return bigSign(against.get(a)[0] - against.get(z)[0])\n    //   })\n    // }\n    // let sorted = sortAgainst(variants, context.variantMap)\n    // if (sorted.toString() !== variants.toString()) {\n    //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n    //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n    // }\n    for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)){\n        let matches = [];\n        let typesByMatches = new Map();\n        let [plugins, modifier] = matchedPlugins;\n        let isOnlyPlugin = plugins.length === 1;\n        for (let [sort, plugin] of plugins){\n            let matchesPerPlugin = [];\n            if (typeof plugin === \"function\") {\n                for (let ruleSet of [].concat(plugin(modifier, {\n                    isOnlyPlugin\n                }))){\n                    let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n                    for (let rule of rules){\n                        matchesPerPlugin.push([\n                            {\n                                ...sort,\n                                options: {\n                                    ...sort.options,\n                                    ...options\n                                }\n                            },\n                            rule\n                        ]);\n                    }\n                }\n            } else if (modifier === \"DEFAULT\" || modifier === \"-DEFAULT\") {\n                let ruleSet = plugin;\n                let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n                for (let rule of rules){\n                    matchesPerPlugin.push([\n                        {\n                            ...sort,\n                            options: {\n                                ...sort.options,\n                                ...options\n                            }\n                        },\n                        rule\n                    ]);\n                }\n            }\n            if (matchesPerPlugin.length > 0) {\n                var _sort_options;\n                var _sort_options_types, _sort_options1;\n                let matchingTypes = Array.from((0, _pluginUtils.getMatchingTypes)((_sort_options_types = (_sort_options = sort.options) === null || _sort_options === void 0 ? void 0 : _sort_options.types) !== null && _sort_options_types !== void 0 ? _sort_options_types : [], modifier, (_sort_options1 = sort.options) !== null && _sort_options1 !== void 0 ? _sort_options1 : {}, context.tailwindConfig)).map(([_, type])=>type);\n                if (matchingTypes.length > 0) {\n                    typesByMatches.set(matchesPerPlugin, matchingTypes);\n                }\n                matches.push(matchesPerPlugin);\n            }\n        }\n        if (isArbitraryValue(modifier)) {\n            if (matches.length > 1) {\n                // Partition plugins in 2 categories so that we can start searching in the plugins that\n                // don't have `any` as a type first.\n                let [withAny, withoutAny] = matches.reduce((group, plugin)=>{\n                    let hasAnyType = plugin.some(([{ options  }])=>options.types.some(({ type  })=>type === \"any\"));\n                    if (hasAnyType) {\n                        group[0].push(plugin);\n                    } else {\n                        group[1].push(plugin);\n                    }\n                    return group;\n                }, [\n                    [],\n                    []\n                ]);\n                function findFallback(matches) {\n                    // If only a single plugin matches, let's take that one\n                    if (matches.length === 1) {\n                        return matches[0];\n                    }\n                    // Otherwise, find the plugin that creates a valid rule given the arbitrary value, and\n                    // also has the correct type which preferOnConflicts the plugin in case of clashes.\n                    return matches.find((rules)=>{\n                        let matchingTypes = typesByMatches.get(rules);\n                        return rules.some(([{ options  }, rule])=>{\n                            if (!isParsableNode(rule)) {\n                                return false;\n                            }\n                            return options.types.some(({ type , preferOnConflict  })=>matchingTypes.includes(type) && preferOnConflict);\n                        });\n                    });\n                }\n                var _findFallback;\n                // Try to find a fallback plugin, because we already know that multiple plugins matched for\n                // the given arbitrary value.\n                let fallback = (_findFallback = findFallback(withoutAny)) !== null && _findFallback !== void 0 ? _findFallback : findFallback(withAny);\n                if (fallback) {\n                    matches = [\n                        fallback\n                    ];\n                } else {\n                    var _typesByMatches_get;\n                    let typesPerPlugin = matches.map((match)=>new Set([\n                            ...(_typesByMatches_get = typesByMatches.get(match)) !== null && _typesByMatches_get !== void 0 ? _typesByMatches_get : []\n                        ]));\n                    // Remove duplicates, so that we can detect proper unique types for each plugin.\n                    for (let pluginTypes of typesPerPlugin){\n                        for (let type of pluginTypes){\n                            let removeFromOwnGroup = false;\n                            for (let otherGroup of typesPerPlugin){\n                                if (pluginTypes === otherGroup) continue;\n                                if (otherGroup.has(type)) {\n                                    otherGroup.delete(type);\n                                    removeFromOwnGroup = true;\n                                }\n                            }\n                            if (removeFromOwnGroup) pluginTypes.delete(type);\n                        }\n                    }\n                    let messages = [];\n                    for (let [idx, group] of typesPerPlugin.entries()){\n                        for (let type of group){\n                            let rules = matches[idx].map(([, rule])=>rule).flat().map((rule)=>rule.toString().split(\"\\n\").slice(1, -1) // Remove selector and closing '}'\n                                .map((line)=>line.trim()).map((x)=>`      ${x}`) // Re-indent\n                                .join(\"\\n\")).join(\"\\n\\n\");\n                            messages.push(`  Use \\`${candidate.replace(\"[\", `[${type}:`)}\\` for \\`${rules.trim()}\\``);\n                            break;\n                        }\n                    }\n                    _log.default.warn([\n                        `The class \\`${candidate}\\` is ambiguous and matches multiple utilities.`,\n                        ...messages,\n                        `If this is content and not a class, replace it with \\`${candidate.replace(\"[\", \"&lsqb;\").replace(\"]\", \"&rsqb;\")}\\` to silence this warning.`\n                    ]);\n                    continue;\n                }\n            }\n            matches = matches.map((list)=>list.filter((match)=>isParsableNode(match[1])));\n        }\n        matches = matches.flat();\n        matches = Array.from(recordCandidates(matches, classCandidate));\n        matches = applyPrefix(matches, context);\n        if (important) {\n            matches = applyImportant(matches, classCandidate);\n        }\n        for (let variant of variants){\n            matches = applyVariant(variant, matches, context);\n        }\n        for (let match of matches){\n            match[1].raws.tailwind = {\n                ...match[1].raws.tailwind,\n                candidate\n            };\n            // Apply final format selector\n            match = applyFinalFormat(match, {\n                context,\n                candidate,\n                original\n            });\n            // Skip rules with invalid selectors\n            // This will cause the candidate to be added to the \"not class\"\n            // cache skipping it entirely for future builds\n            if (match === null) {\n                continue;\n            }\n            yield match;\n        }\n    }\n}\nfunction applyFinalFormat(match, { context , candidate , original  }) {\n    if (!match[0].collectedFormats) {\n        return match;\n    }\n    let isValid = true;\n    let finalFormat;\n    try {\n        finalFormat = (0, _formatVariantSelector.formatVariantSelector)(match[0].collectedFormats, {\n            context,\n            candidate\n        });\n    } catch  {\n        // The format selector we produced is invalid\n        // This could be because:\n        // - A bug exists\n        // - A plugin introduced an invalid variant selector (ex: `addVariant('foo', '&;foo')`)\n        // - The user used an invalid arbitrary variant (ex: `[&;foo]:underline`)\n        // Either way the build will fail because of this\n        // We would rather that the build pass \"silently\" given that this could\n        // happen because of picking up invalid things when scanning content\n        // So we'll throw out the candidate instead\n        return null;\n    }\n    let container = _postcss.default.root({\n        nodes: [\n            match[1].clone()\n        ]\n    });\n    container.walkRules((rule)=>{\n        if (inKeyframes(rule)) {\n            return;\n        }\n        try {\n            rule.selector = (0, _formatVariantSelector.finalizeSelector)(rule.selector, finalFormat, {\n                candidate: original,\n                context\n            });\n        } catch  {\n            // If this selector is invalid we also want to skip it\n            // But it's likely that being invalid here means there's a bug in a plugin rather than too loosely matching content\n            isValid = false;\n            return false;\n        }\n    });\n    if (!isValid) {\n        return null;\n    }\n    match[1] = container.nodes[0];\n    return match;\n}\nfunction inKeyframes(rule) {\n    return rule.parent && rule.parent.type === \"atrule\" && rule.parent.name === \"keyframes\";\n}\nfunction getImportantStrategy(important) {\n    if (important === true) {\n        return (rule)=>{\n            if (inKeyframes(rule)) {\n                return;\n            }\n            rule.walkDecls((d)=>{\n                if (d.parent.type === \"rule\" && !inKeyframes(d.parent)) {\n                    d.important = true;\n                }\n            });\n        };\n    }\n    if (typeof important === \"string\") {\n        return (rule)=>{\n            if (inKeyframes(rule)) {\n                return;\n            }\n            rule.selectors = rule.selectors.map((selector)=>{\n                return (0, _applyImportantSelector.applyImportantSelector)(selector, important);\n            });\n        };\n    }\n}\nfunction generateRules(candidates, context) {\n    let allRules = [];\n    let strategy = getImportantStrategy(context.tailwindConfig.important);\n    for (let candidate of candidates){\n        if (context.notClassCache.has(candidate)) {\n            continue;\n        }\n        if (context.candidateRuleCache.has(candidate)) {\n            allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));\n            continue;\n        }\n        let matches = Array.from(resolveMatches(candidate, context));\n        if (matches.length === 0) {\n            context.notClassCache.add(candidate);\n            continue;\n        }\n        context.classCache.set(candidate, matches);\n        var _context_candidateRuleCache_get;\n        let rules = (_context_candidateRuleCache_get = context.candidateRuleCache.get(candidate)) !== null && _context_candidateRuleCache_get !== void 0 ? _context_candidateRuleCache_get : new Set();\n        context.candidateRuleCache.set(candidate, rules);\n        for (const match of matches){\n            let [{ sort , options  }, rule] = match;\n            if (options.respectImportant && strategy) {\n                let container = _postcss.default.root({\n                    nodes: [\n                        rule.clone()\n                    ]\n                });\n                container.walkRules(strategy);\n                rule = container.nodes[0];\n            }\n            let newEntry = [\n                sort,\n                rule\n            ];\n            rules.add(newEntry);\n            context.ruleCache.add(newEntry);\n            allRules.push(newEntry);\n        }\n    }\n    return allRules;\n}\nfunction isArbitraryValue(input) {\n    return input.startsWith(\"[\") && input.endsWith(\"]\");\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}