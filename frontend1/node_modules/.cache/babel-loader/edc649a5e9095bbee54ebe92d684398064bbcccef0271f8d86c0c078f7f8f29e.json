{"ast":null,"code":"/* eslint max-len: 0 */\n\nimport { input, isFlowEnabled, state } from \"../traverser/base\";\nimport { unexpected } from \"../traverser/util\";\nimport { charCodes } from \"../util/charcodes\";\nimport { IS_IDENTIFIER_CHAR, IS_IDENTIFIER_START } from \"../util/identifier\";\nimport { IS_WHITESPACE, skipWhiteSpace } from \"../util/whitespace\";\nimport { ContextualKeyword } from \"./keywords\";\nimport readWord from \"./readWord\";\nimport { TokenType as tt } from \"./types\";\nexport var IdentifierRole;\n(function (IdentifierRole) {\n  const Access = 0;\n  IdentifierRole[IdentifierRole[\"Access\"] = Access] = \"Access\";\n  const ExportAccess = Access + 1;\n  IdentifierRole[IdentifierRole[\"ExportAccess\"] = ExportAccess] = \"ExportAccess\";\n  const TopLevelDeclaration = ExportAccess + 1;\n  IdentifierRole[IdentifierRole[\"TopLevelDeclaration\"] = TopLevelDeclaration] = \"TopLevelDeclaration\";\n  const FunctionScopedDeclaration = TopLevelDeclaration + 1;\n  IdentifierRole[IdentifierRole[\"FunctionScopedDeclaration\"] = FunctionScopedDeclaration] = \"FunctionScopedDeclaration\";\n  const BlockScopedDeclaration = FunctionScopedDeclaration + 1;\n  IdentifierRole[IdentifierRole[\"BlockScopedDeclaration\"] = BlockScopedDeclaration] = \"BlockScopedDeclaration\";\n  const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1;\n  IdentifierRole[IdentifierRole[\"ObjectShorthandTopLevelDeclaration\"] = ObjectShorthandTopLevelDeclaration] = \"ObjectShorthandTopLevelDeclaration\";\n  const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1;\n  IdentifierRole[IdentifierRole[\"ObjectShorthandFunctionScopedDeclaration\"] = ObjectShorthandFunctionScopedDeclaration] = \"ObjectShorthandFunctionScopedDeclaration\";\n  const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1;\n  IdentifierRole[IdentifierRole[\"ObjectShorthandBlockScopedDeclaration\"] = ObjectShorthandBlockScopedDeclaration] = \"ObjectShorthandBlockScopedDeclaration\";\n  const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1;\n  IdentifierRole[IdentifierRole[\"ObjectShorthand\"] = ObjectShorthand] = \"ObjectShorthand\";\n  // Any identifier bound in an import statement, e.g. both A and b from\n  // `import A, * as b from 'A';`\n  const ImportDeclaration = ObjectShorthand + 1;\n  IdentifierRole[IdentifierRole[\"ImportDeclaration\"] = ImportDeclaration] = \"ImportDeclaration\";\n  const ObjectKey = ImportDeclaration + 1;\n  IdentifierRole[IdentifierRole[\"ObjectKey\"] = ObjectKey] = \"ObjectKey\";\n  // The `foo` in `import {foo as bar} from \"./abc\";`.\n  const ImportAccess = ObjectKey + 1;\n  IdentifierRole[IdentifierRole[\"ImportAccess\"] = ImportAccess] = \"ImportAccess\";\n})(IdentifierRole || (IdentifierRole = {}));\n\n/**\n * Extra information on jsxTagStart tokens, used to determine which of the three\n * jsx functions are called in the automatic transform.\n */\nexport var JSXRole;\n(function (JSXRole) {\n  // The element is self-closing or has a body that resolves to empty. We\n  // shouldn't emit children at all in this case.\n  const NoChildren = 0;\n  JSXRole[JSXRole[\"NoChildren\"] = NoChildren] = \"NoChildren\";\n  // The element has a single explicit child, which might still be an arbitrary\n  // expression like an array. We should emit that expression as the children.\n  const OneChild = NoChildren + 1;\n  JSXRole[JSXRole[\"OneChild\"] = OneChild] = \"OneChild\";\n  // The element has at least two explicitly-specified children or has spread\n  // children, so child positions are assumed to be \"static\". We should wrap\n  // these children in an array.\n  const StaticChildren = OneChild + 1;\n  JSXRole[JSXRole[\"StaticChildren\"] = StaticChildren] = \"StaticChildren\";\n  // The element has a prop named \"key\" after a prop spread, so we should fall\n  // back to the createElement function.\n  const KeyAfterPropSpread = StaticChildren + 1;\n  JSXRole[JSXRole[\"KeyAfterPropSpread\"] = KeyAfterPropSpread] = \"KeyAfterPropSpread\";\n})(JSXRole || (JSXRole = {}));\nexport function isDeclaration(token) {\n  const role = token.identifierRole;\n  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;\n}\nexport function isNonTopLevelDeclaration(token) {\n  const role = token.identifierRole;\n  return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;\n}\nexport function isTopLevelDeclaration(token) {\n  const role = token.identifierRole;\n  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ImportDeclaration;\n}\nexport function isBlockScopedDeclaration(token) {\n  const role = token.identifierRole;\n  // Treat top-level declarations as block scope since the distinction doesn't matter here.\n  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;\n}\nexport function isFunctionScopedDeclaration(token) {\n  const role = token.identifierRole;\n  return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;\n}\nexport function isObjectShorthandDeclaration(token) {\n  return token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration || token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration || token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;\n}\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\nexport class Token {\n  constructor() {\n    this.type = state.type;\n    this.contextualKeyword = state.contextualKeyword;\n    this.start = state.start;\n    this.end = state.end;\n    this.scopeDepth = state.scopeDepth;\n    this.isType = state.isType;\n    this.identifierRole = null;\n    this.jsxRole = null;\n    this.shadowsGlobal = false;\n    this.isAsyncOperation = false;\n    this.contextId = null;\n    this.rhsEndIndex = null;\n    this.isExpression = false;\n    this.numNullishCoalesceStarts = 0;\n    this.numNullishCoalesceEnds = 0;\n    this.isOptionalChainStart = false;\n    this.isOptionalChainEnd = false;\n    this.subscriptStartIndex = null;\n    this.nullishStartIndex = null;\n  }\n\n  // Initially false for all tokens, then may be computed in a follow-up step that does scope\n  // analysis.\n\n  // Initially false for all tokens, but may be set during transform to mark it as containing an\n  // await operation.\n\n  // For assignments, the index of the RHS. For export tokens, the end of the export.\n\n  // For class tokens, records if the class is a class expression or a class statement.\n\n  // Number of times to insert a `nullishCoalesce(` snippet before this token.\n\n  // Number of times to insert a `)` snippet after this token.\n\n  // If true, insert an `optionalChain([` snippet before this token.\n\n  // If true, insert a `])` snippet after this token.\n\n  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the \"root\" token for this\n  // subscript chain. This can be used to determine if this chain is an optional chain.\n\n  // Tag for `??` operators to denote the root token for this nullish coalescing call.\n}\n\n// ## Tokenizer\n\n// Move to the next token\nexport function next() {\n  state.tokens.push(new Token());\n  nextToken();\n}\n\n// Call instead of next when inside a template, since that needs to be handled differently.\nexport function nextTemplateToken() {\n  state.tokens.push(new Token());\n  state.start = state.pos;\n  readTmplToken();\n}\n\n// The tokenizer never parses regexes by default. Instead, the parser is responsible for\n// instructing it to parse a regex when we see a slash at the start of an expression.\nexport function retokenizeSlashAsRegex() {\n  if (state.type === tt.assign) {\n    --state.pos;\n  }\n  readRegexp();\n}\nexport function pushTypeContext(existingTokensInType) {\n  for (let i = state.tokens.length - existingTokensInType; i < state.tokens.length; i++) {\n    state.tokens[i].isType = true;\n  }\n  const oldIsType = state.isType;\n  state.isType = true;\n  return oldIsType;\n}\nexport function popTypeContext(oldIsType) {\n  state.isType = oldIsType;\n}\nexport function eat(type) {\n  if (match(type)) {\n    next();\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function eatTypeToken(tokenType) {\n  const oldIsType = state.isType;\n  state.isType = true;\n  eat(tokenType);\n  state.isType = oldIsType;\n}\nexport function match(type) {\n  return state.type === type;\n}\nexport function lookaheadType() {\n  const snapshot = state.snapshot();\n  next();\n  const type = state.type;\n  state.restoreFromSnapshot(snapshot);\n  return type;\n}\nexport class TypeAndKeyword {\n  constructor(type, contextualKeyword) {\n    this.type = type;\n    this.contextualKeyword = contextualKeyword;\n  }\n}\nexport function lookaheadTypeAndKeyword() {\n  const snapshot = state.snapshot();\n  next();\n  const type = state.type;\n  const contextualKeyword = state.contextualKeyword;\n  state.restoreFromSnapshot(snapshot);\n  return new TypeAndKeyword(type, contextualKeyword);\n}\nexport function nextTokenStart() {\n  return nextTokenStartSince(state.pos);\n}\nexport function nextTokenStartSince(pos) {\n  skipWhiteSpace.lastIndex = pos;\n  const skip = skipWhiteSpace.exec(input);\n  return pos + skip[0].length;\n}\nexport function lookaheadCharCode() {\n  return input.charCodeAt(nextTokenStart());\n}\n\n// Read a single token, updating the parser object's token-related\n// properties.\nexport function nextToken() {\n  skipSpace();\n  state.start = state.pos;\n  if (state.pos >= input.length) {\n    const tokens = state.tokens;\n    // We normally run past the end a bit, but if we're way past the end, avoid an infinite loop.\n    // Also check the token positions rather than the types since sometimes we rewrite the token\n    // type to something else.\n    if (tokens.length >= 2 && tokens[tokens.length - 1].start >= input.length && tokens[tokens.length - 2].start >= input.length) {\n      unexpected(\"Unexpectedly reached the end of input.\");\n    }\n    finishToken(tt.eof);\n    return;\n  }\n  readToken(input.charCodeAt(state.pos));\n}\nfunction readToken(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (IS_IDENTIFIER_START[code] || code === charCodes.backslash || code === charCodes.atSign && input.charCodeAt(state.pos + 1) === charCodes.atSign) {\n    readWord();\n  } else {\n    getTokenFromCode(code);\n  }\n}\nfunction skipBlockComment() {\n  while (input.charCodeAt(state.pos) !== charCodes.asterisk || input.charCodeAt(state.pos + 1) !== charCodes.slash) {\n    state.pos++;\n    if (state.pos > input.length) {\n      unexpected(\"Unterminated comment\", state.pos - 2);\n      return;\n    }\n  }\n  state.pos += 2;\n}\nexport function skipLineComment(startSkip) {\n  let ch = input.charCodeAt(state.pos += startSkip);\n  if (state.pos < input.length) {\n    while (ch !== charCodes.lineFeed && ch !== charCodes.carriageReturn && ch !== charCodes.lineSeparator && ch !== charCodes.paragraphSeparator && ++state.pos < input.length) {\n      ch = input.charCodeAt(state.pos);\n    }\n  }\n}\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments.\nexport function skipSpace() {\n  while (state.pos < input.length) {\n    const ch = input.charCodeAt(state.pos);\n    switch (ch) {\n      case charCodes.carriageReturn:\n        if (input.charCodeAt(state.pos + 1) === charCodes.lineFeed) {\n          ++state.pos;\n        }\n      case charCodes.lineFeed:\n      case charCodes.lineSeparator:\n      case charCodes.paragraphSeparator:\n        ++state.pos;\n        break;\n      case charCodes.slash:\n        switch (input.charCodeAt(state.pos + 1)) {\n          case charCodes.asterisk:\n            state.pos += 2;\n            skipBlockComment();\n            break;\n          case charCodes.slash:\n            skipLineComment(2);\n            break;\n          default:\n            return;\n        }\n        break;\n      default:\n        if (IS_WHITESPACE[ch]) {\n          ++state.pos;\n        } else {\n          return;\n        }\n    }\n  }\n}\n\n// Called at the end of every token. Sets various fields, and skips the space after the token, so\n// that the next one's `start` will point at the right position.\nexport function finishToken(type) {\n  let contextualKeyword = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ContextualKeyword.NONE;\n  state.end = state.pos;\n  state.type = type;\n  state.contextualKeyword = contextualKeyword;\n}\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\nfunction readToken_dot() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar >= charCodes.digit0 && nextChar <= charCodes.digit9) {\n    readNumber(true);\n    return;\n  }\n  if (nextChar === charCodes.dot && input.charCodeAt(state.pos + 2) === charCodes.dot) {\n    state.pos += 3;\n    finishToken(tt.ellipsis);\n  } else {\n    ++state.pos;\n    finishToken(tt.dot);\n  }\n}\nfunction readToken_slash() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else {\n    finishOp(tt.slash, 1);\n  }\n}\nfunction readToken_mult_modulo(code) {\n  // '%*'\n  let tokenType = code === charCodes.asterisk ? tt.star : tt.modulo;\n  let width = 1;\n  let nextChar = input.charCodeAt(state.pos + 1);\n\n  // Exponentiation operator **\n  if (code === charCodes.asterisk && nextChar === charCodes.asterisk) {\n    width++;\n    nextChar = input.charCodeAt(state.pos + 2);\n    tokenType = tt.exponent;\n  }\n\n  // Match *= or %=, disallowing *=> which can be valid in flow.\n  if (nextChar === charCodes.equalsTo && input.charCodeAt(state.pos + 2) !== charCodes.greaterThan) {\n    width++;\n    tokenType = tt.assign;\n  }\n  finishOp(tokenType, width);\n}\nfunction readToken_pipe_amp(code) {\n  // '|&'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === code) {\n    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {\n      // ||= or &&=\n      finishOp(tt.assign, 3);\n    } else {\n      // || or &&\n      finishOp(code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND, 2);\n    }\n    return;\n  }\n  if (code === charCodes.verticalBar) {\n    // '|>'\n    if (nextChar === charCodes.greaterThan) {\n      finishOp(tt.pipeline, 2);\n      return;\n    } else if (nextChar === charCodes.rightCurlyBrace && isFlowEnabled) {\n      // '|}'\n      finishOp(tt.braceBarR, 2);\n      return;\n    }\n  }\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n    return;\n  }\n  finishOp(code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND, 1);\n}\nfunction readToken_caret() {\n  // '^'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else {\n    finishOp(tt.bitwiseXOR, 1);\n  }\n}\nfunction readToken_plus_min(code) {\n  // '+-'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === code) {\n    // Tentatively call this a prefix operator, but it might be changed to postfix later.\n    finishOp(tt.preIncDec, 2);\n    return;\n  }\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else if (code === charCodes.plusSign) {\n    finishOp(tt.plus, 1);\n  } else {\n    finishOp(tt.minus, 1);\n  }\n}\nfunction readToken_lt() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.lessThan) {\n    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {\n      finishOp(tt.assign, 3);\n      return;\n    }\n    // We see <<, but need to be really careful about whether to treat it as a\n    // true left-shift or as two < tokens.\n    if (state.isType) {\n      // Within a type, << might come up in a snippet like `Array<<T>() => void>`,\n      // so treat it as two < tokens. Importantly, this should only override <<\n      // rather than other tokens like <= . If we treated <= as < in a type\n      // context, then the snippet `a as T <= 1` would incorrectly start parsing\n      // a type argument on T. We don't need to worry about `a as T << 1`\n      // because TypeScript disallows that syntax.\n      finishOp(tt.lessThan, 1);\n    } else {\n      // Outside a type, this might be a true left-shift operator, or it might\n      // still be two open-type-arg tokens, such as in `f<<T>() => void>()`. We\n      // look at the token while considering the `f`, so we don't yet know that\n      // we're in a type context. In this case, we initially tokenize as a\n      // left-shift and correct after-the-fact as necessary in\n      // tsParseTypeArgumentsWithPossibleBitshift .\n      finishOp(tt.bitShiftL, 2);\n    }\n    return;\n  }\n  if (nextChar === charCodes.equalsTo) {\n    // <=\n    finishOp(tt.relationalOrEqual, 2);\n  } else {\n    finishOp(tt.lessThan, 1);\n  }\n}\nfunction readToken_gt() {\n  if (state.isType) {\n    // Avoid right-shift for things like `Array<Array<string>>` and\n    // greater-than-or-equal for things like `const a: Array<number>=[];`.\n    finishOp(tt.greaterThan, 1);\n    return;\n  }\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.greaterThan) {\n    const size = input.charCodeAt(state.pos + 2) === charCodes.greaterThan ? 3 : 2;\n    if (input.charCodeAt(state.pos + size) === charCodes.equalsTo) {\n      finishOp(tt.assign, size + 1);\n      return;\n    }\n    finishOp(tt.bitShiftR, size);\n    return;\n  }\n  if (nextChar === charCodes.equalsTo) {\n    // >=\n    finishOp(tt.relationalOrEqual, 2);\n  } else {\n    finishOp(tt.greaterThan, 1);\n  }\n}\n\n/**\n * Called after `as` expressions in TS; we're switching from a type to a\n * non-type context, so a > token may actually be >= . This is needed because >=\n * must be tokenized as a > in a type context because of code like\n * `const x: Array<T>=[];`, but `a as T >= 1` is a code example where it must be\n * treated as >=.\n *\n * Notably, this only applies to >, not <. In a code snippet like `a as T <= 1`,\n * we must NOT tokenize as <, or else the type parser will start parsing a type\n * argument and fail.\n */\nexport function rescan_gt() {\n  if (state.type === tt.greaterThan) {\n    state.pos -= 1;\n    readToken_gt();\n  }\n}\nfunction readToken_eq_excl(code) {\n  // '=!'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.equality, input.charCodeAt(state.pos + 2) === charCodes.equalsTo ? 3 : 2);\n    return;\n  }\n  if (code === charCodes.equalsTo && nextChar === charCodes.greaterThan) {\n    // '=>'\n    state.pos += 2;\n    finishToken(tt.arrow);\n    return;\n  }\n  finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);\n}\nfunction readToken_question() {\n  // '?'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  const nextChar2 = input.charCodeAt(state.pos + 2);\n  if (nextChar === charCodes.questionMark &&\n  // In Flow (but not TypeScript), ??string is a valid type that should be\n  // tokenized as two individual ? tokens.\n  !(isFlowEnabled && state.isType)) {\n    if (nextChar2 === charCodes.equalsTo) {\n      // '??='\n      finishOp(tt.assign, 3);\n    } else {\n      // '??'\n      finishOp(tt.nullishCoalescing, 2);\n    }\n  } else if (nextChar === charCodes.dot && !(nextChar2 >= charCodes.digit0 && nextChar2 <= charCodes.digit9)) {\n    // '.' not followed by a number\n    state.pos += 2;\n    finishToken(tt.questionDot);\n  } else {\n    ++state.pos;\n    finishToken(tt.question);\n  }\n}\nexport function getTokenFromCode(code) {\n  switch (code) {\n    case charCodes.numberSign:\n      ++state.pos;\n      finishToken(tt.hash);\n      return;\n\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n\n    case charCodes.dot:\n      readToken_dot();\n      return;\n\n    // Punctuation tokens.\n    case charCodes.leftParenthesis:\n      ++state.pos;\n      finishToken(tt.parenL);\n      return;\n    case charCodes.rightParenthesis:\n      ++state.pos;\n      finishToken(tt.parenR);\n      return;\n    case charCodes.semicolon:\n      ++state.pos;\n      finishToken(tt.semi);\n      return;\n    case charCodes.comma:\n      ++state.pos;\n      finishToken(tt.comma);\n      return;\n    case charCodes.leftSquareBracket:\n      ++state.pos;\n      finishToken(tt.bracketL);\n      return;\n    case charCodes.rightSquareBracket:\n      ++state.pos;\n      finishToken(tt.bracketR);\n      return;\n    case charCodes.leftCurlyBrace:\n      if (isFlowEnabled && input.charCodeAt(state.pos + 1) === charCodes.verticalBar) {\n        finishOp(tt.braceBarL, 2);\n      } else {\n        ++state.pos;\n        finishToken(tt.braceL);\n      }\n      return;\n    case charCodes.rightCurlyBrace:\n      ++state.pos;\n      finishToken(tt.braceR);\n      return;\n    case charCodes.colon:\n      if (input.charCodeAt(state.pos + 1) === charCodes.colon) {\n        finishOp(tt.doubleColon, 2);\n      } else {\n        ++state.pos;\n        finishToken(tt.colon);\n      }\n      return;\n    case charCodes.questionMark:\n      readToken_question();\n      return;\n    case charCodes.atSign:\n      ++state.pos;\n      finishToken(tt.at);\n      return;\n    case charCodes.graveAccent:\n      ++state.pos;\n      finishToken(tt.backQuote);\n      return;\n    case charCodes.digit0:\n      {\n        const nextChar = input.charCodeAt(state.pos + 1);\n        // '0x', '0X', '0o', '0O', '0b', '0B'\n        if (nextChar === charCodes.lowercaseX || nextChar === charCodes.uppercaseX || nextChar === charCodes.lowercaseO || nextChar === charCodes.uppercaseO || nextChar === charCodes.lowercaseB || nextChar === charCodes.uppercaseB) {\n          readRadixNumber();\n          return;\n        }\n      }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case charCodes.digit1:\n    case charCodes.digit2:\n    case charCodes.digit3:\n    case charCodes.digit4:\n    case charCodes.digit5:\n    case charCodes.digit6:\n    case charCodes.digit7:\n    case charCodes.digit8:\n    case charCodes.digit9:\n      readNumber(false);\n      return;\n\n    // Quotes produce strings.\n    case charCodes.quotationMark:\n    case charCodes.apostrophe:\n      readString(code);\n      return;\n\n    // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case charCodes.slash:\n      readToken_slash();\n      return;\n    case charCodes.percentSign:\n    case charCodes.asterisk:\n      readToken_mult_modulo(code);\n      return;\n    case charCodes.verticalBar:\n    case charCodes.ampersand:\n      readToken_pipe_amp(code);\n      return;\n    case charCodes.caret:\n      readToken_caret();\n      return;\n    case charCodes.plusSign:\n    case charCodes.dash:\n      readToken_plus_min(code);\n      return;\n    case charCodes.lessThan:\n      readToken_lt();\n      return;\n    case charCodes.greaterThan:\n      readToken_gt();\n      return;\n    case charCodes.equalsTo:\n    case charCodes.exclamationMark:\n      readToken_eq_excl(code);\n      return;\n    case charCodes.tilde:\n      finishOp(tt.tilde, 1);\n      return;\n    default:\n      break;\n  }\n  unexpected(`Unexpected character '${String.fromCharCode(code)}'`, state.pos);\n}\nfunction finishOp(type, size) {\n  state.pos += size;\n  finishToken(type);\n}\nfunction readRegexp() {\n  const start = state.pos;\n  let escaped = false;\n  let inClass = false;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated regular expression\", start);\n      return;\n    }\n    const code = input.charCodeAt(state.pos);\n    if (escaped) {\n      escaped = false;\n    } else {\n      if (code === charCodes.leftSquareBracket) {\n        inClass = true;\n      } else if (code === charCodes.rightSquareBracket && inClass) {\n        inClass = false;\n      } else if (code === charCodes.slash && !inClass) {\n        break;\n      }\n      escaped = code === charCodes.backslash;\n    }\n    ++state.pos;\n  }\n  ++state.pos;\n  // Need to use `skipWord` because '\\uXXXX' sequences are allowed here (don't ask).\n  skipWord();\n  finishToken(tt.regexp);\n}\n\n/**\n * Read a decimal integer. Note that this can't be unified with the similar code\n * in readRadixNumber (which also handles hex digits) because \"e\" needs to be\n * the end of the integer so that we can properly handle scientific notation.\n */\nfunction readInt() {\n  while (true) {\n    const code = input.charCodeAt(state.pos);\n    if (code >= charCodes.digit0 && code <= charCodes.digit9 || code === charCodes.underscore) {\n      state.pos++;\n    } else {\n      break;\n    }\n  }\n}\nfunction readRadixNumber() {\n  state.pos += 2; // 0x\n\n  // Walk to the end of the number, allowing hex digits.\n  while (true) {\n    const code = input.charCodeAt(state.pos);\n    if (code >= charCodes.digit0 && code <= charCodes.digit9 || code >= charCodes.lowercaseA && code <= charCodes.lowercaseF || code >= charCodes.uppercaseA && code <= charCodes.uppercaseF || code === charCodes.underscore) {\n      state.pos++;\n    } else {\n      break;\n    }\n  }\n  const nextChar = input.charCodeAt(state.pos);\n  if (nextChar === charCodes.lowercaseN) {\n    ++state.pos;\n    finishToken(tt.bigint);\n  } else {\n    finishToken(tt.num);\n  }\n}\n\n// Read an integer, octal integer, or floating-point number.\nfunction readNumber(startsWithDot) {\n  let isBigInt = false;\n  let isDecimal = false;\n  if (!startsWithDot) {\n    readInt();\n  }\n  let nextChar = input.charCodeAt(state.pos);\n  if (nextChar === charCodes.dot) {\n    ++state.pos;\n    readInt();\n    nextChar = input.charCodeAt(state.pos);\n  }\n  if (nextChar === charCodes.uppercaseE || nextChar === charCodes.lowercaseE) {\n    nextChar = input.charCodeAt(++state.pos);\n    if (nextChar === charCodes.plusSign || nextChar === charCodes.dash) {\n      ++state.pos;\n    }\n    readInt();\n    nextChar = input.charCodeAt(state.pos);\n  }\n  if (nextChar === charCodes.lowercaseN) {\n    ++state.pos;\n    isBigInt = true;\n  } else if (nextChar === charCodes.lowercaseM) {\n    ++state.pos;\n    isDecimal = true;\n  }\n  if (isBigInt) {\n    finishToken(tt.bigint);\n    return;\n  }\n  if (isDecimal) {\n    finishToken(tt.decimal);\n    return;\n  }\n  finishToken(tt.num);\n}\nfunction readString(quote) {\n  state.pos++;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated string constant\");\n      return;\n    }\n    const ch = input.charCodeAt(state.pos);\n    if (ch === charCodes.backslash) {\n      state.pos++;\n    } else if (ch === quote) {\n      break;\n    }\n    state.pos++;\n  }\n  state.pos++;\n  finishToken(tt.string);\n}\n\n// Reads template string tokens.\nfunction readTmplToken() {\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated template\");\n      return;\n    }\n    const ch = input.charCodeAt(state.pos);\n    if (ch === charCodes.graveAccent || ch === charCodes.dollarSign && input.charCodeAt(state.pos + 1) === charCodes.leftCurlyBrace) {\n      if (state.pos === state.start && match(tt.template)) {\n        if (ch === charCodes.dollarSign) {\n          state.pos += 2;\n          finishToken(tt.dollarBraceL);\n          return;\n        } else {\n          ++state.pos;\n          finishToken(tt.backQuote);\n          return;\n        }\n      }\n      finishToken(tt.template);\n      return;\n    }\n    if (ch === charCodes.backslash) {\n      state.pos++;\n    }\n    state.pos++;\n  }\n}\n\n// Skip to the end of the current word. Note that this is the same as the snippet at the end of\n// readWord, but calling skipWord from readWord seems to slightly hurt performance from some rough\n// measurements.\nexport function skipWord() {\n  while (state.pos < input.length) {\n    const ch = input.charCodeAt(state.pos);\n    if (IS_IDENTIFIER_CHAR[ch]) {\n      state.pos++;\n    } else if (ch === charCodes.backslash) {\n      // \\u\n      state.pos += 2;\n      if (input.charCodeAt(state.pos) === charCodes.leftCurlyBrace) {\n        while (state.pos < input.length && input.charCodeAt(state.pos) !== charCodes.rightCurlyBrace) {\n          state.pos++;\n        }\n        state.pos++;\n      }\n    } else {\n      break;\n    }\n  }\n}","map":{"version":3,"names":["input","isFlowEnabled","state","unexpected","charCodes","IS_IDENTIFIER_CHAR","IS_IDENTIFIER_START","IS_WHITESPACE","skipWhiteSpace","ContextualKeyword","readWord","TokenType","tt","IdentifierRole","Access","ExportAccess","TopLevelDeclaration","FunctionScopedDeclaration","BlockScopedDeclaration","ObjectShorthandTopLevelDeclaration","ObjectShorthandFunctionScopedDeclaration","ObjectShorthandBlockScopedDeclaration","ObjectShorthand","ImportDeclaration","ObjectKey","ImportAccess","JSXRole","NoChildren","OneChild","StaticChildren","KeyAfterPropSpread","isDeclaration","token","role","identifierRole","isNonTopLevelDeclaration","isTopLevelDeclaration","isBlockScopedDeclaration","isFunctionScopedDeclaration","isObjectShorthandDeclaration","Token","constructor","type","contextualKeyword","start","end","scopeDepth","isType","jsxRole","shadowsGlobal","isAsyncOperation","contextId","rhsEndIndex","isExpression","numNullishCoalesceStarts","numNullishCoalesceEnds","isOptionalChainStart","isOptionalChainEnd","subscriptStartIndex","nullishStartIndex","next","tokens","push","nextToken","nextTemplateToken","pos","readTmplToken","retokenizeSlashAsRegex","assign","readRegexp","pushTypeContext","existingTokensInType","i","length","oldIsType","popTypeContext","eat","match","eatTypeToken","tokenType","lookaheadType","snapshot","restoreFromSnapshot","TypeAndKeyword","lookaheadTypeAndKeyword","nextTokenStart","nextTokenStartSince","lastIndex","skip","exec","lookaheadCharCode","charCodeAt","skipSpace","finishToken","eof","readToken","code","backslash","atSign","getTokenFromCode","skipBlockComment","asterisk","slash","skipLineComment","startSkip","ch","lineFeed","carriageReturn","lineSeparator","paragraphSeparator","arguments","undefined","NONE","readToken_dot","nextChar","digit0","digit9","readNumber","dot","ellipsis","readToken_slash","equalsTo","finishOp","readToken_mult_modulo","star","modulo","width","exponent","greaterThan","readToken_pipe_amp","verticalBar","logicalOR","logicalAND","pipeline","rightCurlyBrace","braceBarR","bitwiseOR","bitwiseAND","readToken_caret","bitwiseXOR","readToken_plus_min","preIncDec","plusSign","plus","minus","readToken_lt","lessThan","bitShiftL","relationalOrEqual","readToken_gt","size","bitShiftR","rescan_gt","readToken_eq_excl","equality","arrow","eq","bang","readToken_question","nextChar2","questionMark","nullishCoalescing","questionDot","question","numberSign","hash","leftParenthesis","parenL","rightParenthesis","parenR","semicolon","semi","comma","leftSquareBracket","bracketL","rightSquareBracket","bracketR","leftCurlyBrace","braceBarL","braceL","braceR","colon","doubleColon","at","graveAccent","backQuote","lowercaseX","uppercaseX","lowercaseO","uppercaseO","lowercaseB","uppercaseB","readRadixNumber","digit1","digit2","digit3","digit4","digit5","digit6","digit7","digit8","quotationMark","apostrophe","readString","percentSign","ampersand","caret","dash","exclamationMark","tilde","String","fromCharCode","escaped","inClass","skipWord","regexp","readInt","underscore","lowercaseA","lowercaseF","uppercaseA","uppercaseF","lowercaseN","bigint","num","startsWithDot","isBigInt","isDecimal","uppercaseE","lowercaseE","lowercaseM","decimal","quote","string","dollarSign","template","dollarBraceL"],"sources":["/Users/manan/Desktop/hach-unicorn/StockSure/frontend1/node_modules/sucrase/dist/esm/parser/tokenizer/index.js"],"sourcesContent":["/* eslint max-len: 0 */\n\nimport {input, isFlowEnabled, state} from \"../traverser/base\";\nimport {unexpected} from \"../traverser/util\";\nimport {charCodes} from \"../util/charcodes\";\nimport {IS_IDENTIFIER_CHAR, IS_IDENTIFIER_START} from \"../util/identifier\";\nimport {IS_WHITESPACE, skipWhiteSpace} from \"../util/whitespace\";\nimport {ContextualKeyword} from \"./keywords\";\nimport readWord from \"./readWord\";\nimport { TokenType as tt} from \"./types\";\n\nexport var IdentifierRole; (function (IdentifierRole) {\n  const Access = 0; IdentifierRole[IdentifierRole[\"Access\"] = Access] = \"Access\";\n  const ExportAccess = Access + 1; IdentifierRole[IdentifierRole[\"ExportAccess\"] = ExportAccess] = \"ExportAccess\";\n  const TopLevelDeclaration = ExportAccess + 1; IdentifierRole[IdentifierRole[\"TopLevelDeclaration\"] = TopLevelDeclaration] = \"TopLevelDeclaration\";\n  const FunctionScopedDeclaration = TopLevelDeclaration + 1; IdentifierRole[IdentifierRole[\"FunctionScopedDeclaration\"] = FunctionScopedDeclaration] = \"FunctionScopedDeclaration\";\n  const BlockScopedDeclaration = FunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"BlockScopedDeclaration\"] = BlockScopedDeclaration] = \"BlockScopedDeclaration\";\n  const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandTopLevelDeclaration\"] = ObjectShorthandTopLevelDeclaration] = \"ObjectShorthandTopLevelDeclaration\";\n  const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandFunctionScopedDeclaration\"] = ObjectShorthandFunctionScopedDeclaration] = \"ObjectShorthandFunctionScopedDeclaration\";\n  const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandBlockScopedDeclaration\"] = ObjectShorthandBlockScopedDeclaration] = \"ObjectShorthandBlockScopedDeclaration\";\n  const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthand\"] = ObjectShorthand] = \"ObjectShorthand\";\n  // Any identifier bound in an import statement, e.g. both A and b from\n  // `import A, * as b from 'A';`\n  const ImportDeclaration = ObjectShorthand + 1; IdentifierRole[IdentifierRole[\"ImportDeclaration\"] = ImportDeclaration] = \"ImportDeclaration\";\n  const ObjectKey = ImportDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectKey\"] = ObjectKey] = \"ObjectKey\";\n  // The `foo` in `import {foo as bar} from \"./abc\";`.\n  const ImportAccess = ObjectKey + 1; IdentifierRole[IdentifierRole[\"ImportAccess\"] = ImportAccess] = \"ImportAccess\";\n})(IdentifierRole || (IdentifierRole = {}));\n\n/**\n * Extra information on jsxTagStart tokens, used to determine which of the three\n * jsx functions are called in the automatic transform.\n */\nexport var JSXRole; (function (JSXRole) {\n  // The element is self-closing or has a body that resolves to empty. We\n  // shouldn't emit children at all in this case.\n  const NoChildren = 0; JSXRole[JSXRole[\"NoChildren\"] = NoChildren] = \"NoChildren\";\n  // The element has a single explicit child, which might still be an arbitrary\n  // expression like an array. We should emit that expression as the children.\n  const OneChild = NoChildren + 1; JSXRole[JSXRole[\"OneChild\"] = OneChild] = \"OneChild\";\n  // The element has at least two explicitly-specified children or has spread\n  // children, so child positions are assumed to be \"static\". We should wrap\n  // these children in an array.\n  const StaticChildren = OneChild + 1; JSXRole[JSXRole[\"StaticChildren\"] = StaticChildren] = \"StaticChildren\";\n  // The element has a prop named \"key\" after a prop spread, so we should fall\n  // back to the createElement function.\n  const KeyAfterPropSpread = StaticChildren + 1; JSXRole[JSXRole[\"KeyAfterPropSpread\"] = KeyAfterPropSpread] = \"KeyAfterPropSpread\";\n})(JSXRole || (JSXRole = {}));\n\nexport function isDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n}\n\nexport function isNonTopLevelDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n}\n\nexport function isTopLevelDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ImportDeclaration\n  );\n}\n\nexport function isBlockScopedDeclaration(token) {\n  const role = token.identifierRole;\n  // Treat top-level declarations as block scope since the distinction doesn't matter here.\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n}\n\nexport function isFunctionScopedDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration\n  );\n}\n\nexport function isObjectShorthandDeclaration(token) {\n  return (\n    token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration ||\n    token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration\n  );\n}\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\nexport class Token {\n  constructor() {\n    this.type = state.type;\n    this.contextualKeyword = state.contextualKeyword;\n    this.start = state.start;\n    this.end = state.end;\n    this.scopeDepth = state.scopeDepth;\n    this.isType = state.isType;\n    this.identifierRole = null;\n    this.jsxRole = null;\n    this.shadowsGlobal = false;\n    this.isAsyncOperation = false;\n    this.contextId = null;\n    this.rhsEndIndex = null;\n    this.isExpression = false;\n    this.numNullishCoalesceStarts = 0;\n    this.numNullishCoalesceEnds = 0;\n    this.isOptionalChainStart = false;\n    this.isOptionalChainEnd = false;\n    this.subscriptStartIndex = null;\n    this.nullishStartIndex = null;\n  }\n\n  \n  \n  \n  \n  \n  \n  \n  \n  // Initially false for all tokens, then may be computed in a follow-up step that does scope\n  // analysis.\n  \n  // Initially false for all tokens, but may be set during transform to mark it as containing an\n  // await operation.\n  \n  \n  // For assignments, the index of the RHS. For export tokens, the end of the export.\n  \n  // For class tokens, records if the class is a class expression or a class statement.\n  \n  // Number of times to insert a `nullishCoalesce(` snippet before this token.\n  \n  // Number of times to insert a `)` snippet after this token.\n  \n  // If true, insert an `optionalChain([` snippet before this token.\n  \n  // If true, insert a `])` snippet after this token.\n  \n  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the \"root\" token for this\n  // subscript chain. This can be used to determine if this chain is an optional chain.\n  \n  // Tag for `??` operators to denote the root token for this nullish coalescing call.\n  \n}\n\n// ## Tokenizer\n\n// Move to the next token\nexport function next() {\n  state.tokens.push(new Token());\n  nextToken();\n}\n\n// Call instead of next when inside a template, since that needs to be handled differently.\nexport function nextTemplateToken() {\n  state.tokens.push(new Token());\n  state.start = state.pos;\n  readTmplToken();\n}\n\n// The tokenizer never parses regexes by default. Instead, the parser is responsible for\n// instructing it to parse a regex when we see a slash at the start of an expression.\nexport function retokenizeSlashAsRegex() {\n  if (state.type === tt.assign) {\n    --state.pos;\n  }\n  readRegexp();\n}\n\nexport function pushTypeContext(existingTokensInType) {\n  for (let i = state.tokens.length - existingTokensInType; i < state.tokens.length; i++) {\n    state.tokens[i].isType = true;\n  }\n  const oldIsType = state.isType;\n  state.isType = true;\n  return oldIsType;\n}\n\nexport function popTypeContext(oldIsType) {\n  state.isType = oldIsType;\n}\n\nexport function eat(type) {\n  if (match(type)) {\n    next();\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function eatTypeToken(tokenType) {\n  const oldIsType = state.isType;\n  state.isType = true;\n  eat(tokenType);\n  state.isType = oldIsType;\n}\n\nexport function match(type) {\n  return state.type === type;\n}\n\nexport function lookaheadType() {\n  const snapshot = state.snapshot();\n  next();\n  const type = state.type;\n  state.restoreFromSnapshot(snapshot);\n  return type;\n}\n\nexport class TypeAndKeyword {\n  \n  \n  constructor(type, contextualKeyword) {\n    this.type = type;\n    this.contextualKeyword = contextualKeyword;\n  }\n}\n\nexport function lookaheadTypeAndKeyword() {\n  const snapshot = state.snapshot();\n  next();\n  const type = state.type;\n  const contextualKeyword = state.contextualKeyword;\n  state.restoreFromSnapshot(snapshot);\n  return new TypeAndKeyword(type, contextualKeyword);\n}\n\nexport function nextTokenStart() {\n  return nextTokenStartSince(state.pos);\n}\n\nexport function nextTokenStartSince(pos) {\n  skipWhiteSpace.lastIndex = pos;\n  const skip = skipWhiteSpace.exec(input);\n  return pos + skip[0].length;\n}\n\nexport function lookaheadCharCode() {\n  return input.charCodeAt(nextTokenStart());\n}\n\n// Read a single token, updating the parser object's token-related\n// properties.\nexport function nextToken() {\n  skipSpace();\n  state.start = state.pos;\n  if (state.pos >= input.length) {\n    const tokens = state.tokens;\n    // We normally run past the end a bit, but if we're way past the end, avoid an infinite loop.\n    // Also check the token positions rather than the types since sometimes we rewrite the token\n    // type to something else.\n    if (\n      tokens.length >= 2 &&\n      tokens[tokens.length - 1].start >= input.length &&\n      tokens[tokens.length - 2].start >= input.length\n    ) {\n      unexpected(\"Unexpectedly reached the end of input.\");\n    }\n    finishToken(tt.eof);\n    return;\n  }\n  readToken(input.charCodeAt(state.pos));\n}\n\nfunction readToken(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (\n    IS_IDENTIFIER_START[code] ||\n    code === charCodes.backslash ||\n    (code === charCodes.atSign && input.charCodeAt(state.pos + 1) === charCodes.atSign)\n  ) {\n    readWord();\n  } else {\n    getTokenFromCode(code);\n  }\n}\n\nfunction skipBlockComment() {\n  while (\n    input.charCodeAt(state.pos) !== charCodes.asterisk ||\n    input.charCodeAt(state.pos + 1) !== charCodes.slash\n  ) {\n    state.pos++;\n    if (state.pos > input.length) {\n      unexpected(\"Unterminated comment\", state.pos - 2);\n      return;\n    }\n  }\n  state.pos += 2;\n}\n\nexport function skipLineComment(startSkip) {\n  let ch = input.charCodeAt((state.pos += startSkip));\n  if (state.pos < input.length) {\n    while (\n      ch !== charCodes.lineFeed &&\n      ch !== charCodes.carriageReturn &&\n      ch !== charCodes.lineSeparator &&\n      ch !== charCodes.paragraphSeparator &&\n      ++state.pos < input.length\n    ) {\n      ch = input.charCodeAt(state.pos);\n    }\n  }\n}\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments.\nexport function skipSpace() {\n  while (state.pos < input.length) {\n    const ch = input.charCodeAt(state.pos);\n    switch (ch) {\n      case charCodes.carriageReturn:\n        if (input.charCodeAt(state.pos + 1) === charCodes.lineFeed) {\n          ++state.pos;\n        }\n\n      case charCodes.lineFeed:\n      case charCodes.lineSeparator:\n      case charCodes.paragraphSeparator:\n        ++state.pos;\n        break;\n\n      case charCodes.slash:\n        switch (input.charCodeAt(state.pos + 1)) {\n          case charCodes.asterisk:\n            state.pos += 2;\n            skipBlockComment();\n            break;\n\n          case charCodes.slash:\n            skipLineComment(2);\n            break;\n\n          default:\n            return;\n        }\n        break;\n\n      default:\n        if (IS_WHITESPACE[ch]) {\n          ++state.pos;\n        } else {\n          return;\n        }\n    }\n  }\n}\n\n// Called at the end of every token. Sets various fields, and skips the space after the token, so\n// that the next one's `start` will point at the right position.\nexport function finishToken(\n  type,\n  contextualKeyword = ContextualKeyword.NONE,\n) {\n  state.end = state.pos;\n  state.type = type;\n  state.contextualKeyword = contextualKeyword;\n}\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\nfunction readToken_dot() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar >= charCodes.digit0 && nextChar <= charCodes.digit9) {\n    readNumber(true);\n    return;\n  }\n\n  if (nextChar === charCodes.dot && input.charCodeAt(state.pos + 2) === charCodes.dot) {\n    state.pos += 3;\n    finishToken(tt.ellipsis);\n  } else {\n    ++state.pos;\n    finishToken(tt.dot);\n  }\n}\n\nfunction readToken_slash() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else {\n    finishOp(tt.slash, 1);\n  }\n}\n\nfunction readToken_mult_modulo(code) {\n  // '%*'\n  let tokenType = code === charCodes.asterisk ? tt.star : tt.modulo;\n  let width = 1;\n  let nextChar = input.charCodeAt(state.pos + 1);\n\n  // Exponentiation operator **\n  if (code === charCodes.asterisk && nextChar === charCodes.asterisk) {\n    width++;\n    nextChar = input.charCodeAt(state.pos + 2);\n    tokenType = tt.exponent;\n  }\n\n  // Match *= or %=, disallowing *=> which can be valid in flow.\n  if (\n    nextChar === charCodes.equalsTo &&\n    input.charCodeAt(state.pos + 2) !== charCodes.greaterThan\n  ) {\n    width++;\n    tokenType = tt.assign;\n  }\n\n  finishOp(tokenType, width);\n}\n\nfunction readToken_pipe_amp(code) {\n  // '|&'\n  const nextChar = input.charCodeAt(state.pos + 1);\n\n  if (nextChar === code) {\n    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {\n      // ||= or &&=\n      finishOp(tt.assign, 3);\n    } else {\n      // || or &&\n      finishOp(code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND, 2);\n    }\n    return;\n  }\n\n  if (code === charCodes.verticalBar) {\n    // '|>'\n    if (nextChar === charCodes.greaterThan) {\n      finishOp(tt.pipeline, 2);\n      return;\n    } else if (nextChar === charCodes.rightCurlyBrace && isFlowEnabled) {\n      // '|}'\n      finishOp(tt.braceBarR, 2);\n      return;\n    }\n  }\n\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n    return;\n  }\n\n  finishOp(code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND, 1);\n}\n\nfunction readToken_caret() {\n  // '^'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else {\n    finishOp(tt.bitwiseXOR, 1);\n  }\n}\n\nfunction readToken_plus_min(code) {\n  // '+-'\n  const nextChar = input.charCodeAt(state.pos + 1);\n\n  if (nextChar === code) {\n    // Tentatively call this a prefix operator, but it might be changed to postfix later.\n    finishOp(tt.preIncDec, 2);\n    return;\n  }\n\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else if (code === charCodes.plusSign) {\n    finishOp(tt.plus, 1);\n  } else {\n    finishOp(tt.minus, 1);\n  }\n}\n\nfunction readToken_lt() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n\n  if (nextChar === charCodes.lessThan) {\n    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {\n      finishOp(tt.assign, 3);\n      return;\n    }\n    // We see <<, but need to be really careful about whether to treat it as a\n    // true left-shift or as two < tokens.\n    if (state.isType) {\n      // Within a type, << might come up in a snippet like `Array<<T>() => void>`,\n      // so treat it as two < tokens. Importantly, this should only override <<\n      // rather than other tokens like <= . If we treated <= as < in a type\n      // context, then the snippet `a as T <= 1` would incorrectly start parsing\n      // a type argument on T. We don't need to worry about `a as T << 1`\n      // because TypeScript disallows that syntax.\n      finishOp(tt.lessThan, 1);\n    } else {\n      // Outside a type, this might be a true left-shift operator, or it might\n      // still be two open-type-arg tokens, such as in `f<<T>() => void>()`. We\n      // look at the token while considering the `f`, so we don't yet know that\n      // we're in a type context. In this case, we initially tokenize as a\n      // left-shift and correct after-the-fact as necessary in\n      // tsParseTypeArgumentsWithPossibleBitshift .\n      finishOp(tt.bitShiftL, 2);\n    }\n    return;\n  }\n\n  if (nextChar === charCodes.equalsTo) {\n    // <=\n    finishOp(tt.relationalOrEqual, 2);\n  } else {\n    finishOp(tt.lessThan, 1);\n  }\n}\n\nfunction readToken_gt() {\n  if (state.isType) {\n    // Avoid right-shift for things like `Array<Array<string>>` and\n    // greater-than-or-equal for things like `const a: Array<number>=[];`.\n    finishOp(tt.greaterThan, 1);\n    return;\n  }\n\n  const nextChar = input.charCodeAt(state.pos + 1);\n\n  if (nextChar === charCodes.greaterThan) {\n    const size = input.charCodeAt(state.pos + 2) === charCodes.greaterThan ? 3 : 2;\n    if (input.charCodeAt(state.pos + size) === charCodes.equalsTo) {\n      finishOp(tt.assign, size + 1);\n      return;\n    }\n    finishOp(tt.bitShiftR, size);\n    return;\n  }\n\n  if (nextChar === charCodes.equalsTo) {\n    // >=\n    finishOp(tt.relationalOrEqual, 2);\n  } else {\n    finishOp(tt.greaterThan, 1);\n  }\n}\n\n/**\n * Called after `as` expressions in TS; we're switching from a type to a\n * non-type context, so a > token may actually be >= . This is needed because >=\n * must be tokenized as a > in a type context because of code like\n * `const x: Array<T>=[];`, but `a as T >= 1` is a code example where it must be\n * treated as >=.\n *\n * Notably, this only applies to >, not <. In a code snippet like `a as T <= 1`,\n * we must NOT tokenize as <, or else the type parser will start parsing a type\n * argument and fail.\n */\nexport function rescan_gt() {\n  if (state.type === tt.greaterThan) {\n    state.pos -= 1;\n    readToken_gt();\n  }\n}\n\nfunction readToken_eq_excl(code) {\n  // '=!'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.equality, input.charCodeAt(state.pos + 2) === charCodes.equalsTo ? 3 : 2);\n    return;\n  }\n  if (code === charCodes.equalsTo && nextChar === charCodes.greaterThan) {\n    // '=>'\n    state.pos += 2;\n    finishToken(tt.arrow);\n    return;\n  }\n  finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);\n}\n\nfunction readToken_question() {\n  // '?'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  const nextChar2 = input.charCodeAt(state.pos + 2);\n  if (\n    nextChar === charCodes.questionMark &&\n    // In Flow (but not TypeScript), ??string is a valid type that should be\n    // tokenized as two individual ? tokens.\n    !(isFlowEnabled && state.isType)\n  ) {\n    if (nextChar2 === charCodes.equalsTo) {\n      // '??='\n      finishOp(tt.assign, 3);\n    } else {\n      // '??'\n      finishOp(tt.nullishCoalescing, 2);\n    }\n  } else if (\n    nextChar === charCodes.dot &&\n    !(nextChar2 >= charCodes.digit0 && nextChar2 <= charCodes.digit9)\n  ) {\n    // '.' not followed by a number\n    state.pos += 2;\n    finishToken(tt.questionDot);\n  } else {\n    ++state.pos;\n    finishToken(tt.question);\n  }\n}\n\nexport function getTokenFromCode(code) {\n  switch (code) {\n    case charCodes.numberSign:\n      ++state.pos;\n      finishToken(tt.hash);\n      return;\n\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n\n    case charCodes.dot:\n      readToken_dot();\n      return;\n\n    // Punctuation tokens.\n    case charCodes.leftParenthesis:\n      ++state.pos;\n      finishToken(tt.parenL);\n      return;\n    case charCodes.rightParenthesis:\n      ++state.pos;\n      finishToken(tt.parenR);\n      return;\n    case charCodes.semicolon:\n      ++state.pos;\n      finishToken(tt.semi);\n      return;\n    case charCodes.comma:\n      ++state.pos;\n      finishToken(tt.comma);\n      return;\n    case charCodes.leftSquareBracket:\n      ++state.pos;\n      finishToken(tt.bracketL);\n      return;\n    case charCodes.rightSquareBracket:\n      ++state.pos;\n      finishToken(tt.bracketR);\n      return;\n\n    case charCodes.leftCurlyBrace:\n      if (isFlowEnabled && input.charCodeAt(state.pos + 1) === charCodes.verticalBar) {\n        finishOp(tt.braceBarL, 2);\n      } else {\n        ++state.pos;\n        finishToken(tt.braceL);\n      }\n      return;\n\n    case charCodes.rightCurlyBrace:\n      ++state.pos;\n      finishToken(tt.braceR);\n      return;\n\n    case charCodes.colon:\n      if (input.charCodeAt(state.pos + 1) === charCodes.colon) {\n        finishOp(tt.doubleColon, 2);\n      } else {\n        ++state.pos;\n        finishToken(tt.colon);\n      }\n      return;\n\n    case charCodes.questionMark:\n      readToken_question();\n      return;\n    case charCodes.atSign:\n      ++state.pos;\n      finishToken(tt.at);\n      return;\n\n    case charCodes.graveAccent:\n      ++state.pos;\n      finishToken(tt.backQuote);\n      return;\n\n    case charCodes.digit0: {\n      const nextChar = input.charCodeAt(state.pos + 1);\n      // '0x', '0X', '0o', '0O', '0b', '0B'\n      if (\n        nextChar === charCodes.lowercaseX ||\n        nextChar === charCodes.uppercaseX ||\n        nextChar === charCodes.lowercaseO ||\n        nextChar === charCodes.uppercaseO ||\n        nextChar === charCodes.lowercaseB ||\n        nextChar === charCodes.uppercaseB\n      ) {\n        readRadixNumber();\n        return;\n      }\n    }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case charCodes.digit1:\n    case charCodes.digit2:\n    case charCodes.digit3:\n    case charCodes.digit4:\n    case charCodes.digit5:\n    case charCodes.digit6:\n    case charCodes.digit7:\n    case charCodes.digit8:\n    case charCodes.digit9:\n      readNumber(false);\n      return;\n\n    // Quotes produce strings.\n    case charCodes.quotationMark:\n    case charCodes.apostrophe:\n      readString(code);\n      return;\n\n    // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case charCodes.slash:\n      readToken_slash();\n      return;\n\n    case charCodes.percentSign:\n    case charCodes.asterisk:\n      readToken_mult_modulo(code);\n      return;\n\n    case charCodes.verticalBar:\n    case charCodes.ampersand:\n      readToken_pipe_amp(code);\n      return;\n\n    case charCodes.caret:\n      readToken_caret();\n      return;\n\n    case charCodes.plusSign:\n    case charCodes.dash:\n      readToken_plus_min(code);\n      return;\n\n    case charCodes.lessThan:\n      readToken_lt();\n      return;\n\n    case charCodes.greaterThan:\n      readToken_gt();\n      return;\n\n    case charCodes.equalsTo:\n    case charCodes.exclamationMark:\n      readToken_eq_excl(code);\n      return;\n\n    case charCodes.tilde:\n      finishOp(tt.tilde, 1);\n      return;\n\n    default:\n      break;\n  }\n\n  unexpected(`Unexpected character '${String.fromCharCode(code)}'`, state.pos);\n}\n\nfunction finishOp(type, size) {\n  state.pos += size;\n  finishToken(type);\n}\n\nfunction readRegexp() {\n  const start = state.pos;\n  let escaped = false;\n  let inClass = false;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated regular expression\", start);\n      return;\n    }\n    const code = input.charCodeAt(state.pos);\n    if (escaped) {\n      escaped = false;\n    } else {\n      if (code === charCodes.leftSquareBracket) {\n        inClass = true;\n      } else if (code === charCodes.rightSquareBracket && inClass) {\n        inClass = false;\n      } else if (code === charCodes.slash && !inClass) {\n        break;\n      }\n      escaped = code === charCodes.backslash;\n    }\n    ++state.pos;\n  }\n  ++state.pos;\n  // Need to use `skipWord` because '\\uXXXX' sequences are allowed here (don't ask).\n  skipWord();\n\n  finishToken(tt.regexp);\n}\n\n/**\n * Read a decimal integer. Note that this can't be unified with the similar code\n * in readRadixNumber (which also handles hex digits) because \"e\" needs to be\n * the end of the integer so that we can properly handle scientific notation.\n */\nfunction readInt() {\n  while (true) {\n    const code = input.charCodeAt(state.pos);\n    if ((code >= charCodes.digit0 && code <= charCodes.digit9) || code === charCodes.underscore) {\n      state.pos++;\n    } else {\n      break;\n    }\n  }\n}\n\nfunction readRadixNumber() {\n  state.pos += 2; // 0x\n\n  // Walk to the end of the number, allowing hex digits.\n  while (true) {\n    const code = input.charCodeAt(state.pos);\n    if (\n      (code >= charCodes.digit0 && code <= charCodes.digit9) ||\n      (code >= charCodes.lowercaseA && code <= charCodes.lowercaseF) ||\n      (code >= charCodes.uppercaseA && code <= charCodes.uppercaseF) ||\n      code === charCodes.underscore\n    ) {\n      state.pos++;\n    } else {\n      break;\n    }\n  }\n\n  const nextChar = input.charCodeAt(state.pos);\n  if (nextChar === charCodes.lowercaseN) {\n    ++state.pos;\n    finishToken(tt.bigint);\n  } else {\n    finishToken(tt.num);\n  }\n}\n\n// Read an integer, octal integer, or floating-point number.\nfunction readNumber(startsWithDot) {\n  let isBigInt = false;\n  let isDecimal = false;\n\n  if (!startsWithDot) {\n    readInt();\n  }\n\n  let nextChar = input.charCodeAt(state.pos);\n  if (nextChar === charCodes.dot) {\n    ++state.pos;\n    readInt();\n    nextChar = input.charCodeAt(state.pos);\n  }\n\n  if (nextChar === charCodes.uppercaseE || nextChar === charCodes.lowercaseE) {\n    nextChar = input.charCodeAt(++state.pos);\n    if (nextChar === charCodes.plusSign || nextChar === charCodes.dash) {\n      ++state.pos;\n    }\n    readInt();\n    nextChar = input.charCodeAt(state.pos);\n  }\n\n  if (nextChar === charCodes.lowercaseN) {\n    ++state.pos;\n    isBigInt = true;\n  } else if (nextChar === charCodes.lowercaseM) {\n    ++state.pos;\n    isDecimal = true;\n  }\n\n  if (isBigInt) {\n    finishToken(tt.bigint);\n    return;\n  }\n\n  if (isDecimal) {\n    finishToken(tt.decimal);\n    return;\n  }\n\n  finishToken(tt.num);\n}\n\nfunction readString(quote) {\n  state.pos++;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated string constant\");\n      return;\n    }\n    const ch = input.charCodeAt(state.pos);\n    if (ch === charCodes.backslash) {\n      state.pos++;\n    } else if (ch === quote) {\n      break;\n    }\n    state.pos++;\n  }\n  state.pos++;\n  finishToken(tt.string);\n}\n\n// Reads template string tokens.\nfunction readTmplToken() {\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated template\");\n      return;\n    }\n    const ch = input.charCodeAt(state.pos);\n    if (\n      ch === charCodes.graveAccent ||\n      (ch === charCodes.dollarSign && input.charCodeAt(state.pos + 1) === charCodes.leftCurlyBrace)\n    ) {\n      if (state.pos === state.start && match(tt.template)) {\n        if (ch === charCodes.dollarSign) {\n          state.pos += 2;\n          finishToken(tt.dollarBraceL);\n          return;\n        } else {\n          ++state.pos;\n          finishToken(tt.backQuote);\n          return;\n        }\n      }\n      finishToken(tt.template);\n      return;\n    }\n    if (ch === charCodes.backslash) {\n      state.pos++;\n    }\n    state.pos++;\n  }\n}\n\n// Skip to the end of the current word. Note that this is the same as the snippet at the end of\n// readWord, but calling skipWord from readWord seems to slightly hurt performance from some rough\n// measurements.\nexport function skipWord() {\n  while (state.pos < input.length) {\n    const ch = input.charCodeAt(state.pos);\n    if (IS_IDENTIFIER_CHAR[ch]) {\n      state.pos++;\n    } else if (ch === charCodes.backslash) {\n      // \\u\n      state.pos += 2;\n      if (input.charCodeAt(state.pos) === charCodes.leftCurlyBrace) {\n        while (\n          state.pos < input.length &&\n          input.charCodeAt(state.pos) !== charCodes.rightCurlyBrace\n        ) {\n          state.pos++;\n        }\n        state.pos++;\n      }\n    } else {\n      break;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}